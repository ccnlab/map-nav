// ta_Dump File v3.0 -- code v8.5.2.0 rev11409
LeabraProject .projects[0] { 
 Doc_Group @.docs = [1] {
  taDoc @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
   };
  };
 };

 Wizard_Group @.wizards = [1] {
  LeabraWizard @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
   };
  };
 };

 ControlPanel_Group @.ctrl_panels = [2] {
  ControlPanel @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
   };

   ControlPanelMember_Group @.mbrs = [2] {
    ControlPanelMember @[0] { };
    ControlPanelMember @[1] { };
   };

   ControlPanelMethod_Group @.mths = [4] {
    ControlPanelMethod @[0] { };
    ControlPanelMethod @[1] { };
    ControlPanelMethod @[2] { };
    ControlPanelMethod @[3] { };
   };
  };
  ClusterRun @[1] { 
   ControlPanelMember_Group @.mbrs = [0] {
   };

   ControlPanelMethod_Group @.mths = [0] {
   };

   ParamSearchAlgo_List @.search_algos = [0] {
   };
  };
 };

 ParamSet_Group @.active_params = [0] {
 };

 ArchivedParams_Group @.archived_params = [0] {
 };

 DataTable_Group @.data = [0] {
  DataTable_Group @.gp[0] = [3] { 
   DataTable @[0] { 
    DataTableCols @.data = [3] {
     String_Data @[0] { };
     float_Data @[1] { };
     float_Data @[2] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
   DataTable @[1] { 
    DataTableCols @.data = [7] {
     String_Data @[0] { };
     String_Data @[1] { };
     float_Data @[2] { };
     float_Data @[3] { };
     float_Data @[4] { };
     float_Data @[5] { };
     float_Data @[6] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
   DataTable @[2] { 
    DataTableCols @.data = [6] {
     String_Data @[0] { };
     String_Data @[1] { };
     float_Data @[2] { };
     float_Data @[3] { };
     float_Data @[4] { };
     float_Data @[5] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
  };
  DataTable_Group @.gp[1] = [2] { 
   DataTable @[0] { 
    DataTableCols @.data = [11] {
     int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     String_Data @[2] { };
     int_Data @[3] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[4] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     String_Data @[5] { };
     String_Data @[6] { };
     float_Data @[7] { };
     float_Data @[8] { };
     float_Data @[9] { };
     float_Data @[10] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
   DataTable @[1] { 
    DataTableCols @.data = [26] {
     int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     String_Data @[2] { };
     float_Data @[3] { };
     float_Data @[4] { };
     float_Data @[5] { };
     float_Data @[6] { };
     float_Data @[7] { };
     float_Data @[8] { };
     float_Data @[9] { };
     float_Data @[10] { };
     float_Data @[11] { };
     float_Data @[12] { };
     float_Data @[13] { };
     float_Data @[14] { };
     float_Data @[15] { };
     float_Data @[16] { };
     float_Data @[17] { };
     float_Data @[18] { };
     float_Data @[19] { };
     float_Data @[20] { };
     float_Data @[21] { };
     float_Data @[22] { };
     float_Data @[23] { };
     float_Data @[24] { };
     float_Data @[25] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
  };
  DataTable_Group @.gp[2] { 
  };
  DataTable_Group @.gp[3] = [1] { 
   DataTable @[0] { 
    DataTableCols @.data = [15] {
     String_Data @[0] { };
     String_Data @[1] { };
     String_Data @[2] { };
     String_Data @[3] { };
     String_Data @[4] { };
     int_Data @[5] { };
     int_Data @[6] { };
     int_Data @[7] { };
     int_Data @[8] { };
     int_Data @[9] { };
     int_Data @[10] { };
     int_Data @[11] { };
     String_Data @[12] { };
     int_Data @[13] { };
     int_Data @[14] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
  };
 };

 Program_TopGroup @.programs = [1] {
  Program @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserData_DocLink @[0] { };
   };

   ProgObjList @.objs = [0] {
   };

   ProgVar_List @.objs_vars = [0] {
   };

   ProgType_List @.types = [0] {
   };

   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgVar_List @.vars = [12] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
    ProgVar @[3] { };
    ProgVar @[4] { };
    ProgVar @[5] { };
    ProgVar @[6] { };
    ProgVar @[7] { };
    ProgVar @[8] { };
    ProgVar @[9] { };
    ProgVar @[10] { };
    ProgVar @[11] { };
   };

   Function_List @.functions = [1] {
    Function @[0] { 
     ProgVar_List @.args = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };

     ProgEl_List @.fun_code = [4] {
      If @[0] { 
       ProgEl_List @.true_code = [1] {
	ReturnExpr @[0] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      PrintExpr @[2] { };
      ReturnExpr @[3] { };
     };
    };
   };

   ProgEl_List @.init_code = [0] {
   };

   ProgEl_List @.prog_code = [40] {
    If @[0] { 
     ProgEl_List @.true_code = [1] {
      ReturnExpr @[0] { };
     };
    };
    RegisterArgs @[1] { };
    PrintExpr @[2] { };
    Comment @[3] { };
    ProgVarFmArg @[4] { };
    ProgVarFmArg @[5] { };
    ProgVarFmArg @[6] { };
    ProgVarFmArg @[7] { };
    ProgVarFmArg @[8] { };
    Comment @[9] { };
    ProgVarFmArg @[10] { };
    ProgVarFmArg @[11] { };
    OtherProgramVar @[12] { };
    Comment @[13] { };
    MethodCall @[14] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    Comment @[15] { };
    Comment @[16] { };
    MemberFmArg @[17] { };
    MemberFmArg @[18] { };
    MemberFmArg @[19] { };
    MemberFmArg @[20] { };
    Comment @[21] { };
    Comment @[22] { };
    If @[23] { 
     ProgEl_List @.true_code = [1] {
      MiscCall @[0] { 
       ProgArg_List @.meth_args = [9] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
	ProgArg @[4] { };
	ProgArg @[5] { };
	ProgArg @[6] { };
	ProgArg @[7] { };
	ProgArg @[8] { };
       };
      };
     };
    };
    AssignExpr @[24] { };
    Comment @[25] { };
    DataColsFmArgs @[26] { };
    Comment @[27] { };
    If @[28] { 
     ProgEl_List @.true_code = [4] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      ProgVarFmArg @[1] { };
      MiscCall @[2] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      VarIncr @[3] { };
     };
    };
    MethodCall @[29] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    MiscCall @[30] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[31] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    MethodCall @[32] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    If @[33] { 
     ProgEl_List @.true_code = [2] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
     };
    };
    OtherProgramVar @[34] { };
    Comment @[35] { };
    DataVarProg @[36] { };
    ProgramCallVar @[37] { 
     ProgArg_List @.prog_args = [1] {
      ProgArg @[0] { };
     };
    };
    PrintExpr @[38] { };
    ProgramCall @[39] { 
     ProgArg_List @.prog_args = [1] {
      ProgArg @[0] { };
     };
    };
   };
  };
  Program_Group @.gp[0] = [1] { 
   Program @[0] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [6] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [4] {
     Comment @[0] { };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [4] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [3] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
      };
     };
     If @[3] { 
      ProgEl_List @.true_code = [2] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [4] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	 ProgArg @[2] { };
	 ProgArg @[3] { };
	};
       };
       MethodCall @[1] { 
	ProgArg_List @.meth_args = [3] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	 ProgArg @[2] { };
	};
       };
      };
     };
    };
   };
  };
  Program_Group @.gp[1] = [3] { 
   Program @[0] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [1] {
     NetCounterInit @[0] { };
    };

    ProgEl_List @.prog_code = [3] {
     If @[0] { 
      ProgEl_List @.true_code = [1] {
       NetCounterInit @[0] { };
      };
     };
     Else @[1] { 
      ProgEl_List @.true_code = [1] {
       MemberAssign @[0] { };
      };
     };
     WhileLoop @[2] { 
      ProgEl_List @.loop_code = [2] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
       NetCounterIncr @[1] { };
      };
     };
    };
   };
   Program @[1] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [5] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [2] {
     AssignExpr @[0] { };
     WtInitPrompt @[1] { 
      ProgEl_List @.yes_code = [3] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       MethodCall @[1] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       PrintExpr @[2] { };
      };
     };
    };

    ProgEl_List @.prog_code = [4] {
     AssignExpr @[0] { };
     DataVarProg @[1] { };
     ProgramCallVar @[2] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     WhileLoop @[3] { 
      ProgEl_List @.loop_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [3] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	 ProgArg @[2] { };
	};
       };
      };
     };
    };
   };
   Program @[2] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [1] {
     ProgramCallVar @[0] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
    };
   };
   Program_Group @.gp[0] = [3] { 
    Program @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [0] {
     };

     ProgVar_List @.objs_vars = [0] {
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };

     ProgVar_List @.vars = [1] {
      ProgVar @[0] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [0] {
     };

     ProgEl_List @.prog_code = [5] {
      ProgramCall @[0] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      ProgramCall @[1] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      ProgramCall @[2] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      If @[3] { 
       ProgEl_List @.true_code = [1] {
	MemberAssign @[0] { };
       };
      };
      Else @[4] { 
       ProgEl_List @.true_code = [1] {
	MemberAssign @[0] { };
       };
      };
     };
    };
    Program @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [0] {
     };

     ProgVar_List @.objs_vars = [0] {
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };

     ProgVar_List @.vars = [1] {
      ProgVar @[0] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [0] {
     };

     ProgEl_List @.prog_code = [5] {
      ProgramCall @[0] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      ProgramCall @[1] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      ProgramCall @[2] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      If @[3] { 
       ProgEl_List @.true_code = [1] {
	MemberAssign @[0] { };
       };
      };
      Else @[4] { 
       ProgEl_List @.true_code = [1] {
	MemberAssign @[0] { };
       };
      };
     };
    };
    Program @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [0] {
     };

     ProgVar_List @.objs_vars = [0] {
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };

     ProgVar_List @.vars = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [0] {
     };

     ProgEl_List @.prog_code = [8] {
      ProgramCall @[0] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      AssignExpr @[1] { };
      AssignExpr @[2] { };
      ProgramCall @[3] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[4] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      ProgramCall @[5] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      If @[6] { 
       ProgEl_List @.true_code = [1] {
	MemberAssign @[0] { };
       };
      };
      Else @[7] { 
       ProgEl_List @.true_code = [1] {
	MemberAssign @[0] { };
       };
      };
     };
    };
   };
   Program_Group @.gp[1] = [3] { 
    Program @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [0] {
     };

     ProgVar_List @.objs_vars = [0] {
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };

     ProgVar_List @.vars = [4] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [0] {
     };

     ProgEl_List @.prog_code = [8] {
      Comment @[0] { };
      MemberAssign @[1] { };
      ProgramCall @[2] { 
       ProgArg_List @.prog_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      Comment @[3] { };
      ProgramCall @[4] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      ProgramCall @[5] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      MemberAssign @[6] { };
      If @[7] { 
       ProgEl_List @.true_code = [4] {
	ProgramCall @[0] { 
	 ProgArg_List @.prog_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	MemberAssign @[1] { };
	If @[2] { 
	 ProgEl_List @.true_code = [2] {
	  ProgramCall @[0] { 
	   ProgArg_List @.prog_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	  ReturnExpr @[1] { };
	 };
	};
	ProgramCall @[3] { 
	 ProgArg_List @.prog_args = [1] {
	  ProgArg @[0] { };
	 };
	};
       };
      };
     };
    };
    Program @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [0] {
     };

     ProgVar_List @.objs_vars = [0] {
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };

     ProgVar_List @.vars = [4] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [0] {
     };

     ProgEl_List @.prog_code = [9] {
      Comment @[0] { };
      MemberAssign @[1] { };
      If @[2] { 
       ProgEl_List @.true_code = [1] {
	If @[0] { 
	 ProgEl_List @.true_code = [1] {
	  ProgramCall @[0] { 
	   ProgArg_List @.prog_args = [0] {
	   };
	  };
	 };
	};
       };
      };
      ProgramCall @[3] { 
       ProgArg_List @.prog_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      Comment @[4] { };
      ProgramCall @[5] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      ProgramCall @[6] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      MemberAssign @[7] { };
      If @[8] { 
       ProgEl_List @.true_code = [4] {
	ProgramCall @[0] { 
	 ProgArg_List @.prog_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	MemberAssign @[1] { };
	If @[2] { 
	 ProgEl_List @.true_code = [2] {
	  ProgramCall @[0] { 
	   ProgArg_List @.prog_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	  ReturnExpr @[1] { };
	 };
	};
	ProgramCall @[3] { 
	 ProgArg_List @.prog_args = [1] {
	  ProgArg @[0] { };
	 };
	};
       };
      };
     };
    };
    Program @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [0] {
     };

     ProgVar_List @.objs_vars = [0] {
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };

     ProgVar_List @.vars = [4] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [0] {
     };

     ProgEl_List @.prog_code = [9] {
      Comment @[0] { };
      MemberAssign @[1] { };
      If @[2] { 
       ProgEl_List @.true_code = [1] {
	If @[0] { 
	 ProgEl_List @.true_code = [1] {
	  ProgramCall @[0] { 
	   ProgArg_List @.prog_args = [0] {
	   };
	  };
	 };
	};
       };
      };
      ProgramCall @[3] { 
       ProgArg_List @.prog_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      Comment @[4] { };
      ProgramCall @[5] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      ProgramCall @[6] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      MemberAssign @[7] { };
      If @[8] { 
       ProgEl_List @.true_code = [4] {
	ProgramCall @[0] { 
	 ProgArg_List @.prog_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	MemberAssign @[1] { };
	If @[2] { 
	 ProgEl_List @.true_code = [2] {
	  ProgramCall @[0] { 
	   ProgArg_List @.prog_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	  ReturnExpr @[1] { };
	 };
	};
	ProgramCall @[3] { 
	 ProgArg_List @.prog_args = [1] {
	  ProgArg @[0] { };
	 };
	};
       };
      };
     };
    };
   };
  };
  Program_Group @.gp[2] = [0] { 
   Program_Group @.gp[0] = [1] { 
    Program @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [1] {
      TimeUsed @[0] { };
     };

     ProgVar_List @.objs_vars = [1] {
      ProgVar @[0] { };
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [3] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
     };

     ProgVar_List @.vars = [7] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
      ProgVar @[6] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [1] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
     };

     ProgEl_List @.prog_code = [48] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      Comment @[1] { };
      ProgramCall @[2] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      ProgramCall @[3] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      ProgramCall @[4] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      DataVarProg @[5] { };
      MemberAssign @[6] { };
      If @[7] { 
       ProgEl_List @.true_code = [2] {
	Comment @[0] { };
	MemberAssign @[1] { };
       };
      };
      Else @[8] { 
       ProgEl_List @.true_code = [2] {
	If @[0] { 
	 ProgEl_List @.true_code = [2] {
	  Comment @[0] { };
	  MemberAssign @[1] { };
	 };
	};
	Else @[1] { 
	 ProgEl_List @.true_code = [2] {
	  Comment @[0] { };
	  If @[1] { 
	   ProgEl_List @.true_code = [1] {
	    MemberAssign @[0] { };
	   };
	  };
	 };
	};
       };
      };
      ProgramCall @[9] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      Comment @[10] { };
      MethodCall @[11] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MemberAssign @[12] { };
      MemberAssign @[13] { };
      MemberAssign @[14] { };
      ForLoop @[15] { 
       ProgEl_List @.loop_code = [4] {
	MemberAssign @[0] { };
	MethodCall @[1] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
	ForLoop @[2] { 
	 ProgEl_List @.loop_code = [3] {
	  MemberAssign @[0] { };
	  MethodCall @[1] { 
	   ProgArg_List @.meth_args = [0] {
	   };
	  };
	  ProgramCall @[2] { 
	   ProgArg_List @.prog_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	 };
	};
	MethodCall @[3] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
       };
      };
      ProgramCall @[16] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      ProgramCall @[17] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[18] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[19] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[20] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      NetUpdateView @[21] { };
      StopStepPoint @[22] { };
      Comment @[23] { };
      ProgramCall @[24] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      MemberAssign @[25] { };
      MemberAssign @[26] { };
      MethodCall @[27] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[28] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[29] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      ProgramCall @[30] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[31] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      ProgramCall @[32] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      ProgramCall @[33] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[34] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      ForLoop @[35] { 
       ProgEl_List @.loop_code = [3] {
	MemberAssign @[0] { };
	MethodCall @[1] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
	ProgramCall @[2] { 
	 ProgArg_List @.prog_args = [1] {
	  ProgArg @[0] { };
	 };
	};
       };
      };
      MethodCall @[36] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[37] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MemberAssign @[38] { };
      MethodCall @[39] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[40] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[41] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      NetUpdateView @[42] { };
      Comment @[43] { };
      MemberAssign @[44] { };
      MemberAssign @[45] { };
      MemberAssign @[46] { };
      MethodCall @[47] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
     };
    };
   };
   Program_Group @.gp[1] = [1] { 
    Program @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [1] {
      TimeUsed @[0] { };
     };

     ProgVar_List @.objs_vars = [1] {
      ProgVar @[0] { };
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [3] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
     };

     ProgVar_List @.vars = [10] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
      ProgVar @[6] { };
      ProgVar @[7] { };
      ProgVar @[8] { };
      ProgVar @[9] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [1] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
     };

     ProgEl_List @.prog_code = [40] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      Comment @[1] { };
      ProgramCall @[2] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      ProgramCall @[3] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      ProgramCall @[4] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      DataVarProg @[5] { };
      MemberAssign @[6] { };
      MemberAssign @[7] { };
      MemberAssign @[8] { };
      MemberAssign @[9] { };
      MemberAssign @[10] { };
      MemberAssign @[11] { };
      ProgramCall @[12] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      Comment @[13] { };
      MethodCall @[14] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      ProgramCall @[15] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      ProgramCall @[16] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MemberAssign @[17] { };
      MemberAssign @[18] { };
      MemberAssign @[19] { };
      ForLoop @[20] { 
       ProgEl_List @.loop_code = [4] {
	MemberAssign @[0] { };
	MethodCall @[1] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
	ForLoop @[2] { 
	 ProgEl_List @.loop_code = [3] {
	  MemberAssign @[0] { };
	  MethodCall @[1] { 
	   ProgArg_List @.meth_args = [0] {
	   };
	  };
	  ProgramCall @[2] { 
	   ProgArg_List @.prog_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	 };
	};
	MethodCall @[3] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
       };
      };
      MethodCall @[21] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[22] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      NetUpdateView @[23] { };
      StopStepPoint @[24] { };
      Comment @[25] { };
      ProgramCall @[26] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      ProgramCall @[27] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[28] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      ProgramCall @[29] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      ProgramCall @[30] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MemberAssign @[31] { };
      MethodCall @[32] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[33] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      NetUpdateView @[34] { };
      Comment @[35] { };
      MemberAssign @[36] { };
      MemberAssign @[37] { };
      MemberAssign @[38] { };
      MethodCall @[39] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
     };
    };
   };
  };
  Program_Group @.gp[3] = [5] { 
   Program @[0] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [2] {
     RandomCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };
   };
   Program @[1] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [2] {
     If @[0] { 
      ProgEl_List @.true_code = [2] {
       RandomCall @[0] { 
	ProgArg_List @.meth_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
       MethodCall @[1] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
     Else @[1] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
    };
   };
   Program @[2] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     LayerWriter @[0] { 
      LayerDataEl_List @.layer_data = [4] {
       LayerWriterEl @[0] { };
       LayerWriterEl @[1] { };
       LayerWriterEl @[2] { };
       LayerWriterEl @[3] { };
      };
     };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [0] {
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [3] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [2] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program @[3] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     LayerWriter @[0] { 
      LayerDataEl_List @.layer_data = [4] {
       LayerWriterEl @[0] { };
       LayerWriterEl @[1] { };
       LayerWriterEl @[2] { };
       LayerWriterEl @[3] { };
      };
     };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [0] {
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [3] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [2] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program @[4] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     LayerWriter @[0] { 
      LayerDataEl_List @.layer_data = [3] {
       LayerWriterEl @[0] { };
       LayerWriterEl @[1] { };
       LayerWriterEl @[2] { };
      };
     };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [0] {
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [3] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [2] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program_Group @.gp[0] = [1] { 
    Program @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [8] {
      DataTable @[0] { 
       DataTableCols @.data = [1] {
	String_Data @[0] { };
       };

       DataOpList @.last_sort_spec.ops = [0] {
       };
      };
      DataTable @[1] { 
       DataTableCols @.data = [1] {
	String_Data @[0] { };
       };

       DataOpList @.last_sort_spec.ops = [0] {
       };
      };
      DataTable @[2] { 
       DataTableCols @.data = [1] {
	String_Data @[0] { };
       };

       DataOpList @.last_sort_spec.ops = [0] {
       };
      };
      DataTable @[3] { 
       DataTableCols @.data = [1] {
	String_Data @[0] { };
       };

       DataOpList @.last_sort_spec.ops = [0] {
       };
      };
      DataTable @[4] { 
       DataTableCols @.data = [3] {
	String_Data @[0] { };
	String_Data @[1] { };
	String_Data @[2] { };
       };

       DataOpList @.last_sort_spec.ops = [0] {
       };
      };
      DataTable @[5] { 
       DataTableCols @.data = [3] {
	String_Data @[0] { };
	String_Data @[1] { };
	String_Data @[2] { };
       };

       DataOpList @.last_sort_spec.ops = [0] {
       };
      };
      DataTable @[6] { 
       DataTableCols @.data = [3] {
	String_Data @[0] { };
	String_Data @[1] { };
	String_Data @[2] { };
       };

       DataOpList @.last_sort_spec.ops = [0] {
       };
      };
      DataTable @[7] { 
       DataTableCols @.data = [3] {
	String_Data @[0] { };
	String_Data @[1] { };
	String_Data @[2] { };
       };

       DataOpList @.last_sort_spec.ops = [0] {
       };
      };
     };

     ProgVar_List @.objs_vars = [8] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
      ProgVar @[6] { };
      ProgVar @[7] { };
     };

     ProgType_List @.types = [6] {
      DynEnumType @[0] { 
       DynEnumItem_List @.enums = [3] {
	DynEnumItem @[0] { };
	DynEnumItem @[1] { };
	DynEnumItem @[2] { };
       };
      };
      DynEnumType @[1] { 
       DynEnumItem_List @.enums = [15] {
	DynEnumItem @[0] { };
	DynEnumItem @[1] { };
	DynEnumItem @[2] { };
	DynEnumItem @[3] { };
	DynEnumItem @[4] { };
	DynEnumItem @[5] { };
	DynEnumItem @[6] { };
	DynEnumItem @[7] { };
	DynEnumItem @[8] { };
	DynEnumItem @[9] { };
	DynEnumItem @[10] { };
	DynEnumItem @[11] { };
	DynEnumItem @[12] { };
	DynEnumItem @[13] { };
	DynEnumItem @[14] { };
       };
      };
      DynEnumType @[2] { 
       DynEnumItem_List @.enums = [15] {
	DynEnumItem @[0] { };
	DynEnumItem @[1] { };
	DynEnumItem @[2] { };
	DynEnumItem @[3] { };
	DynEnumItem @[4] { };
	DynEnumItem @[5] { };
	DynEnumItem @[6] { };
	DynEnumItem @[7] { };
	DynEnumItem @[8] { };
	DynEnumItem @[9] { };
	DynEnumItem @[10] { };
	DynEnumItem @[11] { };
	DynEnumItem @[12] { };
	DynEnumItem @[13] { };
	DynEnumItem @[14] { };
       };
      };
      DynEnumType @[3] { 
       DynEnumItem_List @.enums = [15] {
	DynEnumItem @[0] { };
	DynEnumItem @[1] { };
	DynEnumItem @[2] { };
	DynEnumItem @[3] { };
	DynEnumItem @[4] { };
	DynEnumItem @[5] { };
	DynEnumItem @[6] { };
	DynEnumItem @[7] { };
	DynEnumItem @[8] { };
	DynEnumItem @[9] { };
	DynEnumItem @[10] { };
	DynEnumItem @[11] { };
	DynEnumItem @[12] { };
	DynEnumItem @[13] { };
	DynEnumItem @[14] { };
       };
      };
      DynEnumType @[4] { 
       DynEnumItem_List @.enums = [15] {
	DynEnumItem @[0] { };
	DynEnumItem @[1] { };
	DynEnumItem @[2] { };
	DynEnumItem @[3] { };
	DynEnumItem @[4] { };
	DynEnumItem @[5] { };
	DynEnumItem @[6] { };
	DynEnumItem @[7] { };
	DynEnumItem @[8] { };
	DynEnumItem @[9] { };
	DynEnumItem @[10] { };
	DynEnumItem @[11] { };
	DynEnumItem @[12] { };
	DynEnumItem @[13] { };
	DynEnumItem @[14] { };
       };
      };
      DynEnumType @[5] { 
       DynEnumItem_List @.enums = [15] {
	DynEnumItem @[0] { };
	DynEnumItem @[1] { };
	DynEnumItem @[2] { };
	DynEnumItem @[3] { };
	DynEnumItem @[4] { };
	DynEnumItem @[5] { };
	DynEnumItem @[6] { };
	DynEnumItem @[7] { };
	DynEnumItem @[8] { };
	DynEnumItem @[9] { };
	DynEnumItem @[10] { };
	DynEnumItem @[11] { };
	DynEnumItem @[12] { };
	DynEnumItem @[13] { };
	DynEnumItem @[14] { };
       };
      };
     };

     ProgVar_List @.args = [0] {
     };

     ProgVar_List @.vars = [19] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
      ProgVar @[6] { };
      ProgVar @[7] { };
      ProgVar @[8] { };
      ProgVar @[9] { };
      ProgVar @[10] { };
      ProgVar @[11] { };
      ProgVar @[12] { };
      ProgVar @[13] { };
      ProgVar @[14] { };
      ProgVar @[15] { };
      ProgVar @[16] { };
      ProgVar @[17] { };
      ProgVar @[18] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [1] {
      AssignExpr @[0] { };
     };

     ProgEl_List @.prog_code = [11] {
      LocalVars @[0] { 
       ProgVar_List @.local_vars = [1] {
	ProgVar @[0] { };
       };
      };
      Comment @[1] { };
      Comment @[2] { };
      ForLoop @[3] { 
       ProgEl_List @.loop_code = [6] {
	AssignExpr @[0] { };
	AssignExpr @[1] { };
	AssignExpr @[2] { };
	DataVarProg @[3] { };
	DataVarProg @[4] { };
	DataVarProg @[5] { };
       };
      };
      Comment @[4] { };
      DataLoop @[5] { 
       ProgEl_List @.loop_code = [4] {
	DataVarProg @[0] { };
	AssignExpr @[1] { };
	PrintVar @[2] { };
	Switch @[3] { 
	 ProgEl_List @.cases = [3] {
	  CaseBlock @[0] { 
	   ProgEl_List @.prog_code = [10] {
	    Comment @[0] { };
	    Comment @[1] { };
	    MethodCall @[2] { 
	     ProgArg_List @.meth_args = [0] {
	     };
	    };
	    DataProcCall @[3] { 
	     ProgArg_List @.meth_args = [3] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	     };
	    };
	    MethodCall @[4] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	    MethodCall @[5] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	    MethodCall @[6] { 
	     ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	     };
	    };
	    MethodCall @[7] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	    Comment @[8] { };
	    ForLoop @[9] { 
	     ProgEl_List @.loop_code = [2] {
	      Comment @[0] { };
	      MethodCall @[1] { 
	       ProgArg_List @.meth_args = [5] {
		ProgArg @[0] { };
		ProgArg @[1] { };
		ProgArg @[2] { };
		ProgArg @[3] { };
		ProgArg @[4] { };
	       };
	      };
	     };
	    };
	   };
	  };
	  CaseBlock @[1] { 
	   ProgEl_List @.prog_code = [5] {
	    Comment @[0] { };
	    Comment @[1] { };
	    DataProcCall @[2] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	    MethodCall @[3] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	    MethodCall @[4] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	   };
	  };
	  CaseBlock @[2] { 
	   ProgEl_List @.prog_code = [4] {
	    Comment @[0] { };
	    DataProcCall @[1] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	    MethodCall @[2] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	    MethodCall @[3] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	   };
	  };
	 };
	};
       };
      };
      Comment @[6] { };
      MethodCall @[7] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      DataLoop @[8] { 
       ProgEl_List @.loop_code = [11] {
	DataVarProg @[0] { };
	AssignExpr @[1] { };
	AssignExpr @[2] { };
	MethodCall @[3] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
	DataVarProg @[4] { };
	DataVarProgMatrix @[5] { };
	AssignExpr @[6] { };
	AssignExpr @[7] { };
	AssignExpr @[8] { };
	SetUnitsVar @[9] { };
	MethodCall @[10] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
       };
      };
      DataLoop @[9] { 
       ProgEl_List @.loop_code = [11] {
	DataVarProg @[0] { };
	AssignExpr @[1] { };
	AssignExpr @[2] { };
	MethodCall @[3] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
	DataVarProg @[4] { };
	DataVarProgMatrix @[5] { };
	AssignExpr @[6] { };
	AssignExpr @[7] { };
	AssignExpr @[8] { };
	SetUnitsVar @[9] { };
	MethodCall @[10] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
       };
      };
      DataLoop @[10] { 
       ProgEl_List @.loop_code = [11] {
	DataVarProg @[0] { };
	AssignExpr @[1] { };
	AssignExpr @[2] { };
	MethodCall @[3] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
	DataVarProg @[4] { };
	DataVarProgMatrix @[5] { };
	AssignExpr @[6] { };
	AssignExpr @[7] { };
	AssignExpr @[8] { };
	SetUnitsVar @[9] { };
	MethodCall @[10] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
       };
      };
     };
    };
   };
   Program_Group @.gp[1] = [1] { 
    Program @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [8] {
      DataTable @[0] { 
       DataTableCols @.data = [1] {
	String_Data @[0] { };
       };

       DataOpList @.last_sort_spec.ops = [0] {
       };
      };
      DataTable @[1] { 
       DataTableCols @.data = [1] {
	String_Data @[0] { };
       };

       DataOpList @.last_sort_spec.ops = [0] {
       };
      };
      DataTable @[2] { 
       DataTableCols @.data = [1] {
	String_Data @[0] { };
       };

       DataOpList @.last_sort_spec.ops = [0] {
       };
      };
      DataTable @[3] { 
       DataTableCols @.data = [1] {
	String_Data @[0] { };
       };

       DataOpList @.last_sort_spec.ops = [0] {
       };
      };
      DataTable @[4] { 
       DataTableCols @.data = [3] {
	String_Data @[0] { };
	String_Data @[1] { };
	String_Data @[2] { };
       };

       DataOpList @.last_sort_spec.ops = [0] {
       };
      };
      DataTable @[5] { 
       DataTableCols @.data = [3] {
	String_Data @[0] { };
	String_Data @[1] { };
	String_Data @[2] { };
       };

       DataOpList @.last_sort_spec.ops = [0] {
       };
      };
      DataTable @[6] { 
       DataTableCols @.data = [3] {
	String_Data @[0] { };
	String_Data @[1] { };
	String_Data @[2] { };
       };

       DataOpList @.last_sort_spec.ops = [0] {
       };
      };
      DataTable @[7] { 
       DataTableCols @.data = [3] {
	String_Data @[0] { };
	String_Data @[1] { };
	String_Data @[2] { };
       };

       DataOpList @.last_sort_spec.ops = [0] {
       };
      };
     };

     ProgVar_List @.objs_vars = [8] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
      ProgVar @[6] { };
      ProgVar @[7] { };
     };

     ProgType_List @.types = [8] {
      DynEnumType @[0] { 
       DynEnumItem_List @.enums = [3] {
	DynEnumItem @[0] { };
	DynEnumItem @[1] { };
	DynEnumItem @[2] { };
       };
      };
      DynEnumType @[1] { 
       DynEnumItem_List @.enums = [1] {
	DynEnumItem @[0] { };
       };
      };
      DynEnumType @[2] { 
       DynEnumItem_List @.enums = [1] {
	DynEnumItem @[0] { };
       };
      };
      DynEnumType @[3] { 
       DynEnumItem_List @.enums = [9] {
	DynEnumItem @[0] { };
	DynEnumItem @[1] { };
	DynEnumItem @[2] { };
	DynEnumItem @[3] { };
	DynEnumItem @[4] { };
	DynEnumItem @[5] { };
	DynEnumItem @[6] { };
	DynEnumItem @[7] { };
	DynEnumItem @[8] { };
       };
      };
      DynEnumType @[4] { 
       DynEnumItem_List @.enums = [15] {
	DynEnumItem @[0] { };
	DynEnumItem @[1] { };
	DynEnumItem @[2] { };
	DynEnumItem @[3] { };
	DynEnumItem @[4] { };
	DynEnumItem @[5] { };
	DynEnumItem @[6] { };
	DynEnumItem @[7] { };
	DynEnumItem @[8] { };
	DynEnumItem @[9] { };
	DynEnumItem @[10] { };
	DynEnumItem @[11] { };
	DynEnumItem @[12] { };
	DynEnumItem @[13] { };
	DynEnumItem @[14] { };
       };
      };
      DynEnumType @[5] { 
       DynEnumItem_List @.enums = [15] {
	DynEnumItem @[0] { };
	DynEnumItem @[1] { };
	DynEnumItem @[2] { };
	DynEnumItem @[3] { };
	DynEnumItem @[4] { };
	DynEnumItem @[5] { };
	DynEnumItem @[6] { };
	DynEnumItem @[7] { };
	DynEnumItem @[8] { };
	DynEnumItem @[9] { };
	DynEnumItem @[10] { };
	DynEnumItem @[11] { };
	DynEnumItem @[12] { };
	DynEnumItem @[13] { };
	DynEnumItem @[14] { };
       };
      };
      DynEnumType @[6] { 
       DynEnumItem_List @.enums = [15] {
	DynEnumItem @[0] { };
	DynEnumItem @[1] { };
	DynEnumItem @[2] { };
	DynEnumItem @[3] { };
	DynEnumItem @[4] { };
	DynEnumItem @[5] { };
	DynEnumItem @[6] { };
	DynEnumItem @[7] { };
	DynEnumItem @[8] { };
	DynEnumItem @[9] { };
	DynEnumItem @[10] { };
	DynEnumItem @[11] { };
	DynEnumItem @[12] { };
	DynEnumItem @[13] { };
	DynEnumItem @[14] { };
       };
      };
      DynEnumType @[7] { 
       DynEnumItem_List @.enums = [15] {
	DynEnumItem @[0] { };
	DynEnumItem @[1] { };
	DynEnumItem @[2] { };
	DynEnumItem @[3] { };
	DynEnumItem @[4] { };
	DynEnumItem @[5] { };
	DynEnumItem @[6] { };
	DynEnumItem @[7] { };
	DynEnumItem @[8] { };
	DynEnumItem @[9] { };
	DynEnumItem @[10] { };
	DynEnumItem @[11] { };
	DynEnumItem @[12] { };
	DynEnumItem @[13] { };
	DynEnumItem @[14] { };
       };
      };
     };

     ProgVar_List @.args = [0] {
     };

     ProgVar_List @.vars = [20] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
      ProgVar @[6] { };
      ProgVar @[7] { };
      ProgVar @[8] { };
      ProgVar @[9] { };
      ProgVar @[10] { };
      ProgVar @[11] { };
      ProgVar @[12] { };
      ProgVar @[13] { };
      ProgVar @[14] { };
      ProgVar @[15] { };
      ProgVar @[16] { };
      ProgVar @[17] { };
      ProgVar @[18] { };
      ProgVar @[19] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [1] {
      AssignExpr @[0] { };
     };

     ProgEl_List @.prog_code = [11] {
      LocalVars @[0] { 
       ProgVar_List @.local_vars = [1] {
	ProgVar @[0] { };
       };
      };
      Comment @[1] { };
      Comment @[2] { };
      ForLoop @[3] { 
       ProgEl_List @.loop_code = [6] {
	AssignExpr @[0] { };
	AssignExpr @[1] { };
	AssignExpr @[2] { };
	DataVarProg @[3] { };
	DataVarProg @[4] { };
	DataVarProg @[5] { };
       };
      };
      Comment @[4] { };
      DataLoop @[5] { 
       ProgEl_List @.loop_code = [4] {
	DataVarProg @[0] { };
	AssignExpr @[1] { };
	PrintVar @[2] { };
	Switch @[3] { 
	 ProgEl_List @.cases = [3] {
	  CaseBlock @[0] { 
	   ProgEl_List @.prog_code = [10] {
	    Comment @[0] { };
	    Comment @[1] { };
	    MethodCall @[2] { 
	     ProgArg_List @.meth_args = [0] {
	     };
	    };
	    DataProcCall @[3] { 
	     ProgArg_List @.meth_args = [3] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	     };
	    };
	    MethodCall @[4] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	    MethodCall @[5] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	    MethodCall @[6] { 
	     ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	     };
	    };
	    MethodCall @[7] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	    Comment @[8] { };
	    ForLoop @[9] { 
	     ProgEl_List @.loop_code = [2] {
	      Comment @[0] { };
	      MethodCall @[1] { 
	       ProgArg_List @.meth_args = [5] {
		ProgArg @[0] { };
		ProgArg @[1] { };
		ProgArg @[2] { };
		ProgArg @[3] { };
		ProgArg @[4] { };
	       };
	      };
	     };
	    };
	   };
	  };
	  CaseBlock @[1] { 
	   ProgEl_List @.prog_code = [5] {
	    Comment @[0] { };
	    Comment @[1] { };
	    DataProcCall @[2] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	    MethodCall @[3] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	    MethodCall @[4] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	   };
	  };
	  CaseBlock @[2] { 
	   ProgEl_List @.prog_code = [4] {
	    Comment @[0] { };
	    DataProcCall @[1] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	    MethodCall @[2] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	    MethodCall @[3] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	   };
	  };
	 };
	};
       };
      };
      Comment @[6] { };
      MethodCall @[7] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      DataLoop @[8] { 
       ProgEl_List @.loop_code = [11] {
	DataVarProg @[0] { };
	AssignExpr @[1] { };
	AssignExpr @[2] { };
	MethodCall @[3] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
	DataVarProg @[4] { };
	DataVarProgMatrix @[5] { };
	AssignExpr @[6] { };
	AssignExpr @[7] { };
	AssignExpr @[8] { };
	SetUnitsVar @[9] { };
	MethodCall @[10] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
       };
      };
      DataLoop @[9] { 
       ProgEl_List @.loop_code = [11] {
	DataVarProg @[0] { };
	AssignExpr @[1] { };
	AssignExpr @[2] { };
	MethodCall @[3] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
	DataVarProg @[4] { };
	DataVarProgMatrix @[5] { };
	AssignExpr @[6] { };
	AssignExpr @[7] { };
	AssignExpr @[8] { };
	SetUnitsVar @[9] { };
	MethodCall @[10] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
       };
      };
      DataLoop @[10] { 
       ProgEl_List @.loop_code = [11] {
	DataVarProg @[0] { };
	AssignExpr @[1] { };
	AssignExpr @[2] { };
	MethodCall @[3] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
	DataVarProg @[4] { };
	DataVarProgMatrix @[5] { };
	AssignExpr @[6] { };
	AssignExpr @[7] { };
	AssignExpr @[8] { };
	SetUnitsVar @[9] { };
	MethodCall @[10] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
       };
      };
     };
    };
   };
   Program_Group @.gp[2] = [1] { 
    Program @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [0] {
     };

     ProgVar_List @.objs_vars = [0] {
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [0] {
     };

     ProgVar_List @.vars = [0] {
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [0] {
     };

     ProgEl_List @.prog_code = [1] {
      LocalVars @[0] { 
       ProgVar_List @.local_vars = [0] {
       };
      };
     };
    };
   };
   Program_Group @.gp[3] { 
   };
  };
  Program_Group @.gp[4] = [13] { 
   Program @[0] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [12] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
     ProgVar @[6] { };
     ProgVar @[7] { };
     ProgVar @[8] { };
     ProgVar @[9] { };
     ProgVar @[10] { };
     ProgVar @[11] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [6] {
     Comment @[0] { };
     DataVarProg @[1] { };
     DataVarProg @[2] { };
     DataVarProg @[3] { };
     AssignExpr @[4] { };
     If @[5] { 
      ProgEl_List @.true_code = [2] {
       AssignExpr @[0] { };
       If @[1] { 
	ProgEl_List @.true_code = [1] {
	 VarIncr @[0] { };
	};
       };
      };
     };
    };
   };
   Program @[1] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     RndSeed_List @[0] { 
      taList @.seeds = [25] {
       RndSeed @[0] { };
       RndSeed @[1] { };
       RndSeed @[2] { };
       RndSeed @[3] { };
       RndSeed @[4] { };
       RndSeed @[5] { };
       RndSeed @[6] { };
       RndSeed @[7] { };
       RndSeed @[8] { };
       RndSeed @[9] { };
       RndSeed @[10] { };
       RndSeed @[11] { };
       RndSeed @[12] { };
       RndSeed @[13] { };
       RndSeed @[14] { };
       RndSeed @[15] { };
       RndSeed @[16] { };
       RndSeed @[17] { };
       RndSeed @[18] { };
       RndSeed @[19] { };
       RndSeed @[20] { };
       RndSeed @[21] { };
       RndSeed @[22] { };
       RndSeed @[23] { };
       RndSeed @[24] { };
      };
     };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [0] {
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [1] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };
   };
   Program @[2] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     String_Matrix @[0] { };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [8] {
     Comment @[0] { };
     ForLoop @[1] { 
      ProgEl_List @.loop_code = [3] {
       MemberMethodCall @[0] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       MethodCall @[1] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       MethodCall @[2] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     Comment @[2] { };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     ForLoop @[4] { 
      ProgEl_List @.loop_code = [5] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       MemberMethodCall @[1] { 
	ProgArg_List @.meth_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
       If @[2] { 
	ProgEl_List @.true_code = [2] {
	 MiscCall @[0] { 
	  ProgArg_List @.meth_args = [9] {
	   ProgArg @[0] { };
	   ProgArg @[1] { };
	   ProgArg @[2] { };
	   ProgArg @[3] { };
	   ProgArg @[4] { };
	   ProgArg @[5] { };
	   ProgArg @[6] { };
	   ProgArg @[7] { };
	   ProgArg @[8] { };
	  };
	 };
	 IfContinue @[1] { };
	};
       };
       MethodCall @[3] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       MethodCall @[4] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[6] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     PrintExpr @[7] { };
    };
   };
   Program @[3] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     String_Matrix @[0] { };
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    ProgVar_List @.vars = [4] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [3] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     ForLoop @[1] { 
      ProgEl_List @.loop_code = [5] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       MemberMethodCall @[1] { 
	ProgArg_List @.meth_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
       If @[2] { 
	ProgEl_List @.true_code = [2] {
	 MiscCall @[0] { 
	  ProgArg_List @.meth_args = [9] {
	   ProgArg @[0] { };
	   ProgArg @[1] { };
	   ProgArg @[2] { };
	   ProgArg @[3] { };
	   ProgArg @[4] { };
	   ProgArg @[5] { };
	   ProgArg @[6] { };
	   ProgArg @[7] { };
	   ProgArg @[8] { };
	  };
	 };
	 IfContinue @[1] { };
	};
       };
       If @[3] { 
	ProgEl_List @.true_code = [1] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	};
       };
       Else @[4] { 
	ProgEl_List @.true_code = [1] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	};
       };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program @[4] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     RndSeed @[0] { };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [5] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [8] {
     ProgramCall @[0] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     PrintExpr @[3] { };
     If @[4] { 
      ProgEl_List @.true_code = [3] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
       PrintVar @[1] { };
       MemberAssign @[2] { };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [3] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
      };
     };
     If @[6] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     ProgramCall @[7] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
    };
   };
   Program @[5] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [2] {
     If @[0] { 
      ProgEl_List @.true_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
    };
   };
   Program @[6] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [4] {
     MemberAssign @[0] { };
     MemberMethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program @[7] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [5] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     If @[1] { 
      ProgEl_List @.true_code = [2] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       If @[1] { 
	ProgEl_List @.true_code = [2] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	 MethodCall @[1] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	};
       };
      };
     };
     MemberMethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[3] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     If @[4] { 
      ProgEl_List @.true_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
    };
   };
   Program @[8] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [0] {
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [4] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MemberAssign @[3] { };
    };
   };
   Program @[9] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [4] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     If @[1] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     If @[2] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     NetUpdateView @[3] { };
    };
   };
   Program @[10] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [1] {
     ForLoop @[0] { 
      ProgEl_List @.loop_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
    };
   };
   Program @[11] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [3] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[1] { };
     MemberAssign @[2] { };
    };
   };
   Program @[12] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [8] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
     ProgVar @[6] { };
     ProgVar @[7] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [7] {
     If @[0] { 
      ProgEl_List @.true_code = [1] {
       ReturnExpr @[0] { };
      };
     };
     MiscCall @[1] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MiscCall @[2] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     AssignExpr @[3] { };
     MethodCall @[4] { 
      ProgArg_List @.meth_args = [4] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     If @[6] { 
      ProgEl_List @.true_code = [2] {
       AssignExpr @[0] { };
       MemberMethodCall @[1] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
    };
   };
   Program_Group @.gp[0] = [2] { 
    Program @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [1] {
      NetMonitor @[0] { 
       NetMonItem_List @.items = [11] {
	NetMonItem @[0] { };
	NetMonItem @[1] { };
	NetMonItem @[2] { };
	NetMonItem @[3] { };
	NetMonItem @[4] { };
	NetMonItem @[5] { };
	NetMonItem @[6] { };
	NetMonItem @[7] { };
	NetMonItem @[8] { };
	NetMonItem @[9] { };
	NetMonItem @[10] { };
       };
      };
     };

     ProgVar_List @.objs_vars = [1] {
      ProgVar @[0] { };
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [1] {
      ProgVar @[0] { };
     };

     ProgVar_List @.vars = [1] {
      ProgVar @[0] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [3] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
     };

     ProgEl_List @.prog_code = [4] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
    Program @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [1] {
      NetMonitor @[0] { 
       NetMonItem_List @.items = [12] {
	NetMonItem @[0] { };
	NetMonItem @[1] { };
	NetMonItem @[2] { };
	NetMonItem @[3] { };
	NetMonItem @[4] { };
	NetMonItem @[5] { };
	NetMonItem @[6] { };
	NetMonItem @[7] { };
	NetMonItem @[8] { };
	NetMonItem @[9] { };
	NetMonItem @[10] { };
	NetMonItem @[11] { };
       };
      };
     };

     ProgVar_List @.objs_vars = [1] {
      ProgVar @[0] { };
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [1] {
      ProgVar @[0] { };
     };

     ProgVar_List @.vars = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [4] {
      AssignExpr @[0] { };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
     };

     ProgEl_List @.prog_code = [7] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      AssignExpr @[2] { };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      MethodCall @[4] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      MethodCall @[5] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      Comment @[6] { };
     };
    };
   };
  };
 };

 taViewer_List @.viewers = [1] {
  MainWindowViewer @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
    UserDataItem @[1] { };
    UserDataItem @[2] { };
    UserDataItem @[3] { };
    UserDataItem @[4] { };
    UserDataItem @[5] { };
   };

   ToolBar_List @.toolbars = [1] {
    ToolBar @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   FrameViewer_List @.frames = [3] {
    BrowseViewerTaBase @[0] { };
    PanelViewer @[1] { };
    T3PanelViewer @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };

     T3Panel_List @.panels = [3] {
      T3Panel @[0] { 
       T3DataView_List @.root_view.children = [1] {
	NetView @[0] { 
	 T3Annotation_List @.annotations = [0] {
	 };

	 T3DataView_List @.annote_children = [0] {
	 };

	 NetViewStateItem_List @.net_state_text.state_items = [20] {
	  NetViewStateItem @[0] { };
	  NetViewStateItem @[1] { };
	  NetViewStateItem @[2] { };
	  NetViewStateItem @[3] { };
	  NetViewStateItem @[4] { };
	  NetViewStateItem @[5] { };
	  NetViewStateItem @[6] { };
	  NetViewStateItem @[7] { };
	  NetViewStateItem @[8] { };
	  NetViewStateItem @[9] { };
	  NetViewStateItem @[10] { };
	  NetViewStateItem @[11] { };
	  NetViewStateItem @[12] { };
	  NetViewStateItem @[13] { };
	  NetViewStateItem @[14] { };
	  NetViewStateItem @[15] { };
	  NetViewStateItem @[16] { };
	  NetViewStateItem @[17] { };
	  NetViewStateItem @[18] { };
	  NetViewStateItem @[19] { };
	 };

	 ScaleRange_List @.scale_ranges = [21] {
	  ScaleRange @[0] { };
	  ScaleRange @[1] { };
	  ScaleRange @[2] { };
	  ScaleRange @[3] { };
	  ScaleRange @[4] { };
	  ScaleRange @[5] { };
	  ScaleRange @[6] { };
	  ScaleRange @[7] { };
	  ScaleRange @[8] { };
	  ScaleRange @[9] { };
	  ScaleRange @[10] { };
	  ScaleRange @[11] { };
	  ScaleRange @[12] { };
	  ScaleRange @[13] { };
	  ScaleRange @[14] { };
	  ScaleRange @[15] { };
	  ScaleRange @[16] { };
	  ScaleRange @[17] { };
	  ScaleRange @[18] { };
	  ScaleRange @[19] { };
	  ScaleRange @[20] { };
	 };
	};
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @[0] { };
	T3SavedView @[1] { };
	T3SavedView @[2] { };
	T3SavedView @[3] { };
	T3SavedView @[4] { };
	T3SavedView @[5] { };
	T3SavedView @[6] { };
	T3SavedView @[7] { };
	T3SavedView @[8] { };
	T3SavedView @[9] { };
       };
      };
      T3Panel @[1] { 
       T3DataView_List @.root_view.children = [1] {
	GraphTableView @[0] { 
	 T3DataView_List @.children = [11] {
	  GraphColView @[0] { };
	  GraphColView @[1] { };
	  GraphColView @[2] { };
	  GraphColView @[3] { };
	  GraphColView @[4] { };
	  GraphColView @[5] { };
	  GraphColView @[6] { };
	  GraphColView @[7] { };
	  GraphColView @[8] { };
	  GraphColView @[9] { };
	  GraphColView @[10] { };
	 };

	 T3Annotation_List @.annotations = [0] {
	 };

	 T3DataView_List @.annote_children = [0] {
	 };

	 GraphPlotView_List @.plots = [6] {
	  GraphPlotView @[0] { };
	  GraphPlotView @[1] { };
	  GraphPlotView @[2] { };
	  GraphPlotView @[3] { };
	  GraphPlotView @[4] { };
	  GraphPlotView @[5] { };
	 };

	 GraphPlotView_List @.errbars = [6] {
	  GraphPlotView @[0] { };
	  GraphPlotView @[1] { };
	  GraphPlotView @[2] { };
	  GraphPlotView @[3] { };
	  GraphPlotView @[4] { };
	  GraphPlotView @[5] { };
	 };
	};
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @[0] { };
	T3SavedView @[1] { };
	T3SavedView @[2] { };
	T3SavedView @[3] { };
	T3SavedView @[4] { };
	T3SavedView @[5] { };
	T3SavedView @[6] { };
	T3SavedView @[7] { };
	T3SavedView @[8] { };
	T3SavedView @[9] { };
       };
      };
      T3Panel @[2] { 
       T3DataView_List @.root_view.children = [1] {
	GraphTableView @[0] { 
	 T3DataView_List @.children = [26] {
	  GraphColView @[0] { };
	  GraphColView @[1] { };
	  GraphColView @[2] { };
	  GraphColView @[3] { };
	  GraphColView @[4] { };
	  GraphColView @[5] { };
	  GraphColView @[6] { };
	  GraphColView @[7] { };
	  GraphColView @[8] { };
	  GraphColView @[9] { };
	  GraphColView @[10] { };
	  GraphColView @[11] { };
	  GraphColView @[12] { };
	  GraphColView @[13] { };
	  GraphColView @[14] { };
	  GraphColView @[15] { };
	  GraphColView @[16] { };
	  GraphColView @[17] { };
	  GraphColView @[18] { };
	  GraphColView @[19] { };
	  GraphColView @[20] { };
	  GraphColView @[21] { };
	  GraphColView @[22] { };
	  GraphColView @[23] { };
	  GraphColView @[24] { };
	  GraphColView @[25] { };
	 };

	 T3Annotation_List @.annotations = [0] {
	 };

	 T3DataView_List @.annote_children = [0] {
	 };

	 GraphPlotView_List @.plots = [6] {
	  GraphPlotView @[0] { };
	  GraphPlotView @[1] { };
	  GraphPlotView @[2] { };
	  GraphPlotView @[3] { };
	  GraphPlotView @[4] { };
	  GraphPlotView @[5] { };
	 };

	 GraphPlotView_List @.errbars = [6] {
	  GraphPlotView @[0] { };
	  GraphPlotView @[1] { };
	  GraphPlotView @[2] { };
	  GraphPlotView @[3] { };
	  GraphPlotView @[4] { };
	  GraphPlotView @[5] { };
	 };
	};
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @[0] { };
	T3SavedView @[1] { };
	T3SavedView @[2] { };
	T3SavedView @[3] { };
	T3SavedView @[4] { };
	T3SavedView @[5] { };
	T3SavedView @[6] { };
	T3SavedView @[7] { };
	T3SavedView @[8] { };
	T3SavedView @[9] { };
       };
      };
     };
    };
   };

   DockViewer_List @.docks = [1] {
    ToolBoxDockViewer @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
      UserDataItem @[2] { };
      UserDataItem @[3] { };
      UserDataItem @[4] { };
      UserDataItem @[5] { };
     };
    };
   };
  };
 };

 Network_Group @.networks = [1] {
  LeabraNetwork @[0] { 
   BaseSpec_Group @.specs = [32] {
    LeabraUnitSpec @[0] { 
     BaseSpec_Group @.children = [0] {
     };
    };
    LeabraLayerSpec @[1] { 
     BaseSpec_Group @.children = [0] {
     };
    };
    LeabraLayerSpec @[2] { 
     BaseSpec_Group @.children = [0] {
     };
    };
    LeabraLayerSpec @[3] { 
     BaseSpec_Group @.children = [0] {
     };
    };
    LeabraLayerSpec @[4] { 
     BaseSpec_Group @.children = [1] {
      LeabraLayerSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };
      };
     };
    };
    LeabraLayerSpec @[5] { 
     BaseSpec_Group @.children = [1] {
      LeabraLayerSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };
      };
     };
    };
    FullPrjnSpec @[6] { 
     BaseSpec_Group @.children = [0] {
     };
    };
    OneToOnePrjnSpec @[7] { 
     BaseSpec_Group @.children = [0] {
     };
    };
    LeabraConSpec @[8] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[9] { 
     BaseSpec_Group @.children = [0] {
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[10] { 
     BaseSpec_Group @.children = [0] {
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[11] { 
     BaseSpec_Group @.children = [0] {
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[12] { 
     BaseSpec_Group @.children = [0] {
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[13] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[14] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[15] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[16] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[17] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[18] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[19] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[20] { 
     BaseSpec_Group @.children = [0] {
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[21] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[22] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[23] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[24] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[25] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[26] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[27] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[28] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[29] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[30] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    LeabraConSpec @[31] { 
     BaseSpec_Group @.children = [1] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
   };

   ParamSeq_Group @.param_seqs = [0] {
   };

   NetMonItem_List @.monitor.items = [0] {
   };

   DataTableCols @.mon_data.data = [0] {
   };

   DataOpList @.mon_data.last_sort_spec.ops = [0] {
   };

   Layer_Group @.layers = [0] {
    Layer_Group @.gp[0] = [3] { 
     LeabraLayer @[0] { 
      Projection_List @.projections = [0] {
      };
     };
     LeabraLayer @[1] { 
      Projection_List @.projections = [2] {
       LeabraPrjn @[0] { };
       LeabraPrjn @[1] { };
      };
     };
     LeabraLayer @[2] { 
      Projection_List @.projections = [0] {
      };
     };
    };
    Layer_Group @.gp[1] = [3] { 
     LeabraLayer @[0] { 
      Projection_List @.projections = [2] {
       LeabraPrjn @[0] { };
       LeabraPrjn @[1] { };
      };
     };
     LeabraLayer @[1] { 
      Projection_List @.projections = [2] {
       LeabraPrjn @[0] { };
       LeabraPrjn @[1] { };
      };
     };
     LeabraLayer @[2] { 
      Projection_List @.projections = [2] {
       LeabraPrjn @[0] { };
       LeabraPrjn @[1] { };
      };
     };
    };
    Layer_Group @.gp[2] = [4] { 
     LeabraLayer @[0] { 
      Projection_List @.projections = [6] {
       LeabraPrjn @[0] { };
       LeabraPrjn @[1] { };
       LeabraPrjn @[2] { };
       LeabraPrjn @[3] { };
       LeabraPrjn @[4] { };
       LeabraPrjn @[5] { };
      };
     };
     LeabraLayer @[1] { 
      Projection_List @.projections = [5] {
       LeabraPrjn @[0] { };
       LeabraPrjn @[1] { };
       LeabraPrjn @[2] { };
       LeabraPrjn @[3] { };
       LeabraPrjn @[4] { };
      };
     };
     LeabraLayer @[2] { 
      Projection_List @.projections = [6] {
       LeabraPrjn @[0] { };
       LeabraPrjn @[1] { };
       LeabraPrjn @[2] { };
       LeabraPrjn @[3] { };
       LeabraPrjn @[4] { };
       LeabraPrjn @[5] { };
      };
     };
     LeabraLayer @[3] { 
      Projection_List @.projections = [4] {
       LeabraPrjn @[0] { };
       LeabraPrjn @[1] { };
       LeabraPrjn @[2] { };
       LeabraPrjn @[3] { };
      };
     };
    };
    Layer_Group @.gp[3] = [2] { 
     LeabraLayer @[0] { 
      Projection_List @.projections = [9] {
       LeabraPrjn @[0] { };
       LeabraPrjn @[1] { };
       LeabraPrjn @[2] { };
       LeabraPrjn @[3] { };
       LeabraPrjn @[4] { };
       LeabraPrjn @[5] { };
       LeabraPrjn @[6] { };
       LeabraPrjn @[7] { };
       LeabraPrjn @[8] { };
      };
     };
     LeabraLayer @[1] { 
      Projection_List @.projections = [3] {
       LeabraPrjn @[0] { };
       LeabraPrjn @[1] { };
       LeabraPrjn @[2] { };
      };
     };
    };
    Layer_Group @.gp[4] { 
    };
   };

   Weights_List @.weights = [0] {
   };
  };
 };
};
LeabraProject .projects[0] {
 name="Telos1";
 desc="proj to transfer semantic knowledge for use in exec func";
 tags=;
 version {
  major=0;
  minor=1;
  step=15;
 };
 author=;
 email=;
 license {
  license=GPLv2;
  owner_name=;
  org="CCNLab at the University of Colorado Boulder";
  year="2010";
  custom=;
 };
 pub_cite=;
 wiki {wiki="": page_name="": };
 docs {
  name="docs";
  el_typ=taDoc;
  el_def=0;
  taDoc @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="user_pinned": value=1: val_type_fixed=0: };
   };
   name="ProjectDocs";
   desc=;
   web_doc=1;
   wiki="emergent";
   url="LeabraFlexProgs";
   full_url="https://grey.colorado.edu/emergent/index.php/LeabraFlexProgs";
   text_size=1;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
   html_text="<!DOCTYPE html><html lang=\"en\" dir=\"ltr\" class=\"client-js\"><head>
<meta charset=\"UTF-8\">
<title>LeabraFlex - emergent</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\\s)client-nojs(\\s|$)/, \"$1client-js$2\" );</script>
<script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.config.set({\"wgCanonicalNamespace\":\"\",\"wgCanonicalSpecialPageName\":!1,\"wgNamespaceNumber\":0,\"wgPageName\":\"LeabraFlex\",\"wgTitle\":\"LeabraFlex\",\"wgCurRevisionId\":13216,\"wgRevisionId\":13216,\"wgArticleId\":2315,\"wgIsArticle\":!0,\"wgIsRedirect\":!1,\"wgAction\":\"view\",\"wgUserName\":null,\"wgUserGroups\":[\"*\"],\"wgCategories\":[],\"wgBreakFrames\":!1,\"wgPageContentLanguage\":\"en\",\"wgPageContentModel\":\"wikitext\",\"wgSeparatorTransformTable\":[\"\",\"\"],\"wgDigitTransformTable\":[\"\",\"\"],\"wgDefaultDateFormat\":\"dmy\",\"wgMonthNames\":[\"\",\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],\"wgMonthNamesShort\":[\"\",\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],\"wgRelevantPageName\":\"LeabraFlex\",\"wgRelevantArticleId\":2315,\"wgIsProbablyEditable\":!1,\"wgRestrictionEdit\":[],\"wgRestrictionMove\":[],\"wgRedirectedFrom\":\"LeabraFlexProgs\",\"sfgAutocompleteValues\":[],\"sfgAutocompleteOnAllChars\":!1,\"sfgFieldProperties\":[],
\"sfgDependentFields\":[],\"sfgShowOnSelect\":[],\"sfgScriptPath\":\"/emergent/extensions/SemanticForms\",\"wgSVGEditEditor\":\"http://svg-edit.googlecode.com/svn/trunk/editor/svg-editor.html\",\"wgHeaderTabsTabIndexes\":[],\"wgWikiEditorEnabledModules\":{\"toolbar\":!0,\"dialogs\":!0,\"preview\":!0,\"publish\":!1},\"wgCategoryTreePageCategoryOptions\":\"{\\\"mode\\\":0,\\\"hideprefix\\\":20,\\\"showcount\\\":true,\\\"namespaces\\\":false}\",\"wgInternalRedirectTargetUrl\":\"/emergent/index.php/LeabraFlex\"});mw.loader.implement(\"user.options\",function($,jQuery){mw.user.options.set({\"variant\":\"en\"});});mw.loader.implement(\"user.tokens\",function($,jQuery){mw.user.tokens.set({\"editToken\":\"+\\\\\",\"patrolToken\":\"+\\\\\",\"watchToken\":\"+\\\\\"});});mw.loader.load([\"mediawiki.action.view.redirect\",\"ext.smw.style\",\"ext.smw.tooltips\",\"mediawiki.page.startup\",\"mediawiki.legacy.wikibits\",\"skins.vector.js\"]);
} );</script>
<link rel=\"stylesheet\" href=\"/emergent/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector\">
<link rel=\"stylesheet\" href=\"/emergent/extensions/HeaderTabs/skins/ext.headertabs.large.css\">
<meta name=\"ResourceLoaderDynamicStyles\" content=\"\">
<link rel=\"stylesheet\" href=\"/emergent/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector\">
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}</style>
<script async=\"\" src=\"/emergent/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector\"></script>
<meta name=\"generator\" content=\"MediaWiki 1.26.4\">
<link rel=\"ExportRDF\" type=\"application/rdf+xml\" title=\"LeabraFlex\" href=\"/emergent/index.php?title=Special:ExportRDF/LeabraFlex&amp;xmlmime=rdf\">
<link rel=\"shortcut icon\" href=\"/emergent/favicon.ico\">
<link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/emergent/opensearch_desc.php\" title=\"emergent (en)\">
<link rel=\"EditURI\" type=\"application/rsd+xml\" href=\"https://grey.colorado.edu/emergent/api.php?action=rsd\">
<link rel=\"alternate\" type=\"application/atom+xml\" title=\"emergent Atom feed\" href=\"/emergent/index.php?title=Special:RecentChanges&amp;feed=atom\">
<link rel=\"canonical\" href=\"https://grey.colorado.edu/emergent/index.php/LeabraFlex\">
<!--[if lt IE 7]><style type=\"text/css\">body{behavior:url(\"/emergent/skins/Vector/csshover.min.htc\")}</style><![endif]-->
</head>
<body class=\"mediawiki ltr sitedir-ltr ns-0 ns-subject page-LeabraFlex skin-vector action-view\">
		<div id=\"mw-page-base\" class=\"noprint\"></div>
		<div id=\"mw-head-base\" class=\"noprint\"></div>
		<div id=\"content\" class=\"mw-body\" role=\"main\">
			<a id=\"top\"></a>

						<div class=\"mw-indicators\">
</div>
			<h1 id=\"firstHeading\" class=\"firstHeading\" lang=\"en\">LeabraFlex</h1>
									<div id=\"bodyContent\" class=\"mw-body-content\">
									<div id=\"siteSub\">From emergent</div>
								<div id=\"contentSub\"><span class=\"mw-redirectedfrom\">(Redirected from <a href=\"/emergent/index.php?title=LeabraFlexProgs&amp;redirect=no\" title=\"LeabraFlexProgs\">LeabraFlexProgs</a>)</span></div>
												<div id=\"jump-to-nav\" class=\"mw-jump\">
					Jump to:					<a href=\"#mw-head\">navigation</a>, 					<a href=\"#p-search\">search</a>
				</div>
				<div id=\"mw-content-text\" lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\"><p>Documentation for the <code>LeabraFlex</code> <a href=\"/emergent/index.php/Project_template\" title=\"Project template\">Project template</a>, which provides a different way of configuring the <a href=\"/emergent/index.php/Leabra\" title=\"Leabra\">Leabra</a> programs that is more flexible and modular -- very useful for more complex projects that require extensive novel functionality, including interactive behaviors between the network and the programs that generate inputs to the network, things that happen at different points in the settling process, and supporting multiple different ways of running the model in a more efficient, modular fashion.
</p>
<div id=\"toc\" class=\"toc\"><div id=\"toctitle\"><h2>Contents</h2></div>
<ul>
<li class=\"toclevel-1 tocsection-1\"><a href=\"#ParamSet_Configuration_Mechanism\"><span class=\"tocnumber\">1</span> <span class=\"toctext\">ParamSet Configuration Mechanism</span></a>
<ul>
<li class=\"toclevel-2 tocsection-2\"><a href=\"#Converting_Existing_Projects\"><span class=\"tocnumber\">1.1</span> <span class=\"toctext\">Converting Existing Projects</span></a></li>
</ul>
</li>
<li class=\"toclevel-1 tocsection-3\"><a href=\"#Program_Hierarchy\"><span class=\"tocnumber\">2</span> <span class=\"toctext\">Program Hierarchy</span></a></li>
<li class=\"toclevel-1 tocsection-4\"><a href=\"#UtilProgs\"><span class=\"tocnumber\">3</span> <span class=\"toctext\">UtilProgs</span></a></li>
<li class=\"toclevel-1 tocsection-5\"><a href=\"#DMem_.28MPI.29\"><span class=\"tocnumber\">4</span> <span class=\"toctext\">DMem (MPI)</span></a></li>
</ul>
</div>

<h1><span class=\"mw-headline\" id=\"ParamSet_Configuration_Mechanism\">ParamSet Configuration Mechanism</span></h1>
<p>In version 8.0.6 and above, the previous ConfigTable mechanism has been replaced with a new <a href=\"/emergent/index.php/ParamSet\" title=\"ParamSet\">ParamSet</a> mechanism that is simpler and more easily configured and extensible.
</p><p>The master ControlPanel and ClusterRun now point to the <b>run_params</b> and <b>misc_params</b> variables on the <b>MasterTrain</b> program.  When MasterTrain runs (interactively in the gui), it Activates the currently-selected ParamSet configuration -- this copies the saved_value settings into the live, \"active\" current values of each item in the param set.  These items include variables in other key <a href=\"/emergent/index.php/Program\" title=\"Program\">Programs</a>, and parameters in the network that you want to control.  <i>It is easy to add any number of different sets of such parameters</i> -- you can either add new parameters to the existing Params groups, or you can make new groups for sets of parameters that vary mostly independently of the existing ones.
</p><p>The param sets live in the <b>param_sets</b> group in the <a href=\"/emergent/index.php/Project\" title=\"Project\">Project</a>, in sub-groups called <b>RunParams</b> and <b>MiscParams</b>.  Within each of these groups, the first ParamSet object serves as the <b>Master</b> ParamSet, while all the remaining ones are <b>Clones.</b>  Whenever you add, remove, or modify an item within the Master, those changes are automatically copied to all the Clones.  This makes it easy to maintain a consistent set of parameters across all the configurations.  To make this more visually apparent, the Clones are shown with a grey background.  Nevertheless, the Master and Clone ParamSet objects all function in the identical way, and each has its own independent set of <b>saved_value</b> settings.  It is these saved values that distinguish each configuration.  When you Activate a ParamSet, you are copying the saved_value into the current \"live\" active value of that given item (whether it is a variable in a Program, or a value in a <a href=\"/emergent/index.php/Spec\" title=\"Spec\" class=\"mw-redirect\">Spec</a>, or any other value on any object anywhere in the software!).
</p><p>We have removed the StdGlobalsInit program, which used to serve as the way to load all the values from the ConfigTable into live, active variables that you can then use in Programs.  Instead, these variables just live in the programs that use them directly, and the ParamSet's just point into those variables.  The <b>TrainStart</b> and <b>TrainEnd</b> programs have many of the RunParams variables. To see where a variable is, just do the <a href=\"/emergent/index.php/context_menu\" title=\"context menu\" class=\"mw-redirect\">context menu</a> on a given item label in the ParamSet, and select <b>Go To Object</b> and you'll be taken right there.  This is a major advantage over the previous DataTable mechanism, which didn't have this direct connection to the variables it controlled.
</p>
<h2><span class=\"mw-headline\" id=\"Converting_Existing_Projects\">Converting Existing Projects</span></h2>
<p>Use the <a href=\"/emergent/index.php/LeabraFlex_v804_to_v810\" title=\"LeabraFlex v804 to v810\">LeabraFlex_v804_to_v810</a> <a href=\"/emergent/index.php/Patch\" title=\"Patch\">Patch</a> to automatically upgrade an older project to this new configuration -- see <a href=\"/emergent/index.php/PublishedPatchList\" title=\"PublishedPatchList\">PublishedPatchList</a> for list of all such patches.
</p><p>If you want to do it manually, here are the main steps to convert an existing LeabraFlex project over to the new ParamSet mechanism:
</p>
<ul><li> Drag the MasterTrain, MasterRun, MasterStartup, TrainStart (TODO: others???) programs from a new LeabraFlex project on top of your existing versions of these programs (in that order -- select Assign To from the drop menu -- it is a good idea to first do Compare To and make sure that you didn't have any custom code in any of these programs that you'll want to keep -- this is relatively rare however).</li></ul>
<ul><li> Do a Find on programs (all programs) and look for config_id -- this variable was passed around in the prior versions, but is absent in the new versions -- please remove it from all existing programs that have it).</li></ul>
<ul><li> Drag over the RunParams NetConfig and LearnParams groups into param_sets from the new LeabraFlex -- these should be able to find the variables in your project once you've updated the above programs.  The default LearnParams just has one token item -- you'll probably want to adapt that to your actual project, and may have params in your ClusterRun or ControlPanel that you'll like to add. If these params are variables in StdGlobalsInit (likely) move them to TrainStart or another program and then add each one to the RunMaster or other param_set by selecting the variable and on the context menu choosing \"Add Var to Control Panel\".</li></ul>
<ul><li> Make sure you've got everything you want from your existing ConfigTable into In the RunParams and / or MiscParams  Master's, and then go to the small menu in edit panel for RunParams group (and MiscParams if relevant) in middle Editor Panel, select Control Panel/CopyFromDataTable menu item, and select the ConfigTable -- this will copy over each of the rows of the config table as a new ParamSet in that group, with saved_value's copied from the column with the same name as the variable in the ParamSet.  Hence, make sure your param set variables are named the same as your ConfigTable column names.  You can change the names later in your ParamSet if you want.. the Master will auto-copy to all the clones!</li></ul>
<ul><li> You can copy over the ClusterRun and ControlPanel (drop on existing and Assign To) once you've moved all the variables to the MiscParams configs.  These ones have the pointers to the MasterTrain variables.</li></ul>
<ul><li> Then you can remove the ConfigTable and the StdGlobalsInit.  Try to run your project from the ControlPanel.  Fix any errors!</li></ul>
<ul><li> It is really easy to create a new ParamSet_Group within the objs of a Program (there is a new button to do it) -- you can then select a set of variables from the program to add to the master param set in the group, and then add a call at the top of your prog_code to ActivateParamSet() in the ParamSet_Group object, with the name from a String variable that contains the name of the ParamSet to use -- and with that, you've got a program that can be run with different named configurations of its variables, making it easier for other programs to configure things.  You can then add this String variable to your MiscParams or other top-level param sets.  When you have a lot of complex functionality embedded within a single Program (e.g., a program that generates a complex environment), this really makes it a lot easier to configure and control, while still ensuring that each program is fully self-contained!</li></ul>
<ul><li> Please update these instructions with any other helpful tips or missing steps!</li></ul>
<h1><span class=\"mw-headline\" id=\"Program_Hierarchy\">Program Hierarchy</span></h1>
<p>The call sequence is:
</p>
<ul><li> <b>MasterTrain</b></li></ul>
<dl><dd><ul><li> <b>InitProgs[init_prog]</b> (as spec'd in ConfigTable)</li>
<li> loop over <b>MasterRun</b> until stop_train is set to true</li></ul>
<dl><dd><ul><li> <b>RunProgs[run_prog]</b> (as spec'd in ConfigTable)</li></ul>
<dl><dd><ul><li> typically calls one or more <b>TaskProgs</b>, increments counters and does appropriate Epoch and higher-level housekeeping as necessary.</li></ul></dd></dl></dd></dl></dd></dl>
<p>MasterRun now has a <b>stop_step_grain</b> parameter that allows you to Step this program at different grain sizes (e.g., after an Epoch) and for different conditions -- this is completely extensible if you look at the underlying code, and very powerful.
</p>
<h1><span class=\"mw-headline\" id=\"UtilProgs\">UtilProgs</span></h1>
<p>The UtilProgs contain all the basic functionality for training a network and monitoring, etc -- the task programs should consist of calls to these util programs in the desired order to achieve whatever form of processing is required.  The built-in BasicTrain program just does the equivalent of a standard LeabraTrial.
</p>
<h1><span class=\"mw-headline\" id=\"DMem_.28MPI.29\">DMem (MPI)</span></h1>
<p>The most efficient way to use multiple distributed memory (dmem) processors (via MPI) is to split different events across processors.  The standard Leabra programs do this by interleaving trials according to dmem processor (e.g., for 10 processors, proc 0 gets trials 0, 10, 20, ..; proc 1 gets 1, 11, 21, etc..).  For these flex progs, which can have interactive behavior and ill-defined sequences of events, this strategy is not always possible (the <b>ChoosePermutedEvent</b> program in EnviroProgs does implement this behavior however).  Here are some tips:
</p>
<ul><li> After version 8.0, you can add taMisc::dmem_proc to all calls to <a href=\"/emergent/index.php/Random\" title=\"Random\">Random</a> or various Permute etc functions that use random numbers and take a <b>thr_no</b> (thread number) argument -- as documented in <a href=\"/emergent/index.php/MTRnd\" title=\"MTRnd\">MTRnd</a>, this thr_no arg selects different random number sequences that are initialized from a single common seed, and will produce statistically independent sequences.  Thus, you can ensure that each node gets different random inputs and other parameters, as appropriate, without needing to have an entirely different seed for each node.  This also means that results can be fully replicable when starting from the same random seed, and that nodes can also generate the same random numbers as needed (if this is needed, it is a good idea to pass taMisc::dmem_proc + 1 to the Random calls, and reserve 0 for the common shared thread that should only be called identically from all processors -- otherwise it will diverge from the 0'th node relative to the others.</li></ul>
<ul><li> After common weight initialization etc, the <b>TrainStart</b> program has the option to generate a new random seed just before starting the Epoch -- see the <b>dmem_new_seed</b> flag -- each processor at this point will be operating with their own random seed, so any dynamic event generation code that uses random numbers (hint: it should!) will result in different things on different nodes.  However, as a result of this, <b>every run of the simulation will be different</b>, even if using common initial starting seeds.   See first note to alternative that avoids these consequences.</li></ul>
<ul><li> It is <b>essential</b> that the different nodes still end up calling <b>Compute_Weights</b> the same number of times, after roughly the same amount of overall computation -- this is where the weight changes are synchronized across processors -- the simulation will lock up and hang if these do not align.</li></ul>
<ul><li> The <b>epoch_trials</b> value gets divided by dmem_nprocs in StdGlobalsInit, such that each processor runs this reduced number of trials, <i>with the network-&gt;trial counter going from 0 to this lower epoch_trials value</i> -- it does not do the interleaving that is done in the hierarchical programs.  This also means that trial numbers will be duplicated if you merge separate trial log data tables into a single table, which is not necessarily a problem, but you may need to do things a bit differently in analyzing the data.</li></ul>
<ul><li> If you are using a traditional list of events in an input_data table, use ChoosePermutedEvent and it will work properly with dmem, just like the standard programs.  This program maintains its own internal counter, and simply iterates in a permuted order through the events and then repeats -- it does not need to be synchronized with the trial and epoch structure of the programs (to achieve this, simply ensure that the epoch_trials is the same as the number of rows in the input data table).</li></ul>

<!-- 
NewPP limit report
Cached time: 20200206042349
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.032 seconds
Real time usage: 0.035 seconds
Preprocessor visited node count: 19/1000000
Preprocessor generated node count: 24/1000000
Post?expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 - -total
-->

<!-- Saved in parser cache with key pdpwiki:pcache:idhash:2315-0!*!0!!en!*!* and timestamp 20200206042349 and revision id 13216
 -->
</div>					<div class=\"printfooter\">
						Retrieved from \"<a dir=\"ltr\" href=\"https://grey.colorado.edu/emergent/index.php?title=LeabraFlex&amp;oldid=13216\">https://grey.colorado.edu/emergent/index.php?title=LeabraFlex&amp;oldid=13216</a>\"					</div>
				<div id=\"catlinks\" class=\"catlinks catlinks-allhidden\"></div>				<div class=\"visualClear\"></div>
							</div>
		</div>
		<div id=\"mw-navigation\">
			<h2>Navigation menu</h2>

			<div id=\"mw-head\">
									<div id=\"p-personal\" role=\"navigation\" class=\"\" aria-labelledby=\"p-personal-label\">
						<h3 id=\"p-personal-label\">Personal tools</h3>
						<ul>
							<li id=\"pt-login\"><a href=\"/emergent/index.php?title=Special:UserLogin&amp;returnto=LeabraFlex\" title=\"You are encouraged to log in; however, it is not mandatory [o]\" accesskey=\"o\">Log in</a></li>						</ul>
					</div>
									<div id=\"left-navigation\">
										<div id=\"p-namespaces\" role=\"navigation\" class=\"vectorTabs\" aria-labelledby=\"p-namespaces-label\">
						<h3 id=\"p-namespaces-label\">Namespaces</h3>
						<ul>
															<li id=\"ca-nstab-main\" class=\"selected\"><span><a href=\"/emergent/index.php/LeabraFlex\" title=\"View the content page [c]\" accesskey=\"c\">Page</a></span></li>
															<li id=\"ca-talk\" class=\"new\"><span><a href=\"/emergent/index.php?title=Talk:LeabraFlex&amp;action=edit&amp;redlink=1\" title=\"Discussion about the content page [t]\" accesskey=\"t\" rel=\"discussion\">Discussion</a></span></li>
													</ul>
					</div>
										<div id=\"p-variants\" role=\"navigation\" class=\"vectorMenu emptyPortlet\" aria-labelledby=\"p-variants-label\">
												<h3 id=\"p-variants-label\">
							<span>Variants</span><a href=\"#\"></a>
						</h3>

						<div class=\"menu\">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id=\"right-navigation\">
										<div id=\"p-views\" role=\"navigation\" class=\"vectorTabs\" aria-labelledby=\"p-views-label\">
						<h3 id=\"p-views-label\">Views</h3>
						<ul>
															<li id=\"ca-view\" class=\"selected\"><span><a href=\"/emergent/index.php/LeabraFlex\">Read</a></span></li>
															<li id=\"ca-viewsource\"><span><a href=\"/emergent/index.php?title=LeabraFlex&amp;action=edit\" title=\"This page is protected.
You can view its source [e]\" accesskey=\"e\">View source</a></span></li>
															<li id=\"ca-history\" class=\"collapsible\"><span><a href=\"/emergent/index.php?title=LeabraFlex&amp;action=history\" title=\"Past revisions of this page [h]\" accesskey=\"h\">View history</a></span></li>
													</ul>
					</div>
										<div id=\"p-cactions\" role=\"navigation\" class=\"vectorMenu emptyPortlet\" aria-labelledby=\"p-cactions-label\">
						<h3 id=\"p-cactions-label\"><span>More</span><a href=\"#\"></a></h3>

						<div class=\"menu\">
							<ul>
															</ul>
						</div>
					</div>
										<div id=\"p-search\" role=\"search\">
						<h3>
							<label for=\"searchInput\">Search</label>
						</h3>

						<form action=\"/emergent/index.php\" id=\"searchform\">
							<div id=\"simpleSearch\">
							<input type=\"search\" name=\"search\" placeholder=\"Search\" title=\"Search emergent [f]\" accesskey=\"f\" id=\"searchInput\"><input type=\"hidden\" value=\"Special:Search\" name=\"title\"><input type=\"submit\" name=\"fulltext\" value=\"Search\" title=\"Search the pages for this text\" id=\"mw-searchButton\" class=\"searchButton mw-fallbackSearchButton\"><input type=\"submit\" name=\"go\" value=\"Go\" title=\"Go to a page with this exact name if it exists\" id=\"searchButton\" class=\"searchButton\">							</div>
						</form>
					</div>
									</div>
			</div>
			<div id=\"mw-panel\">
				<div id=\"p-logo\" role=\"banner\"><a class=\"mw-wiki-logo\" href=\"/emergent/index.php/Main_Page\" title=\"Visit the main page\"></a></div>
						<div class=\"portal\" role=\"navigation\" id=\"p-navigation\" aria-labelledby=\"p-navigation-label\">
			<h3 id=\"p-navigation-label\">Navigation</h3>

			<div class=\"body\">
									<ul>
						<li id=\"n-mainpage-description\"><a href=\"/emergent/index.php/Main_Page\" title=\"Visit the main page [z]\" accesskey=\"z\">Main page</a></li><li id=\"n-recentchanges\"><a href=\"/emergent/index.php/Special:RecentChanges\" title=\"A list of recent changes in the wiki [r]\" accesskey=\"r\">Recent changes</a></li><li id=\"n-Documentation\"><a href=\"/emergent/index.php/User_hub\">Documentation</a></li><li id=\"n-Submit-a-bug\"><a href=\"/emergent/index.php/How_to_submit_a_bug_report\">Submit a bug</a></li><li id=\"n-Bug-tracker\"><a href=\"//grey.colorado.edu/cgi-bin/bugzilla/index.cgi\" rel=\"nofollow\">Bug tracker</a></li><li id=\"n-Mailing-list\"><a href=\"//grey.colorado.edu/cgi-bin/mailman/listinfo/emergent-users\" rel=\"nofollow\">Mailing list</a></li>					</ul>
							</div>
		</div>
			<div class=\"portal\" role=\"navigation\" id=\"p-tb\" aria-labelledby=\"p-tb-label\">
			<h3 id=\"p-tb-label\">Tools</h3>

			<div class=\"body\">
									<ul>
						<li id=\"t-whatlinkshere\"><a href=\"/emergent/index.php/Special:WhatLinksHere/LeabraFlex\" title=\"A list of all wiki pages that link here [j]\" accesskey=\"j\">What links here</a></li><li id=\"t-recentchangeslinked\"><a href=\"/emergent/index.php/Special:RecentChangesLinked/LeabraFlex\" title=\"Recent changes in pages linked from this page [k]\" accesskey=\"k\">Related changes</a></li><li id=\"t-specialpages\"><a href=\"/emergent/index.php/Special:SpecialPages\" title=\"A list of all special pages [q]\" accesskey=\"q\">Special pages</a></li><li id=\"t-permalink\"><a href=\"/emergent/index.php?title=LeabraFlex&amp;oldid=13216\" title=\"Permanent link to this revision of the page\">Permanent link</a></li><li id=\"t-info\"><a href=\"/emergent/index.php?title=LeabraFlex&amp;action=info\" title=\"More information about this page\">Page information</a></li><li id=\"t-smwbrowselink\"><a href=\"/emergent/index.php/Special:Browse/LeabraFlex\" rel=\"smw-browse\">Browse properties</a></li>					</ul>
							</div>
		</div>
			<div class=\"portal\" role=\"navigation\" id=\"p-coll-print_export\" aria-labelledby=\"p-coll-print_export-label\">
			<h3 id=\"p-coll-print_export-label\">Print/export</h3>

			<div class=\"body\">
									<ul>
						<li id=\"coll-create_a_book\"><a href=\"/emergent/index.php?title=Special:Book&amp;bookcmd=book_creator&amp;referer=LeabraFlex\">Create a book</a></li><li id=\"coll-download-as-rl\"><a href=\"/emergent/index.php?title=Special:Book&amp;bookcmd=render_article&amp;arttitle=LeabraFlex&amp;oldid=13216&amp;writer=rl\">Download as PDF</a></li><li id=\"t-print\"><a href=\"/emergent/index.php?title=LeabraFlex&amp;printable=yes\" title=\"Printable version of this page [p]\" accesskey=\"p\">Printable version</a></li>					</ul>
							</div>
		</div>
				</div>
		</div>
		<div id=\"footer\" role=\"contentinfo\">
							<ul id=\"footer-info\">
											<li id=\"footer-info-lastmod\"> This page was last modified on 18 November 2017, at 19:46.</li>
									</ul>
							<ul id=\"footer-places\">
											<li id=\"footer-places-about\"><a href=\"/emergent/index.php/emergent:About\" title=\"emergent:About\">About emergent</a></li>
									</ul>
										<ul id=\"footer-icons\" class=\"noprint\">
											<li id=\"footer-poweredbyico\">
							<a href=\"//www.mediawiki.org/\"><img src=\"/emergent/resources/assets/poweredby_mediawiki_88x31.png\" alt=\"Powered by MediaWiki\" srcset=\"/emergent/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /emergent/resources/assets/poweredby_mediawiki_176x62.png 2x\" width=\"88\" height=\"31\"></a><a href=\"https://www.semantic-mediawiki.org/wiki/Semantic_MediaWiki\"><img src=\"/emergent/extensions/SemanticMediaWiki/resources/images/smw_button.png\" alt=\"Powered by Semantic MediaWiki\" width=\"88\" height=\"31\"></a>						</li>
									</ul>
						<div style=\"clear:both\"></div>
		</div>
		<script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.loader.state({\"user\":\"ready\",\"user.groups\":\"ready\"});mw.loader.load([\"mediawiki.toc\",\"mediawiki.action.view.postEdit\",\"site\",\"mediawiki.user\",\"mediawiki.hidpi\",\"mediawiki.page.ready\",\"mediawiki.searchSuggest\",\"ext.headertabs\"]);
} );</script><script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.config.set({\"wgBackendResponseTime\":227});
} );</script>
	

</body></html>";
  };
 };
 wizards {
  name="wizards";
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="NO_CLIP": value=1: val_type_fixed=0: };
   };
   name="LeabraWizard_1";
  };
 };
 ctrl_panels {
  name="ctrl_panels";
  el_typ=ControlPanel;
  el_def=0;
  master_and_clones=0;
  ControlPanel @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="user_pinned": value=1: val_type_fixed=0: };
   };
   name="ControlPanel";
   cp_state=REGULAR;
   updt_while_running=0;
   desc="main control panel for the system";
   mbrs {
    name="mbrs";
    el_typ=ControlPanelMember;
    el_def=0;
    ControlPanelMember @[0] {
     label="config_id";
     short_label=1;
     cust_label=0;
     desc="config_id to use for running project";
     cust_desc=1;
     base=.programs.gp[1][1].vars[2]$$;
     mbr=ProgVar::string_val;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value="": range="": notes="": };
    };
    ControlPanelMember @[1] {
     label="Cycle_update_net_view";
     short_label=0;
     cust_label=1;
     desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
     cust_desc=1;
     base=.programs.gp[4][11].vars[0]$$;
     mbr=ProgVar::bool_val;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value="": range="": notes="": };
    };
   };
   mths {
    name="mths";
    el_typ=ControlPanelMethod;
    el_def=0;
    group_type=GT_BUTTONS;
    ControlPanelMethod @[0] {
     label="Init";
     short_label=0;
     cust_label=0;
     desc=" run init_code, global variables retain current values unless reset in the init_code";
     cust_desc=0;
     base=.programs.gp[1][1]$$;
     mth=Program::Init;
    };
    ControlPanelMethod @[1] {
     label="Run";
     short_label=0;
     cust_label=0;
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.programs.gp[1][1]$;
     mth=Program::Run_Gui;
    };
    ControlPanelMethod @[2] {
     label="Step";
     short_label=0;
     cust_label=0;
     desc=" step the program at the level of the given program -- if NULL then step_prog default value will be used";
     cust_desc=0;
     base=$.programs.gp[1][1]$;
     mth=Program::Step_Gui;
    };
    ControlPanelMethod @[3] {
     label="Stop";
     short_label=0;
     cust_label=0;
     desc=" stop the current program at its next natural stopping point (i.e., cleanly stopping when appropriate chunks of computation have completed)";
     cust_desc=0;
     base=$.programs.gp[1][1]$;
     mth=Program::Stop;
    };
   };
  };
  ClusterRun @[1] {
   name="ClusterRun";
   cp_state=REGULAR;
   updt_while_running=0;
   desc=;
   mbrs {
    name="mbrs";
    el_typ=ControlPanelMember;
    el_def=0;
   };
   mths {
    name="mths";
    el_typ=ControlPanelMethod;
    el_def=0;
    group_type=GT_BUTTONS;
   };
   search_algos {
    name="search_algos";
    el_typ=ParamSearchAlgo;
    el_def=0;
   };
   use_search_algo=0;
   cur_search_algo=NULL;
   set_proj_name=0;
   proj_name=;
   auto_updt_interval=10;
   auto_updt_timeout=30;
   cluster=;
   clusters=;
   users=;
   last_submit_time=;
   notes=;
   label=;
   extra_files=;
   svn_repo=;
   repo_url=;
   queue=;
   run_time=;
   exe_cmd="emergent";
   ram_gb=0;
   n_threads=1;
   use_cuda=0;
   use_mpi=0;
   mpi_nodes=10;
   mpi_per_node=1;
   parallel_batch=0;
   pb_batches=10;
   pb_n_batches_per=1;
   nowin_x=0;
   enable_kill=0;
   enable_load=0;
   enable_notes=1;
  };
 };
 active_params {
  name="active_params";
  el_typ=ParamSet;
  el_def=0;
  master_and_clones=0;
 };
 archived_params {
  name="archived_params";
  el_typ=ParamSet;
  el_def=0;
  master_and_clones=0;
 };
 data {
  name="data";
  el_typ=DataTable;
  el_def=0;
  save_tables=1;
  DataTable_Group @.gp[0] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
   DataTable @[0] {
    name="StdInputData";
    desc="basic input data table";
    data {
     name="data";
     el_typ=float_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [6] "checks";"mitvert";"midhoriz";"rdiag";"ldiag";"random";      };
     };
     float_Data @[1] {
      name="Output";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 5;5;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=6;
      matrix_col_width=10;
      ar {
       name="ar";
      [5 5 6] 1;0;0;0;1;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
1;0;0;0;1;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;1;0;0;1;0;0;1;
1;0;0;0;0;0;0;0;0;0;
      };
     };
     float_Data @[2] {
      name="Input";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 5;5;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=5;
      matrix_col_width=10;
      ar {
       name="ar";
      [5 5 6] 1;0;0;0;1;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
1;0;0;0;1;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;1;0;0;1;0;0;0;
1;0;0;0;1;0;0;0;0;0;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [6] 0;1;2;3;4;5;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   DataTable @[1] {
    name="InputData_TrnActionRelation";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="TrialName";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [36] "S0+A0_1->S1";"S0+A0_2->S2";"S0+A0_3->S3";"S1+A1_4->S4";"S1+A1_5->S5";"S1+A1_6->S6";"S2+A2_7->S7";"S2+A2_8->S8";"S2+A2_9->S9";"S3+A3_10->S10";
"S3+A3_11->S11";"S3+A3_12->S12";"A0_1+S1->S0";"A0_2+S2->S0";"A0_3+S3->S0";"A1_4+S4->S1";"A1_5+S5->S1";"A1_6+S6->S1";"A2_7+S7->S2";"A2_8+S8->S2";
"A2_9+S9->S2";"A3_10+S10->S3";"A3_11+S11->S3";"A3_12+S12->S3";"S0+S1->A0_1";"S0+S2->A0_2";"S0+S3->A0_3";"S1+S4->A1_4";"S1+S5->A1_5";"S1+S6->A1_6";
"S2+S7->A2_7";"S2+S8->A2_8";"S2+S9->A2_9";"S3+S10->A3_10";"S3+S11->A3_11";"S3+S12->A3_12";      };
     };
     String_Data @[1] {
      name="TrialTypeInputs";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [36] "Before+Action";"Before+Action";"Before+Action";"Before+Action";"Before+Action";"Before+Action";"Before+Action";"Before+Action";"Before+Action";"Before+Action";
"Before+Action";"Before+Action";"Action+After";"Action+After";"Action+After";"Action+After";"Action+After";"Action+After";"Action+After";"Action+After";
"Action+After";"Action+After";"Action+After";"Action+After";"Before+After";"Before+After";"Before+After";"Before+After";"Before+After";"Before+After";
"Before+After";"Before+After";"Before+After";"Before+After";"Before+After";"Before+After";      };
     };
     float_Data @[2] {
      name="WordBefore_InOut";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 13;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [13 1 36] 1;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;      };
     };
     float_Data @[3] {
      name="WordAction_InOut";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 12;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [12 1 36] 1;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;      };
     };
     float_Data @[4] {
      name="WordAfter_InOut";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 13;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=15;
      matrix_col_width=10;
      ar {
       name="ar";
      [13 1 36] 0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;      };
     };
     float_Data @[5] {
      name="Goal_Input";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 13;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=13;
      matrix_col_width=10;
      ar {
       name="ar";
      [13 1 36] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;      };
     };
     float_Data @[6] {
      name="RewTargNOT_NEEDED";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 1;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=17;
      matrix_col_width=10;
      ar {
       name="ar";
      [1 1 36] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [36] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;15;16;17;18;19;
20;21;22;23;24;25;26;27;28;29;
30;31;32;33;34;35;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   DataTable @[2] {
    name="InputData_TestGoalDirectedTrials";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="TrialName";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [9] "S0+S4->A0_1";"S0+S5->A0_1";"S0+S6->A0_1";"S0+S7->A0_2";"S0+S8->A0_2";"S0+S9->A0_2";"S0+S10->A0_3";"S0+S11->A0_3";"S0+S12->A0_3";      };
     };
     String_Data @[1] {
      name="TrialTypeInputGoal";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=18;
      matrix_col_width=10;
      ar {
       name="ar";
      [9] "Current+Goal";"Current+Goal";"Current+Goal";"Current+Goal";"Current+Goal";"Current+Goal";"Current+Goal";"Current+Goal";"Current+Goal";      };
     };
     float_Data @[2] {
      name="ActualState_Input";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 13;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=17;
      matrix_col_width=10;
      ar {
       name="ar";
      [13 1 9] 1;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;      };
     };
     float_Data @[3] {
      name="Goal_Input";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 13;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=13;
      matrix_col_width=10;
      ar {
       name="ar";
      [13 1 9] 0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;      };
     };
     float_Data @[4] {
      name="WordAction_InOut";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 12;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [12 1 9] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;      };
     };
     float_Data @[5] {
      name="ActualAction_Output";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 12;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=19;
      matrix_col_width=10;
      ar {
       name="ar";
      [12 1 9] 1;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [9] 0;1;2;3;4;5;6;7;8;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
  };
  DataTable_Group @.gp[1] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
   DataTable @[0] {
    name="TrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_17";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="batch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_18";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="epoch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     String_Data @[2] {
      name="train_mode";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
     };
     int_Data @[3] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_19";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="trial";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     int_Data @[4] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_20";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="tick";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     String_Data @[5] {
      name="trial_name";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
     };
     String_Data @[6] {
      name="group_name";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
     };
     float_Data @[7] {
      name="rt_cycles";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=9;
      matrix_col_width=10;
     };
     float_Data @[8] {
      name="sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[9] {
      name="norm_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[10] {
      name="ext_rew";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   DataTable @[1] {
    name="EpochOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_19";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="batch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_20";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="epoch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     String_Data @[2] {
      name="train_mode";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
     };
     float_Data @[3] {
      name="avg_sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[4] {
      name="cnt_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[5] {
      name="avg_norm_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=12;
      matrix_col_width=10;
     };
     float_Data @[6] {
      name="avg_ext_rew";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=11;
      matrix_col_width=10;
     };
     float_Data @[7] {
      name="avg_cycles";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=10;
      matrix_col_width=10;
     };
     float_Data @[8] {
      name="epoch_time_tot";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
     };
     float_Data @[9] {
      name="epoch_time_usr";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
     };
     float_Data @[10] {
      name="ActualAction_Output_Fm_ActionNodes_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=41;
      matrix_col_width=10;
     };
     float_Data @[11] {
      name="BeforeState_Fm_ActRelHid_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=31;
      matrix_col_width=10;
     };
     float_Data @[12] {
      name="ActionBetween_Fm_ActRelHid_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=33;
      matrix_col_width=10;
     };
     float_Data @[13] {
      name="AfterState_Fm_ActRelHid_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=30;
      matrix_col_width=10;
     };
     float_Data @[14] {
      name="AfterState_Fm_StateNodes_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=31;
      matrix_col_width=10;
     };
     float_Data @[15] {
      name="ActRelHid_Fm_BeforeState_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=31;
      matrix_col_width=10;
     };
     float_Data @[16] {
      name="ActRelHid_Fm_ActionBetween_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=33;
      matrix_col_width=10;
     };
     float_Data @[17] {
      name="ActRelHid_Fm_AfterState_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=30;
      matrix_col_width=10;
     };
     float_Data @[18] {
      name="StateNodes_Fm_StateNodes_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=31;
      matrix_col_width=10;
     };
     float_Data @[19] {
      name="StateNodes_Fm_BeforeState_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=32;
      matrix_col_width=10;
     };
     float_Data @[20] {
      name="StateNodes_Fm_AfterState_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=31;
      matrix_col_width=10;
     };
     float_Data @[21] {
      name="StateNodes_Fm_ActualState_Input_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=38;
      matrix_col_width=10;
     };
     float_Data @[22] {
      name="StateNodes_Fm_Goal_Input_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=31;
      matrix_col_width=10;
     };
     float_Data @[23] {
      name="ActionNodes_Fm_StateNodes_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=32;
      matrix_col_width=10;
     };
     float_Data @[24] {
      name="ActionNodes_Fm_ActionBetween_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=35;
      matrix_col_width=10;
     };
     float_Data @[25] {
      name="netmax";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
  };
  DataTable_Group @.gp[2] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
  };
  DataTable_Group @.gp[3] {
   name="ConfigData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
   DataTable @[0] {
    name="ConfigTable";
    desc="different configurations of the system";
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="config_id";
      desc="identifier for this type of configuration";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [3] "basic_train";"act_rel_train";"goal_dir_test";      };
     };
     String_Data @[1] {
      name="config_desc";
      desc="description of this configuration";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [3] "default basic training";"trn action-relations";"test goal-directed action choices";      };
     };
     String_Data @[2] {
      name="init_prog";
      desc="program to run to initialize at start of training";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [3] "BasicInit";"TrnActRelInit";"TstGoalDirInit";      };
     };
     String_Data @[3] {
      name="run_prog";
      desc="program controlling each step of running";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [3] "BasicRun";"TrnActRelRun";"TstGoalDirRun";      };
     };
     String_Data @[4] {
      name="startup_prog";
      desc="program for handling startup args specific to this environment";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [3] "BasicStartup";"BasicStartup";"BasicStartup";      };
     };
     int_Data @[5] {
      name="train_epochs";
      desc="number of total epochs to train for";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=12;
      matrix_col_width=10;
      ar {
       name="ar";
      [3] 200;500;10;      };
     };
     int_Data @[6] {
      name="trials_per_epoch";
      desc="number of individual trials per epoch";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [3] 50;50;10;      };
     };
     int_Data @[7] {
      name="save_final_wts";
      desc="save final weights after training (1 = yes, 0 = no)";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
      ar {
       name="ar";
      [3] 1;0;0;      };
     };
     int_Data @[8] {
      name="save_wts_interval";
      desc="how frequently to save weights during training (in epochs)";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=17;
      matrix_col_width=10;
      ar {
       name="ar";
      [3] 200;200;200;      };
     };
     int_Data @[9] {
      name="test_interval";
      desc="how frequently to test performance without training -- only applicable to training cases";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=13;
      matrix_col_width=10;
      ar {
       name="ar";
      [3] 1000;1000;1000;      };
     };
     int_Data @[10] {
      name="log_trials";
      desc="whether to log trial-level data or not (1 = yes, 0 = no)";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=10;
      matrix_col_width=10;
      ar {
       name="ar";
      [3] 0;0;0;      };
     };
     int_Data @[11] {
      name="load_weights";
      desc="whether to load weights at start";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=12;
      matrix_col_width=10;
      ar {
       name="ar";
      [3] 0;0;1;      };
     };
     String_Data @[12] {
      name="weights_file";
      desc="full relative path (from project) to a weights file to load at start of training";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [3] ;;"wts/Telos1_act_rel_trnd.wts";      };
     };
     int_Data @[13] {
      name="load_st_epc";
      desc="if loading weights, what epoch does it start at?";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=11;
      matrix_col_width=10;
      ar {
       name="ar";
      [3] 1;1;1;      };
     };
     int_Data @[14] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="lrs_step_epochs";
      desc="how many epochs per given step in the lrate schedule: each step drops the lrate roughly in half (log scale)";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=15;
      matrix_col_width=10;
      ar {
       name="ar";
      [3] 50;50;50;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [2] 1;2;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
  };
 };
 programs {
  name="programs";
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  debug_mode=0;
  Program @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserData_DocLink;
    el_def=0;
    UserData_DocLink @[0] {name="DocLink": doc=.programs[0].doc$$: };
   };
   name="MasterStartup";
   short_nm="Startup";
   tags="Leabra, Startup";
   desc="run project in the background (replaces leabra_startup.css)
command line is: emergent -nowin -ni -p <project name>.proj [enviro=xxx] [tag=xxx]";
   version {
    major=0;
    minor=0;
    step=0;
   };
   author=;
   email=;
   flags=STARTUP_RUN;
   stop_step_cond {
    expr=;
   };
   objs {
    name="objs";
    el_typ=taNBase;
    el_def=0;
   };
   objs_vars {
    name="objs_vars";
    el_typ=ProgVar;
    el_def=0;
   };
   types {
    name="types";
    el_typ=DynEnumType;
    el_def=0;
   };
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="network";
     var_type=T_Object;
     object_type=LeabraNetwork;
     completion_type=;
     object_val=.networks[0]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
     reference=0;
     desc="network to operate on -- updates batch counter on network and passes it to train program";
     init_from=NULL;
    };
   };
   vars {
    name="vars";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="batch";
     var_type=T_Object;
     object_type=Program;
     completion_type=;
     object_val=.programs.gp[1][0]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="set this to point to your batch process";
     init_from=NULL;
    };
    ProgVar @[1] {
     name="tag";
     var_type=T_String;
     string_val=;
     completion_type=;
     object_scope=NULL;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="config_id";
     var_type=T_String;
     string_val=;
     completion_type=;
     object_scope=NULL;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="selector for config to use";
     init_from=NULL;
    };
    ProgVar @[3] {
     name="log_dir";
     var_type=T_String;
     string_val=;
     completion_type=;
     object_scope=NULL;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="log file directory";
     init_from=NULL;
    };
    ProgVar @[4] {
     name="log_file_nm";
     var_type=T_String;
     string_val=;
     completion_type=;
     object_scope=NULL;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="name of log file";
     init_from=NULL;
    };
    ProgVar @[5] {
     name="log_trials";
     var_type=T_Bool;
     bool_val=0;
     completion_type=;
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[6] {
     name="EpochOutputData";
     var_type=T_Object;
     object_type=DataTable;
     completion_type=;
     object_val=.data.gp[1][1]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[7] {
     name="TrialOutputData";
     var_type=T_Object;
     object_type=DataTable;
     completion_type=;
     object_val=.data.gp[1][0]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[8] {
     name="Config";
     var_type=T_Object;
     object_type=DataTable;
     completion_type=;
     object_val=.data.gp[3][0]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[9] {
     name="batch_str";
     var_type=T_String;
     string_val="00";
     completion_type=;
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="batch number as a string (leading zeros)";
     init_from=NULL;
    };
    ProgVar @[10] {
     name="batch_start";
     var_type=T_Int;
     int_val=0;
     completion_type=;
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="batch starting number";
     init_from=NULL;
    };
    ProgVar @[11] {
     name="startup_prog";
     var_type=T_String;
     string_val="BasicStartup";
     completion_type=;
     object_scope=NULL;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name="functions";
    el_typ=Function;
    el_def=0;
    Function @[0] {
     name="set_n_units";
     desc=;
     flags=0;
     code_string=;
     return_type=T_Bool;
     object_type=taOBase;
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="lay";
       var_type=T_Object;
       object_type=Layer;
       completion_type=;
       object_val=NULL;
       object_scope=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="n_units";
       var_type=T_Int;
       int_val=0;
       completion_type=;
       object_scope=NULL;
       flags=LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     fun_code {
      name="fun_code";
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       name="If_iflayungeomnnunitsnunits0";
       desc=;
       flags=0;
       code_string=;
       cond {
	expr="lay->un_geom.n == n_units || n_units <= 0";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	ReturnExpr @[0] {
	 name="ReturnExpr_returnfalse";
	 desc=;
	 flags=0;
	 code_string=;
	 expr {
	  expr="false";
	 };
	};
       };
      };
      MethodCall @[1] {
       name="MethodCall_laySetNUnitsnunits";
       desc=;
       flags=0;
       code_string=;
       result_var=NULL;
       obj=.programs[0].functions[0].args[0]$$;
       method=Layer::SetNUnits;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="n_units";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="n_units";
	 };
	};
       };
       meth_sig="void SetNUnits(int n_units)";
       meth_desc=" set number of units in layer in the un_geom member -- attempts to lay out geometry in closest to a square that fits all the units evenly, if possible. note: does NOT rebuild the network. also does not make any changes if current number of units is same as arg, or arg <= 0 (e.g., for startup arg, just init n_units to -1 prior to getting arg val so it won't have any effect if arg not passed)";
      };
      PrintExpr @[2] {
       name="PrintExpr_Printlayerlaynam_uallylayungeomn";
       desc=;
       flags=0;
       code_string=;
       expr {
	expr="\"layer: \" << lay->name << \" changed to: \" << n_units << \" units, actually: \" << lay->un_geom.n";
       };
       debug=0;
      };
      ReturnExpr @[3] {
       name="ReturnExpr_returntrue";
       desc=;
       flags=0;
       code_string=;
       expr {
	expr="true";
       };
      };
     };
    };
   };
   init_code {
    name="init_code";
    el_typ=ProgCode;
    el_def=0;
   };
   prog_code {
    name="prog_code";
    el_typ=ProgCode;
    el_def=0;
    If @[0] {
     name="If_iftaMiscguiactive";
     desc=;
     flags=0;
     code_string=;
     cond {
      expr="taMisc::gui_active";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      ReturnExpr @[0] {
       name="ReturnExpr_return";
       desc=;
       flags=0;
       code_string=;
       expr {
	expr=;
       };
      };
     };
    };
    RegisterArgs @[1] {
     name="RegisterArgs_RegisterArgs";
     desc="This is KEY!!! actually processes all args, including those from ProgVarFmArg guys below";
     flags=0;
     code_string=;
    };
    PrintExpr @[2] {
     name="PrintExpr_PrintLoadedproje_ojects0filename";
     desc=;
     flags=0;
     code_string=;
     expr {
      expr="\"Loaded project: \" << .projects[0].file_name";
     };
     debug=0;
    };
    Comment @[3] {
     name="Comment_Stdvariablesinst_upprogramitself";
     desc="= Std variables in startup program itself =";
     flags=0;
     code_string=;
    };
    ProgVarFmArg @[4] {
     name="ProgVarFmArg_SetVartaginProgr_artupfromArgtag";
     desc=;
     flags=0;
     code_string=;
     prog=.programs[0]$$;
     var_name="tag";
     arg_name="tag";
    };
    ProgVarFmArg @[5] {
     name="ProgVarFmArg_SetVarlogdirinPr_upfromArglogdir";
     desc=;
     flags=0;
     code_string=;
     prog=$.programs[0]$;
     var_name="log_dir";
     arg_name="log_dir";
    };
    ProgVarFmArg @[6] {
     name="ProgVarFmArg_SetVarmaxbatchin_hfromArgbatches";
     desc=;
     flags=0;
     code_string=;
     prog=$.programs.gp[1][0]$;
     var_name="max_batch";
     arg_name="batches";
    };
    ProgVarFmArg @[7] {
     name="ProgVarFmArg_SetVarmaxbatchin_atchfromArgbend";
     desc="b_end is parallel-batch mode of operation (see b_start)";
     flags=0;
     code_string=;
     prog=$.programs.gp[1][0]$;
     var_name="max_batch";
     arg_name="b_end";
    };
    ProgVarFmArg @[8] {
     name="ProgVarFmArg_SetVarbatchinPro_chfromArgbstart";
     desc="b_start is parallel-batch mode of operation (see also b_end)";
     flags=0;
     code_string=;
     prog=$.programs.gp[1][0]$;
     var_name="batch";
     arg_name="b_start";
    };
    Comment @[9] {
     name="Comment_addourspecialargsfromcommandline";
     desc="add our special args from command line";
     flags=0;
     code_string=;
    };
    ProgVarFmArg @[10] {
     name="ProgVarFmArg_SetVarconfigidin_infromArgconfig";
     desc="NOTE: set in MasterTrain and copy from there, so it can use that default!";
     flags=0;
     code_string=;
     prog=$.programs.gp[1][1]$;
     var_name="config_id";
     arg_name="config";
    };
    ProgVarFmArg @[11] {
     name="ProgVarFmArg_SetVarlogtrialsi_romArglogtrials";
     desc=;
     flags=0;
     code_string=;
     prog=$.programs[0]$;
     var_name="log_trials";
     arg_name="log_trials";
    };
    OtherProgramVar @[12] {
     name="OtherProgramVar_VarsFmprogramMas_gidvar2var3var4";
     desc=;
     flags=0;
     code_string=;
     other_prog=$.programs.gp[1][1]$;
     set_other=0;
     var_1=.programs[0].vars[2]$$;
     var_2=NULL;
     var_3=NULL;
     var_4=NULL;
    };
    Comment @[13] {
     name="Comment_Networkresize";
     desc="= Network resize =";
     flags=0;
     code_string=;
    };
    MethodCall @[14] {
     name="MethodCall_networkBuild";
     desc=;
     flags=OFF;
     code_string=;
     result_var=NULL;
     obj=.programs[0].args[0]$$;
     method=Network::Build;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void Build()";
     meth_desc=" Build the network units and Connect them (calls CheckSpecs/BuildLayers/Units/Prjns and Connect)";
    };
    Comment @[15] {
     name="Comment_Trainingtimingse_ngparametersetc";
     desc="= Training timing sequencing parameters etc =";
     flags=0;
     code_string=;
    };
    Comment @[16] {
     name="Comment_Networkargs";
     desc="= Network args =";
     flags=0;
     code_string=;
    };
    MemberFmArg @[17] {
     name="MemberFmArg_networkcttimeminusArgminus";
     desc=;
     flags=0;
     code_string=;
     obj=$.programs[0].args[0]$;
     path="ct_time.minus";
     arg_name="minus";
     update_after=1;
     quiet=0;
    };
    MemberFmArg @[18] {
     name="MemberFmArg_networkcttimeplusArgplus";
     desc=;
     flags=0;
     code_string=;
     obj=$.programs[0].args[0]$;
     path="ct_time.plus";
     arg_name="plus";
     update_after=1;
     quiet=0;
    };
    MemberFmArg @[19] {
     name="MemberFmArg_networkctsravgstartArgsravgstart";
     desc=;
     flags=0;
     code_string=;
     obj=$.programs[0].args[0]$;
     path="ct_sravg.start";
     arg_name="sravg_start";
     update_after=1;
     quiet=0;
    };
    MemberFmArg @[20] {
     name="MemberFmArg_networkctsravgendArgsravgend";
     desc=;
     flags=0;
     code_string=;
     obj=$.programs[0].args[0]$;
     path="ct_sravg.end";
     arg_name="sravg_end";
     update_after=1;
     quiet=0;
    };
    Comment @[21] {
     name="Comment_Programspecificvars";
     desc="= Program specific vars =";
     flags=0;
     code_string=;
    };
    Comment @[22] {
     name="Comment_Addargstotagname";
     desc="= Add args to tag name =";
     flags=0;
     code_string=;
    };
    If @[23] {
     name="If_ifconfigidempty";
     desc=;
     flags=0;
     code_string=;
     cond {
      expr="config_id.empty()";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MiscCall @[0] {
       name="MiscCall_taMiscErrorlesso_tspecifybailing";
       desc=;
       flags=0;
       code_string=;
       result_var=NULL;
       object_type=taMisc;
       method=taMisc::Error;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="a";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"lesson_id is empty -- must specify!  bailing\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="b";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[2] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="c";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[3] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="d";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[4] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="e";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[5] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="f";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[6] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="g";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[7] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="h";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[8] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="i";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
      };
     };
    };
    AssignExpr @[24] {
     name="AssignExpr_tagconfigidtag";
     desc=;
     flags=0;
     code_string=;
     result_var=.programs[0].vars[1]$$;
     expr {
      expr="\"_\" +  config_id + tag";
     };
    };
    Comment @[25] {
     name="Comment_setanyparamsfromConfig";
     desc="set any params from Config";
     flags=0;
     code_string=;
    };
    DataColsFmArgs @[26] {
     name="DataColsFmArgs_DataColsFmArgsta_lrowvarconfigid";
     desc=;
     flags=0;
     code_string=;
     data_var=.programs[0].vars[8]$$;
     row_spec=ROW_VAL;
     row_var=$.programs[0].vars[2]$;
    };
    Comment @[27] {
     name="Comment_Setlogfiles";
     desc="Set log files";
     flags=0;
     code_string=;
    };
    If @[28] {
     name="If_iftaMiscCheckArgByNamebstart";
     desc="if passed b_start, then turn off init_batch in Batch program, so it starts here instead of 0";
     flags=0;
     code_string=;
     cond {
      expr="taMisc::CheckArgByName(\"b_start\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_batchSetVarinitbatchfalse";
       desc="directly set variable on batch program";
       flags=0;
       code_string=;
       result_var=NULL;
       obj=.programs[0].vars[0]$$;
       method=Program::SetVar;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="var_nm";
	 required=1;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="\"init_batch\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="value";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="bool SetVar(taString& var_nm, Variant& value)";
       meth_desc=" set the value of a program variable (only top-level variables in vars or args) -- can be called from within a running program";
      };
      ProgVarFmArg @[1] {
       name="ProgVarFmArg_SetVarbatchstart_upfromArgbstart";
       desc="read in the arg to us too, so we can set file names based on it";
       flags=0;
       code_string=;
       prog=$.programs[0]$;
       var_name="batch_start";
       arg_name="b_start";
      };
      MiscCall @[2] {
       name="MiscCall_batchstrtaMiscLe_erosbatchstart2";
       desc="string version with leading zeros";
       flags=0;
       code_string=;
       result_var=.programs[0].vars[9]$$;
       object_type=taMisc;
       method=taMisc::LeadingZeros;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="num";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="batch_start";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="len";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="2";
	 };
	};
       };
      };
      VarIncr @[3] {
       name="VarIncr_tagbatchstr";
       desc="add to tag for setting log file names";
       flags=0;
       code_string=;
       var=$.programs[0].vars[1]$;
       expr {
	expr="\".\" + batch_str";
       };
      };
     };
    };
    MethodCall @[29] {
     name="MethodCall_logfilenmEpochOu_argstaglogfalse";
     desc="save args to file: last arg is to include dmem proc number";
     flags=0;
     code_string=;
     result_var=.programs[0].vars[4]$$;
     obj=.programs[0].vars[6]$$;
     method=taBase::GetFileNameFmProject;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="ext";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\".args\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="tag";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="tag";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="subdir";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\"log\"";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="dmem_proc_no";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="false";
       };
      };
     };
     meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
     meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
    };
    MiscCall @[30] {
     name="MiscCall_taMiscFullArgStr_ToFilelogfilenm";
     desc=;
     flags=0;
     code_string=;
     result_var=NULL;
     object_type=taMisc;
     method=taMisc::FullArgStringToFile;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="fname";
       required=1;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="log_file_nm";
       };
      };
     };
    };
    MethodCall @[31] {
     name="MethodCall_logfilenmEpochOu_ttaglogdirfalse";
     desc="last arg is to include dmem proc number";
     flags=0;
     code_string=;
     result_var=$.programs[0].vars[4]$;
     obj=$.programs[0].vars[6]$;
     method=taBase::GetFileNameFmProject;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="ext";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\".epc.dat\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="tag";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="tag";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="subdir";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="log_dir";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="dmem_proc_no";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="false";
       };
      };
     };
     meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
     meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
    };
    MethodCall @[32] {
     name="MethodCall_EpochOutputDataS_filenmfalsetrue";
     desc="last arg is to restrict log to dmem_proc = 0";
     flags=0;
     code_string=;
     result_var=NULL;
     obj=$.programs[0].vars[6]$;
     method=DataTable::SaveDataLog;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="fname";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="log_file_nm";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="append";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="false";
       };
      };
      ProgArg @[2] {
       arg_type=bool;
       type="bool";
       name="dmem_proc_0";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="void SaveDataLog(taString& fname, bool append = false, bool dmem_proc_0 = true)";
     meth_desc=" incrementally save each new row of data that is written to the datatable (at WriteClose()) to given file. writes the header first if not appending to existing file. if running under demem, dmem_proc_0 determines if only the first processor writes to the log file, or if all processors write";
    };
    If @[33] {
     name="If_iflogtrials";
     desc=;
     flags=0;
     code_string=;
     cond {
      expr="log_trials";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_logfilenmTrialOu_attaglogdirtrue";
       desc="last arg is to include dmem proc number";
       flags=0;
       code_string=;
       result_var=$.programs[0].vars[4]$;
       obj=.programs[0].vars[7]$$;
       method=taBase::GetFileNameFmProject;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="ext";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\".trl.dat\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="tag";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="tag";
	 };
	};
	ProgArg @[2] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="subdir";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="log_dir";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="dmem_proc_no";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
       };
       meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
       meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
      };
      MethodCall @[1] {
       name="MethodCall_TrialOutputDataS_ilenmfalsefalse";
       desc="last arg is to restrict log to dmem_proc = 0";
       flags=0;
       code_string=;
       result_var=NULL;
       obj=$.programs[0].vars[7]$;
       method=DataTable::SaveDataLog;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="fname";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="log_file_nm";
	 };
	};
	ProgArg @[1] {
	 arg_type=bool;
	 type="bool";
	 name="append";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
	ProgArg @[2] {
	 arg_type=bool;
	 type="bool";
	 name="dmem_proc_0";
	 required=0;
	 def_val="true";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="void SaveDataLog(taString& fname, bool append = false, bool dmem_proc_0 = true)";
       meth_desc=" incrementally save each new row of data that is written to the datatable (at WriteClose()) to given file. writes the header first if not appending to existing file. if running under demem, dmem_proc_0 determines if only the first processor writes to the log file, or if all processors write";
      };
     };
    };
    OtherProgramVar @[34] {
     name="OtherProgramVar_VarsToprogramSav_tagvar2var3var4";
     desc=;
     flags=0;
     code_string=;
     other_prog=.programs.gp[4][12]$$;
     set_other=1;
     var_1=$.programs[0].vars[1]$;
     var_2=NULL;
     var_3=NULL;
     var_4=NULL;
    };
    Comment @[35] {
     name="Comment_Callsubstartupprograms";
     desc="= Call sub-startup programs =";
     flags=0;
     code_string=;
    };
    DataVarProg @[36] {
     name="DataVarProg_DataFromtableCon_rogvar2var3var4";
     desc=;
     flags=0;
     code_string=;
     data_var=$.programs[0].vars[8]$;
     row_spec=ROW_VAL;
     row_var=$.programs[0].vars[2]$;
     set_data=0;
     all_matches=0;
     quiet=0;
     var_1=.programs[0].vars[11]$$;
     var_2=NULL;
     var_3=NULL;
     var_4=NULL;
    };
    ProgramCallVar @[37] {
     name="ProgramCallVar_CallFmproggroupS_rtupprognetwork";
     desc=;
     flags=0;
     code_string=;
     prog_args {
      name="prog_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=LeabraNetwork;
       type="LeabraNetwork*";
       name="network";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="network";
       };
      };
     };
     prog_group=.programs.gp[0]$$;
     prog_name_var=$.programs[0].vars[11]$;
    };
    PrintExpr @[38] {
     name="PrintExpr_PrintRunningbatchname";
     desc=;
     flags=0;
     code_string=;
     expr {
      expr="\"Running: \" << batch.name";
     };
     debug=0;
    };
    ProgramCall @[39] {
     name="ProgramCall_MasterBatchnetwork";
     desc=;
     flags=0;
     code_string=;
     prog_args {
      name="prog_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=LeabraNetwork;
       type="LeabraNetwork*";
       name="network";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="network";
       };
      };
     };
     target=$.programs.gp[1][0]$;
     targ_ld_init="*LeabraBatch*";
    };
   };
   step_prog=.programs.gp[4][11]$$;
   step_n=1;
   doc {
    name="doc";
    desc=;
    web_doc=0;
    wiki=;
    url="local";
    full_url="local";
    text_size=1;
    text=;
    html_text=;
   };
  };
  Program_Group @.gp[0] {
   name="StartupProgs";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   debug_mode=0;
   Program @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][0].doc$$: };
    };
    name="BasicStartup";
    short_nm="BsStrt";
    tags="Leabra, Startup";
    desc="startup args specifically for fixation training parameters";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="tag";
      var_type=T_String;
      string_val=;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL;
      reference=0;
      desc=;
      init_from=$.programs[0]$;
     };
     ProgVar @[1] {
      name="log_trials";
      var_type=T_Bool;
      bool_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL;
      reference=0;
      desc=;
      init_from=$.programs[0]$;
     };
     ProgVar @[2] {
      name="log_dir";
      var_type=T_String;
      string_val="log/";
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL;
      reference=0;
      desc="log file directory";
      init_from=$.programs[0]$;
     };
     ProgVar @[3] {
      name="log_file_nm";
      var_type=T_String;
      string_val=;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="name of log file";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="SampleTrialOutData";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=NULL;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[5] {
      name="SampleEpochOutData";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=NULL;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     Comment @[0] {
      name="Comment_Setlogfiles";
      desc="= Set log files =";
      flags=0;
      code_string=;
     };
     MethodCall @[1] {
      name="MethodCall_logfilenmSampleE_ttaglogdirfalse";
      desc="last arg is to include dmem proc number";
      flags=OFF;
      code_string=;
      result_var=.programs.gp[0][0].vars[3]$$;
      obj=.programs.gp[0][0].vars[5]$$;
      method=taBase::GetFileNameFmProject;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="ext";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="\".fix_epc.dat\"";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="tag";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="tag";
	};
       };
       ProgArg @[2] {
	arg_type=const_taString_ref;
	type="taString&";
	name="subdir";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="log_dir";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="dmem_proc_no";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
      meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
     };
     MethodCall @[2] {
      name="MethodCall_SampleEpochOutDa_filenmfalsetrue";
      desc="last arg is to restrict log to dmem_proc = 0";
      flags=OFF;
      code_string=;
      result_var=NULL;
      obj=$.programs.gp[0][0].vars[5]$;
      method=DataTable::SaveDataLog;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="log_file_nm";
	};
       };
       ProgArg @[1] {
	arg_type=bool;
	type="bool";
	name="append";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
       ProgArg @[2] {
	arg_type=bool;
	type="bool";
	name="dmem_proc_0";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void SaveDataLog(taString& fname, bool append = false, bool dmem_proc_0 = true)";
      meth_desc=" incrementally save each new row of data that is written to the datatable (at WriteClose()) to given file. writes the header first if not appending to existing file. if running under demem, dmem_proc_0 determines if only the first processor writes to the log file, or if all processors write";
     };
     If @[3] {
      name="If_iflogtrials";
      desc=;
      flags=OFF;
      code_string=;
      cond {
       expr="log_trials";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_logfilenmSampleT_attaglogdirtrue";
	desc="last arg is to include dmem proc number";
	flags=0;
	code_string=;
	result_var=$.programs.gp[0][0].vars[3]$;
	obj=.programs.gp[0][0].vars[4]$$;
	method=taBase::GetFileNameFmProject;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="ext";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="\".fix_trl.dat\"";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="tag";
	  required=0;
	  def_val="\"\"";
	  prev_expr=;
	  expr {
	   expr="tag";
	  };
	 };
	 ProgArg @[2] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="subdir";
	  required=0;
	  def_val="\"\"";
	  prev_expr=;
	  expr {
	   expr="log_dir";
	  };
	 };
	 ProgArg @[3] {
	  arg_type=bool;
	  type="bool";
	  name="dmem_proc_no";
	  required=0;
	  def_val="false";
	  prev_expr=;
	  expr {
	   expr="true";
	  };
	 };
	};
	meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
	meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
       };
       MethodCall @[1] {
	name="MethodCall_SampleTrialOutDa_ilenmfalsefalse";
	desc="last arg is to restrict log to dmem_proc = 0";
	flags=OFF;
	code_string=;
	result_var=NULL;
	obj=$.programs.gp[0][0].vars[4]$;
	method=DataTable::SaveDataLog;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="fname";
	  required=0;
	  def_val="\"\"";
	  prev_expr=;
	  expr {
	   expr="log_file_nm";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=bool;
	  type="bool";
	  name="append";
	  required=0;
	  def_val="false";
	  prev_expr=;
	  expr {
	   expr="false";
	  };
	 };
	 ProgArg @[2] {
	  arg_type=bool;
	  type="bool";
	  name="dmem_proc_0";
	  required=0;
	  def_val="true";
	  prev_expr=;
	  expr {
	   expr="false";
	  };
	 };
	};
	meth_sig="void SaveDataLog(taString& fname, bool append = false, bool dmem_proc_0 = true)";
	meth_desc=" incrementally save each new row of data that is written to the datatable (at WriteClose()) to given file. writes the header first if not appending to existing file. if running under demem, dmem_proc_0 determines if only the first processor writes to the log file, or if all processors write";
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
  };
  Program_Group @.gp[1] {
   name="ConfigProgs";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   debug_mode=0;
   Program @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][0].doc$$: };
    };
    name="MasterBatch";
    short_nm="MstBtc";
    tags="Leabra, Std";
    desc="Iterate over training runs (a batch of training runs) -- just a simple loop that calls training program";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="batch";
      var_type=T_Int;
      int_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="batch counter";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="init_batch";
      var_type=T_Bool;
      bool_val=1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="initialize batch counter at start of run -- turn off if using \"parallel batch\" mode to run different batches on different processes";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="max_batch";
      var_type=T_Int;
      int_val=10;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="maximum number of batch runs to perform";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInitbatch";
      desc="initializes local batch counter and batch field on network";
      flags=0;
      code_string=;
      network_var=.programs.gp[1][0].args[0]$$;
      local_ctr_var=.programs.gp[1][0].vars[0]$$;
      counter=Network::batch;
      update_after=0;
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     If @[0] {
      name="If_ifinitbatch";
      desc=;
      flags=0;
      code_string=;
      cond {
       expr="init_batch";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       NetCounterInit @[0] {
	name="NetCounterInit_NetCounterInitbatch";
	desc="initializes local batch counter and batch field on network";
	flags=0;
	code_string=;
	network_var=$.programs.gp[1][0].args[0]$;
	local_ctr_var=$.programs.gp[1][0].vars[0]$;
	counter=Network::batch;
	update_after=0;
       };
      };
     };
     Else @[1] {
      name="Else_If_ifinitbatch";
      desc=;
      flags=0;
      code_string=;
      cond {
       expr=;
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MemberAssign @[0] {
	name="MemberAssign_networkbatchbatch";
	desc="just set directly to current batch value";
	flags=0;
	code_string=;
	obj=$.programs.gp[1][0].args[0]$;
	path="batch";
	expr {
	 expr="batch";
	};
	update_after=0;
       };
      };
     };
     WhileLoop @[2] {
      name="WhileLoop_whilebatchmaxbatch";
      desc="the main loop over training runs";
      flags=0;
      code_string=;
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_MasterTrainnetwork";
	desc="run the training program -- passes the network setting down";
	flags=0;
	code_string=;
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.programs.gp[1][1]$;
	targ_ld_init="*MasterTrain*";
       };
       NetCounterIncr @[1] {
	name="NetCounterIncr_NetCounterIncrbatch";
	desc="increment the local batch counter and copy to network";
	flags=0;
	code_string=;
	network_var=$.programs.gp[1][0].args[0]$;
	local_ctr_var=$.programs.gp[1][0].vars[0]$;
	counter=Network::batch;
	update_after=0;
       };
      };
      test {
       expr="batch < max_batch";
      };
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[1] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][1].doc$$: };
    };
    name="MasterTrain";
    short_nm="MstTrn";
    tags=;
    desc="modular event-based train program";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="stop_train";
      var_type=T_Bool;
      bool_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="set this var from any other program to stop training";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="Config";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[3][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="config_id";
      var_type=T_String;
      string_val="goal_dir_test";
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="configuration to use -- lookup in Config table";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="run_prog";
      var_type=T_String;
      string_val="TstGoalDirRun";
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="name of run program from the Config table";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="init_prog";
      var_type=T_String;
      string_val="TstGoalDirInit";
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="name of init program from the Config table";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     AssignExpr @[0] {
      name="AssignExpr_stoptrainfalse";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="stop_train = false";
      result_var=.programs.gp[1][1].vars[0]$$;
      expr {
       expr="false";
      };
     };
     WtInitPrompt @[1] {
      name="WtInitPrompt_ifguiDoyouwantto_eNetworkWeights";
      desc="don't initialize weights without checking";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (gui && \"Do you want to Initialize Network Weights\")";
      prompt="Do you want to Initialize Network Weights";
      yes_label="Yes";
      no_label="No";
      yes_code {
       name="yes_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkBuild";
	desc="need to have built network by now in any case, so do it here to make double sure -- prevents errs when loading project with startup program";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Build()";
	result_var=NULL;
	obj=.programs.gp[1][1].args[0]$$;
	method=Network::Build;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Build()";
	meth_desc=" Build the network units and Connect them (calls CheckSpecs/BuildLayers/Units/Prjns and Connect)";
       };
       MethodCall @[1] {
	name="MethodCall_networkInitWeights";
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Init_Weights()";
	result_var=NULL;
	obj=$.programs.gp[1][1].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Init_Weights()";
	meth_desc=" Initialize the weights -- also inits acts, counters and stats -- does unit level threaded and then does Layers after";
       };
       PrintExpr @[2] {
	name="PrintExpr_Printnetworkname_ghtsInitialized";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="Print network.name << \" Weights Initialized\"";
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
	debug=0;
       };
      };
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     AssignExpr @[0] {
      name="AssignExpr_stoptrainfalse";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="stop_train = false";
      result_var=$.programs.gp[1][1].vars[0]$;
      expr {
       expr="false";
      };
     };
     DataVarProg @[1] {
      name="DataVarProg_DataFromtableCon_runprogvar3var4";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Data From:  table=Config  row_spec=row_val  row_var=config_id  set=from  all_matches=false  var_1=init_prog  var_2=run_prog  var_3=?  var_4=? ";
      data_var=.programs.gp[1][1].vars[1]$$;
      row_spec=ROW_VAL;
      row_var=$.programs.gp[1][1].vars[2]$;
      set_data=0;
      all_matches=0;
      quiet=0;
      var_1=.programs.gp[1][1].vars[4]$$;
      var_2=.programs.gp[1][1].vars[3]$$;
      var_3=NULL;
      var_4=NULL;
     };
     ProgramCallVar @[2] {
      name="ProgramCallVar_CallFmproggroupI_networkconfigid";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Call Fm: prog_group=InitProgs prog_name_var=init_prog (network, config_id)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=taString;
	type="String";
	name="config_id";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="config_id";
	};
       };
      };
      prog_group=.programs.gp[1].gp[0]$$;
      prog_name_var=$.programs.gp[1][1].vars[4]$;
     };
     WhileLoop @[3] {
      name="WhileLoop_whilestoptrain";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="while (!stop_train)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_MasterRunnetworkconfigidrunprog";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="MasterRun(network, config_id, run_prog)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=taString;
	  type="String";
	  name="config_id";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="config_id";
	  };
	 };
	 ProgArg @[2] {
	  arg_type=taString;
	  type="String";
	  name="run_prog";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="run_prog";
	  };
	 };
	};
	target=.programs.gp[1][2]$$;
	targ_ld_init="*RobotRun*";
       };
      };
      test {
       expr="!stop_train";
      };
     };
    };
    step_prog=$.programs.gp[4][11]$;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[2] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][2].doc$$: };
    };
    name="MasterRun";
    short_nm="MstrRn";
    tags=;
    desc="modular run code -- forks off to RunProgs based on run_prog -- only neccessary to provide common step point for all run progs";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="config_id";
      var_type=T_String;
      string_val="goal_dir_test";
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="configuration to use -- lookup in Config table";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="run_prog";
      var_type=T_String;
      string_val="TstGoalDirRun";
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="name of run program from the Config table";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="Config";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[3][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     ProgramCallVar @[0] {
      name="ProgramCallVar_CallFmproggroupR_networkconfigid";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Call Fm: prog_group=RunProgs prog_name_var=run_prog (network, config_id)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=taString;
	type="String";
	name="config_id";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="config_id";
	};
       };
      };
      prog_group=.programs.gp[1].gp[1]$$;
      prog_name_var=.programs.gp[1][2].args[2]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program_Group @.gp[0] {
    name="InitProgs";
    el_typ=Program;
    el_def=0;
    tags=;
    desc="contains specific Init programs called at start of running by RobotInit";
    debug_mode=0;
    Program @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1].gp[0][0].doc$$: };
     };
     name="BasicInit";
     short_nm="Bscnt";
     tags=;
     desc="initialization for basic training";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author=;
     email=;
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=taNBase;
      el_def=0;
     };
     objs_vars {
      name="objs_vars";
      el_typ=ProgVar;
      el_def=0;
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=LeabraNetwork;
       completion_type=;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to operate on -- updates batch counter on network and passes it to train program";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="config_id";
       var_type=T_String;
       string_val="goal_dir_test";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="configuration to use -- lookup in Config table";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="lay_lesion_list";
       var_type=T_String;
       string_val=;
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="layers to lesion for this run";
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      ProgramCall @[0] {
       name="ProgramCall_StdGlobalsInitnetworkconfigid";
       desc="always do std globals init";
       flags=CAN_REVERT_TO_CODE;
       code_string="StdGlobalsInit(network, config_id)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=taString;
	 type="String";
	 name="config_id";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="config_id";
	 };
	};
       };
       target=.programs.gp[4][0]$$;
       targ_ld_init="*StdGlobalsInit*";
      };
      ProgramCall @[1] {
       name="ProgramCall_ConfigNetworknet_rklaylesionlist";
       desc="get rid of all non-essential layers";
       flags=CAN_REVERT_TO_CODE;
       code_string="ConfigNetwork(network, lay_lesion_list)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=taString;
	 type="String";
	 name="lesion_layers";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="lay_lesion_list";
	 };
	};
       };
       target=.programs.gp[4][2]$$;
       targ_ld_init="*ConfigNetwork*";
      };
      ProgramCall @[2] {
       name="ProgramCall_TrainStartnetwork";
       desc="standard init of training";
       flags=CAN_REVERT_TO_CODE;
       code_string="TrainStart(network)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       target=.programs.gp[4][4]$$;
       targ_ld_init="*TrainStart*";
      };
      If @[3] {
       name="If_ifconfigidcontainstest";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (config_id.contains(\"_test\"))";
       cond {
	expr="config_id.contains(\"_test\")";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MemberAssign @[0] {
	 name="MemberAssign_networktrainmode_abraNetworkTEST";
	 desc="set network to training mode";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.train_mode = LeabraNetwork::TEST";
	 obj=.programs.gp[1].gp[0][0].args[0]$$;
	 path="train_mode";
	 expr {
	  expr="LeabraNetwork::TEST";
	 };
	 update_after=0;
	};
       };
      };
      Else @[4] {
       name="Else_If_ifconfigidcontainstest";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="else";
       cond {
	expr=;
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MemberAssign @[0] {
	 name="MemberAssign_networktrainmode_braNetworkTRAIN";
	 desc="set network to training mode";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.train_mode = LeabraNetwork::TRAIN";
	 obj=$.programs.gp[1].gp[0][0].args[0]$;
	 path="train_mode";
	 expr {
	  expr="LeabraNetwork::TRAIN";
	 };
	 update_after=0;
	};
       };
      };
     };
     step_prog=NULL;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=0;
      wiki=;
      url="local";
      full_url="local";
      text_size=1;
      text=;
      html_text=;
     };
    };
    Program @[1] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1].gp[0][1].doc$$: };
     };
     name="TrnActRelInit";
     short_nm="TrnRln";
     tags=;
     desc="initialization for action-relation training";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author=;
     email=;
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=taNBase;
      el_def=0;
     };
     objs_vars {
      name="objs_vars";
      el_typ=ProgVar;
      el_def=0;
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=LeabraNetwork;
       completion_type=;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to operate on -- updates batch counter on network and passes it to train program";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="config_id";
       var_type=T_String;
       string_val="goal_dir_test";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="configuration to use -- lookup in Config table";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="lay_lesion_list";
       var_type=T_String;
       string_val="TempLesion";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="layers to lesion for this run";
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      ProgramCall @[0] {
       name="ProgramCall_StdGlobalsInitnetworkconfigid";
       desc="always do std globals init";
       flags=CAN_REVERT_TO_CODE;
       code_string="StdGlobalsInit(network, config_id)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=taString;
	 type="String";
	 name="config_id";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="config_id";
	 };
	};
       };
       target=$.programs.gp[4][0]$;
       targ_ld_init="*StdGlobalsInit*";
      };
      ProgramCall @[1] {
       name="ProgramCall_ConfigNetworknet_rklaylesionlist";
       desc="get rid of all non-essential layers";
       flags=CAN_REVERT_TO_CODE;
       code_string="ConfigNetwork(network, lay_lesion_list)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=taString;
	 type="String";
	 name="lesion_layers";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="lay_lesion_list";
	 };
	};
       };
       target=$.programs.gp[4][2]$;
       targ_ld_init="*ConfigNetwork*";
      };
      ProgramCall @[2] {
       name="ProgramCall_TrainStartnetwork";
       desc="standard init of training";
       flags=CAN_REVERT_TO_CODE;
       code_string="TrainStart(network)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       target=$.programs.gp[4][4]$;
       targ_ld_init="*TrainStart*";
      };
      If @[3] {
       name="If_ifconfigidcontainstest";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (config_id.contains(\"_test\"))";
       cond {
	expr="config_id.contains(\"_test\")";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MemberAssign @[0] {
	 name="MemberAssign_networktrainmode_abraNetworkTEST";
	 desc="set network to test mode";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.train_mode = LeabraNetwork::TEST";
	 obj=.programs.gp[1].gp[0][1].args[0]$$;
	 path="train_mode";
	 expr {
	  expr="LeabraNetwork::TEST";
	 };
	 update_after=0;
	};
       };
      };
      Else @[4] {
       name="Else_If_ifconfigidcontainstest";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="else";
       cond {
	expr=;
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MemberAssign @[0] {
	 name="MemberAssign_networktrainmode_braNetworkTRAIN";
	 desc="set network to training mode";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.train_mode = LeabraNetwork::TRAIN";
	 obj=$.programs.gp[1].gp[0][1].args[0]$;
	 path="train_mode";
	 expr {
	  expr="LeabraNetwork::TRAIN";
	 };
	 update_after=0;
	};
       };
      };
     };
     step_prog=NULL;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=0;
      wiki=;
      url="local";
      full_url="local";
      text_size=1;
      text=;
      html_text=;
     };
    };
    Program @[2] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1].gp[0][2].doc$$: };
     };
     name="TstGoalDirInit";
     short_nm="TsGDrn";
     tags=;
     desc="initialization for goal-directed action choice testing";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author=;
     email=;
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=taNBase;
      el_def=0;
     };
     objs_vars {
      name="objs_vars";
      el_typ=ProgVar;
      el_def=0;
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=LeabraNetwork;
       completion_type=;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to operate on -- updates batch counter on network and passes it to train program";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="config_id";
       var_type=T_String;
       string_val="goal_dir_test";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="configuration to use -- lookup in Config table";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="lay_lesion_list";
       var_type=T_String;
       string_val="WordInOut";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="layers to lesion for this run";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="WordAfter_InOut";
       var_type=T_Object;
       object_type=LeabraLayer;
       completion_type=;
       object_val=.networks[0].layers.gp[1][2]$$;
       object_scope=NULL;
       objs_ptr=0;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      ProgramCall @[0] {
       name="ProgramCall_StdGlobalsInitnetworkconfigid";
       desc="always do std globals init";
       flags=CAN_REVERT_TO_CODE;
       code_string="StdGlobalsInit(network, config_id)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=taString;
	 type="String";
	 name="config_id";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="config_id";
	 };
	};
       };
       target=$.programs.gp[4][0]$;
       targ_ld_init="*StdGlobalsInit*";
      };
      AssignExpr @[1] {
       name="AssignExpr_laylesionlistWordInOut";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="lay_lesion_list = \"WordInOut\"";
       result_var=.programs.gp[1].gp[0][2].vars[0]$$;
       expr {
	expr="\"WordInOut\"";
       };
      };
      AssignExpr @[2] {
       name="AssignExpr_laylesionlist";
       desc=;
       flags=OFF|CAN_REVERT_TO_CODE;
       code_string="lay_lesion_list = \"\"";
       result_var=$.programs.gp[1].gp[0][2].vars[0]$;
       expr {
	expr="\"\"";
       };
      };
      ProgramCall @[3] {
       name="ProgramCall_ConfigNetworknet_rklaylesionlist";
       desc="get rid of all non-essential layers";
       flags=CAN_REVERT_TO_CODE;
       code_string="ConfigNetwork(network, lay_lesion_list)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=taString;
	 type="String";
	 name="lesion_layers";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="lay_lesion_list";
	 };
	};
       };
       target=$.programs.gp[4][2]$;
       targ_ld_init="*ConfigNetwork*";
      };
      MethodCall @[4] {
       name="MethodCall_WordAfterInOutSe_yerLESIONEDtrue";
       desc="prevent recurrent activation making goal  input too strong";
       flags=OFF;
       code_string=;
       result_var=NULL;
       obj=.programs.gp[1].gp[0][2].vars[1]$$;
       method=Layer::SetLayerFlagState;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="flg";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="Layer::LESIONED";
	 };
	};
	ProgArg @[1] {
	 arg_type=bool;
	 type="bool";
	 name="on";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
       };
       meth_sig="void SetLayerFlagState(int flg, bool on)";
       meth_desc=" set flag state according to on bool (if true, set flag, if false, clear it)";
      };
      ProgramCall @[5] {
       name="ProgramCall_TrainStartnetwork";
       desc="standard init of training";
       flags=CAN_REVERT_TO_CODE;
       code_string="TrainStart(network)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       target=$.programs.gp[4][4]$;
       targ_ld_init="*TrainStart*";
      };
      If @[6] {
       name="If_ifconfigidcontainstest";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (config_id.contains(\"_test\"))";
       cond {
	expr="config_id.contains(\"_test\")";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MemberAssign @[0] {
	 name="MemberAssign_networktrainmode_abraNetworkTEST";
	 desc="set network to training mode";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.train_mode = LeabraNetwork::TEST";
	 obj=.programs.gp[1].gp[0][2].args[0]$$;
	 path="train_mode";
	 expr {
	  expr="LeabraNetwork::TEST";
	 };
	 update_after=0;
	};
       };
      };
      Else @[7] {
       name="Else_If_ifconfigidcontainstest";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="else";
       cond {
	expr=;
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MemberAssign @[0] {
	 name="MemberAssign_networktrainmode_braNetworkTRAIN";
	 desc="set network to training mode";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.train_mode = LeabraNetwork::TRAIN";
	 obj=$.programs.gp[1].gp[0][2].args[0]$;
	 path="train_mode";
	 expr {
	  expr="LeabraNetwork::TRAIN";
	 };
	 update_after=0;
	};
       };
      };
     };
     step_prog=NULL;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=0;
      wiki=;
      url="local";
      full_url="local";
      text_size=1;
      text=;
      html_text=;
     };
    };
   };
   Program_Group @.gp[1] {
    name="RunProgs";
    el_typ=Program;
    el_def=0;
    tags="contains individual Run programs for specific environments -- called by RobotRun";
    desc=;
    debug_mode=0;
    Program @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1].gp[1][0].doc$$: };
     };
     name="BasicRun";
     short_nm="BaseRun";
     tags=;
     desc="run basic training -- does ";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author=;
     email=;
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=taNBase;
      el_def=0;
     };
     objs_vars {
      name="objs_vars";
      el_typ=ProgVar;
      el_def=0;
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=LeabraNetwork;
       completion_type=;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to operate on -- updates batch counter on network and passes it to train program";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="config_id";
       var_type=T_String;
       string_val="goal_dir_test";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="configuration to use -- lookup in Config table";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="trials_per_epoch";
       var_type=T_Int;
       int_val=10;
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
       reference=0;
       desc=;
       init_from=$.programs.gp[4][0]$;
      };
      ProgVar @[1] {
       name="train_epochs";
       var_type=T_Int;
       int_val=10;
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
       reference=0;
       desc=;
       init_from=$.programs.gp[4][0]$;
      };
      ProgVar @[2] {
       name="update_net_view";
       var_type=T_Bool;
       bool_val=1;
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="if true, will update network views at end of settling";
       init_from=NULL;
      };
      ProgVar @[3] {
       name="StdInputData";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.data.gp[0][1]$$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      Comment @[0] {
       name="Comment_ExecuteOneTrialofBasicTraining";
       desc="== Execute One Trial of Basic Training ==";
       flags=CAN_REVERT_TO_CODE;
       code_string="// == Execute One Trial of Basic Training ==";
      };
      MemberAssign @[1] {
       name="MemberAssign_networktick0";
       desc="always in tick 0 for this -- only one step of processing";
       flags=CAN_REVERT_TO_CODE;
       code_string="network.tick = 0";
       obj=.programs.gp[1].gp[1][0].args[0]$$;
       path="tick";
       expr {
	expr="0";
       };
       update_after=0;
      };
      ProgramCall @[2] {
       name="ProgramCall_programname";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="BasicTrial_train(network, StdInputData, update_net_view)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="input_data";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="StdInputData";
	 };
	};
	ProgArg @[2] {
	 arg_type=bool;
	 type="bool";
	 name="update_net_view";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="update_net_view";
	 };
	};
       };
       target=NULL;
       targ_ld_init="*BasicTrain*";
      };
      Comment @[3] {
       name="Comment_DoneWithOneTrial";
       desc="== Done With One Trial ==";
       flags=CAN_REVERT_TO_CODE;
       code_string="// == Done With One Trial ==";
      };
      ProgramCall @[4] {
       name="ProgramCall_TrialEndnetwork";
       desc="standard end of trial stuff";
       flags=CAN_REVERT_TO_CODE;
       code_string="TrialEnd(network)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       target=.programs.gp[4][9]$$;
       targ_ld_init="*TrialEnd*";
      };
      ProgramCall @[5] {
       name="ProgramCall_LeabraTrialMonitornetwork";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="LeabraTrialMonitor(network)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=Network;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       target=.programs.gp[4].gp[0][0]$$;
       targ_ld_init="*LeabraTrialMonitor*";
      };
      MemberAssign @[6] {
       name="MemberAssign_networktrialnetworktrial1";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="network.trial = network.trial + 1";
       obj=$.programs.gp[1].gp[1][0].args[0]$;
       path="trial";
       expr {
	expr="network.trial + 1";
       };
       update_after=0;
      };
      If @[7] {
       name="If_ifnetworktrialtrialsperepoch";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (network.trial >= trials_per_epoch)";
       cond {
	expr="network.trial >= trials_per_epoch";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	ProgramCall @[0] {
	 name="ProgramCall_EpochEndnetwork";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="EpochEnd(network)";
	 prog_args {
	  name="prog_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=LeabraNetwork;
	   type="LeabraNetwork*";
	   name="network";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 target=.programs.gp[4][7]$$;
	 targ_ld_init="*EpochEnd*";
	};
	MemberAssign @[1] {
	 name="MemberAssign_networkepochnetworkepoch1";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.epoch = network.epoch + 1";
	 obj=$.programs.gp[1].gp[1][0].args[0]$;
	 path="epoch";
	 expr {
	  expr="network.epoch + 1";
	 };
	 update_after=0;
	};
	If @[2] {
	 name="If_ifnetworkepochtrainepochs";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (network.epoch >= train_epochs)";
	 cond {
	  expr="network.epoch >= train_epochs";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  ProgramCall @[0] {
	   name="ProgramCall_TrainEndnetwork";
	   desc="calls stop_train and does final training stuff";
	   flags=CAN_REVERT_TO_CODE;
	   code_string="TrainEnd(network)";
	   prog_args {
	    name="prog_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=LeabraNetwork;
	     type="LeabraNetwork*";
	     name="network";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="network";
	     };
	    };
	   };
	   target=.programs.gp[4][5]$$;
	   targ_ld_init="*TrainEnd*";
	  };
	  ReturnExpr @[1] {
	   name="ReturnExpr_return";
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="return ";
	   expr {
	    expr=;
	   };
	  };
	 };
	};
	ProgramCall @[3] {
	 name="ProgramCall_EpochStartnetwork";
	 desc="time to start a new epoch!";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="EpochStart(network)";
	 prog_args {
	  name="prog_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=LeabraNetwork;
	   type="LeabraNetwork*";
	   name="network";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 target=.programs.gp[4][6]$$;
	 targ_ld_init="*EpochStart*";
	};
       };
      };
     };
     step_prog=NULL;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=0;
      wiki=;
      url="local";
      full_url="local";
      text_size=1;
      text=;
      html_text=;
     };
    };
    Program @[1] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1].gp[1][1].doc$$: };
     };
     name="TrnActRelRun";
     short_nm="TrnRRn";
     tags=;
     desc="run action-relation training ";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author=;
     email=;
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=taNBase;
      el_def=0;
     };
     objs_vars {
      name="objs_vars";
      el_typ=ProgVar;
      el_def=0;
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=LeabraNetwork;
       completion_type=;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to operate on -- updates batch counter on network and passes it to train program";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="config_id";
       var_type=T_String;
       string_val="goal_dir_test";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="configuration to use -- lookup in Config table";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="trials_per_epoch";
       var_type=T_Int;
       int_val=10;
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
       reference=0;
       desc=;
       init_from=$.programs.gp[4][0]$;
      };
      ProgVar @[1] {
       name="train_epochs";
       var_type=T_Int;
       int_val=10;
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
       reference=0;
       desc=;
       init_from=$.programs.gp[4][0]$;
      };
      ProgVar @[2] {
       name="update_net_view";
       var_type=T_Bool;
       bool_val=1;
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="if true, will update network views at end of settling";
       init_from=NULL;
      };
      ProgVar @[3] {
       name="input_data";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=$.data.gp[0][1]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      Comment @[0] {
       name="Comment_ExecuteOneTrialofBasicTraining";
       desc="== Execute One Trial of Basic Training ==";
       flags=CAN_REVERT_TO_CODE;
       code_string="// == Execute One Trial of Basic Training ==";
      };
      MemberAssign @[1] {
       name="MemberAssign_networktick0";
       desc="always in tick 0 for this -- only one step of processing";
       flags=CAN_REVERT_TO_CODE;
       code_string="network.tick = 0";
       obj=.programs.gp[1].gp[1][1].args[0]$$;
       path="tick";
       expr {
	expr="0";
       };
       update_after=0;
      };
      If @[2] {
       name="If_ifnetworkepochtrainepochs";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (network.epoch<train_epochs)";
       cond {
	expr="network.epoch<train_epochs";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	If @[0] {
	 name="If_ifnetworktrial0";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (network.trial==0)";
	 cond {
	  expr="network.trial==0";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  ProgramCall @[0] {
	   name="ProgramCall_WriteInputDataTrnActionRelation";
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="WriteInputData_TrnActionRelation()";
	   prog_args {
	    name="prog_args";
	    el_typ=ProgArg;
	    el_def=0;
	   };
	   target=.programs.gp[3].gp[0][0]$$;
	   targ_ld_init="*WriteInputData_TrnActionRelation*";
	  };
	 };
	};
       };
      };
      ProgramCall @[3] {
       name="ProgramCall_TrnActRelTrialne_taupdatenetview";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="TrnActRelTrial(network, input_data, update_net_view)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="input_data";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="input_data";
	 };
	};
	ProgArg @[2] {
	 arg_type=bool;
	 type="bool";
	 name="update_net_view";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="update_net_view";
	 };
	};
       };
       target=.programs.gp[2].gp[0][0]$$;
       targ_ld_init="*TrnActRelTrial*";
      };
      Comment @[4] {
       name="Comment_DoneWithOneTrial";
       desc="== Done With One Trial ==";
       flags=CAN_REVERT_TO_CODE;
       code_string="// == Done With One Trial ==";
      };
      ProgramCall @[5] {
       name="ProgramCall_TrialEndnetwork";
       desc="standard end of trial stuff";
       flags=CAN_REVERT_TO_CODE;
       code_string="TrialEnd(network)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       target=$.programs.gp[4][9]$;
       targ_ld_init="*TrialEnd*";
      };
      ProgramCall @[6] {
       name="ProgramCall_LeabraTrialMonitornetwork";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="LeabraTrialMonitor(network)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=Network;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       target=$.programs.gp[4].gp[0][0]$;
       targ_ld_init="*LeabraTrialMonitor*";
      };
      MemberAssign @[7] {
       name="MemberAssign_networktrialnetworktrial1";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="network.trial = network.trial + 1";
       obj=$.programs.gp[1].gp[1][1].args[0]$;
       path="trial";
       expr {
	expr="network.trial + 1";
       };
       update_after=0;
      };
      If @[8] {
       name="If_ifnetworktrialtrialsperepoch";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (network.trial >= trials_per_epoch)";
       cond {
	expr="network.trial >= trials_per_epoch";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	ProgramCall @[0] {
	 name="ProgramCall_EpochEndnetwork";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="EpochEnd(network)";
	 prog_args {
	  name="prog_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=LeabraNetwork;
	   type="LeabraNetwork*";
	   name="network";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 target=$.programs.gp[4][7]$;
	 targ_ld_init="*EpochEnd*";
	};
	MemberAssign @[1] {
	 name="MemberAssign_networkepochnetworkepoch1";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.epoch = network.epoch + 1";
	 obj=$.programs.gp[1].gp[1][1].args[0]$;
	 path="epoch";
	 expr {
	  expr="network.epoch + 1";
	 };
	 update_after=0;
	};
	If @[2] {
	 name="If_ifnetworkepochtrainepochs";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (network.epoch >= train_epochs)";
	 cond {
	  expr="network.epoch >= train_epochs";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  ProgramCall @[0] {
	   name="ProgramCall_TrainEndnetwork";
	   desc="calls stop_train and does final training stuff";
	   flags=CAN_REVERT_TO_CODE;
	   code_string="TrainEnd(network)";
	   prog_args {
	    name="prog_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=LeabraNetwork;
	     type="LeabraNetwork*";
	     name="network";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="network";
	     };
	    };
	   };
	   target=$.programs.gp[4][5]$;
	   targ_ld_init="*TrainEnd*";
	  };
	  ReturnExpr @[1] {
	   name="ReturnExpr_return";
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="return ";
	   expr {
	    expr=;
	   };
	  };
	 };
	};
	ProgramCall @[3] {
	 name="ProgramCall_EpochStartnetwork";
	 desc="time to start a new epoch!";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="EpochStart(network)";
	 prog_args {
	  name="prog_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=LeabraNetwork;
	   type="LeabraNetwork*";
	   name="network";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 target=$.programs.gp[4][6]$;
	 targ_ld_init="*EpochStart*";
	};
       };
      };
     };
     step_prog=$.programs.gp[4][11]$;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=0;
      wiki=;
      url="local";
      full_url="local";
      text_size=1;
      text=;
      html_text=;
     };
    };
    Program @[2] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1].gp[1][2].doc$$: };
     };
     name="TstGoalDirRun";
     short_nm="TsGDrR";
     tags=;
     desc="run goal-directed action choice testing";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author=;
     email=;
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=taNBase;
      el_def=0;
     };
     objs_vars {
      name="objs_vars";
      el_typ=ProgVar;
      el_def=0;
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=LeabraNetwork;
       completion_type=;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to operate on -- updates batch counter on network and passes it to train program";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="config_id";
       var_type=T_String;
       string_val="goal_dir_test";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="configuration to use -- lookup in Config table";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="trials_per_epoch";
       var_type=T_Int;
       int_val=10;
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
       reference=0;
       desc=;
       init_from=$.programs.gp[4][0]$;
      };
      ProgVar @[1] {
       name="train_epochs";
       var_type=T_Int;
       int_val=10;
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
       reference=0;
       desc=;
       init_from=$.programs.gp[4][0]$;
      };
      ProgVar @[2] {
       name="update_net_view";
       var_type=T_Bool;
       bool_val=1;
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="if true, will update network views at end of settling";
       init_from=NULL;
      };
      ProgVar @[3] {
       name="input_data";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.data.gp[0][2]$$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      Comment @[0] {
       name="Comment_ExecuteOneTrialofBasicTraining";
       desc="== Execute One Trial of Basic Training ==";
       flags=CAN_REVERT_TO_CODE;
       code_string="// == Execute One Trial of Basic Training ==";
      };
      MemberAssign @[1] {
       name="MemberAssign_networktick0";
       desc="always in tick 0 for this -- only one step of processing";
       flags=CAN_REVERT_TO_CODE;
       code_string="network.tick = 0";
       obj=.programs.gp[1].gp[1][2].args[0]$$;
       path="tick";
       expr {
	expr="0";
       };
       update_after=0;
      };
      If @[2] {
       name="If_ifnetworkepochtrainepochs";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (network.epoch<train_epochs)";
       cond {
	expr="network.epoch<train_epochs";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	If @[0] {
	 name="If_ifnetworktrial0";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (network.trial==0)";
	 cond {
	  expr="network.trial==0";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  ProgramCall @[0] {
	   name="ProgramCall_WriteInputDataTs_lDirectedTrials";
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="WriteInputData_TstGoalDirectedTrials()";
	   prog_args {
	    name="prog_args";
	    el_typ=ProgArg;
	    el_def=0;
	   };
	   target=.programs.gp[3].gp[1][0]$$;
	   targ_ld_init="*WriteInputData_TstGoalDirectedTrials*";
	  };
	 };
	};
       };
      };
      ProgramCall @[3] {
       name="ProgramCall_TstGoalDirTrialn_taupdatenetview";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="TstGoalDirTrial(network, input_data, update_net_view)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="input_data";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="input_data";
	 };
	};
	ProgArg @[2] {
	 arg_type=bool;
	 type="bool";
	 name="update_net_view";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="update_net_view";
	 };
	};
       };
       target=.programs.gp[2].gp[1][0]$$;
       targ_ld_init="*TstGoalDirTrial*";
      };
      Comment @[4] {
       name="Comment_DoneWithOneTrial";
       desc="== Done With One Trial ==";
       flags=CAN_REVERT_TO_CODE;
       code_string="// == Done With One Trial ==";
      };
      ProgramCall @[5] {
       name="ProgramCall_TrialEndnetwork";
       desc="standard end of trial stuff";
       flags=CAN_REVERT_TO_CODE;
       code_string="TrialEnd(network)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       target=$.programs.gp[4][9]$;
       targ_ld_init="*TrialEnd*";
      };
      ProgramCall @[6] {
       name="ProgramCall_LeabraTrialMonitornetwork";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="LeabraTrialMonitor(network)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=Network;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       target=$.programs.gp[4].gp[0][0]$;
       targ_ld_init="*LeabraTrialMonitor*";
      };
      MemberAssign @[7] {
       name="MemberAssign_networktrialnetworktrial1";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="network.trial = network.trial + 1";
       obj=$.programs.gp[1].gp[1][2].args[0]$;
       path="trial";
       expr {
	expr="network.trial + 1";
       };
       update_after=0;
      };
      If @[8] {
       name="If_ifnetworktrialtrialsperepoch";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (network.trial >= trials_per_epoch)";
       cond {
	expr="network.trial >= trials_per_epoch";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	ProgramCall @[0] {
	 name="ProgramCall_EpochEndnetwork";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="EpochEnd(network)";
	 prog_args {
	  name="prog_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=LeabraNetwork;
	   type="LeabraNetwork*";
	   name="network";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 target=$.programs.gp[4][7]$;
	 targ_ld_init="*EpochEnd*";
	};
	MemberAssign @[1] {
	 name="MemberAssign_networkepochnetworkepoch1";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.epoch = network.epoch + 1";
	 obj=$.programs.gp[1].gp[1][2].args[0]$;
	 path="epoch";
	 expr {
	  expr="network.epoch + 1";
	 };
	 update_after=0;
	};
	If @[2] {
	 name="If_ifnetworkepochtrainepochs";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (network.epoch >= train_epochs)";
	 cond {
	  expr="network.epoch >= train_epochs";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  ProgramCall @[0] {
	   name="ProgramCall_TrainEndnetwork";
	   desc="calls stop_train and does final training stuff";
	   flags=CAN_REVERT_TO_CODE;
	   code_string="TrainEnd(network)";
	   prog_args {
	    name="prog_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=LeabraNetwork;
	     type="LeabraNetwork*";
	     name="network";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="network";
	     };
	    };
	   };
	   target=$.programs.gp[4][5]$;
	   targ_ld_init="*TrainEnd*";
	  };
	  ReturnExpr @[1] {
	   name="ReturnExpr_return";
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="return ";
	   expr {
	    expr=;
	   };
	  };
	 };
	};
	ProgramCall @[3] {
	 name="ProgramCall_EpochStartnetwork";
	 desc="time to start a new epoch!";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="EpochStart(network)";
	 prog_args {
	  name="prog_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=LeabraNetwork;
	   type="LeabraNetwork*";
	   name="network";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 target=$.programs.gp[4][6]$;
	 targ_ld_init="*EpochStart*";
	};
       };
      };
     };
     step_prog=NULL;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=0;
      wiki=;
      url="local";
      full_url="local";
      text_size=1;
      text=;
      html_text=;
     };
    };
   };
  };
  Program_Group @.gp[2] {
   name="TaskProgs";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   debug_mode=0;
   Program_Group @.gp[0] {
    name="TrnActRel";
    el_typ=Program;
    el_def=0;
    tags=;
    desc=;
    debug_mode=0;
    Program @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[2].gp[0][0].doc$$: };
     };
     name="TrnActRelTrial";
     short_nm="TrnRTr";
     tags=;
     desc="one trial of training the action-relationship contigency -- pretty much a standard Leabra minus-plus trial";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author=;
     email=;
     flags=2;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=taNBase;
      el_def=0;
      TimeUsed @[0] {name="BasicTrainTime": start={usr=103464: sys=16293: tot=158095504367: }: end={usr=103459: sys=16293: tot=158095504362: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
     };
     objs_vars {
      name="objs_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="basic_train_time";
       var_type=T_Object;
       object_type=TimeUsed;
       completion_type=;
       object_val=.programs.gp[2].gp[0][0].objs[0]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=LeabraNetwork;
       completion_type=;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to operate on -- updates batch counter on network and passes it to train program";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="input_data";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=$.data.gp[0][1]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="update_net_view";
       var_type=T_Bool;
       bool_val=1;
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="if true, will update network views at end of settling";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="TrialTypeInputs";
       var_type=T_String;
       string_val="Action+After";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="TrialName";
       var_type=T_String;
       string_val="A2_8+S8->S2";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="WordBefore_InOut";
       var_type=T_Object;
       object_type=LeabraLayer;
       completion_type=;
       object_val=.networks[0].layers.gp[1][0]$$;
       object_scope=NULL;
       objs_ptr=0;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="WordAction_InOut";
       var_type=T_Object;
       object_type=LeabraLayer;
       completion_type=;
       object_val=.networks[0].layers.gp[1][1]$$;
       object_scope=NULL;
       objs_ptr=0;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="WordAfter_InOut";
       var_type=T_Object;
       object_type=LeabraLayer;
       completion_type=;
       object_val=$.networks[0].layers.gp[1][2]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="i";
       var_type=T_Int;
       int_val=1;
       completion_type=;
       object_scope=NULL;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[6] {
       name="j";
       var_type=T_Int;
       int_val=10;
       completion_type=;
       object_scope=NULL;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_basictraintimeResetUsed";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="basic_train_time->ResetUsed()";
       result_var=NULL;
       obj=.programs.gp[2].gp[0][0].objs_vars[0]$$;
       method=TimeUsed::ResetUsed;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void ResetUsed()";
       meth_desc=" reset time used information";
      };
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_basictraintimeStartTimerfalse";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="basic_train_time->StartTimer(false)";
       result_var=NULL;
       obj=$.programs.gp[2].gp[0][0].objs_vars[0]$;
       method=TimeUsed::StartTimer;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="reset_used";
	 required=0;
	 def_val="true";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="void StartTimer(bool reset_used = true)";
       meth_desc=" record the current time as the starting time, and optionally reset the time used information";
      };
      Comment @[1] {
       name="Comment_StartTrial";
       desc="=== Start Trial ===";
       flags=CAN_REVERT_TO_CODE;
       code_string="// === Start Trial ===";
      };
      ProgramCall @[2] {
       name="ProgramCall_TrialStartnetwork";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="TrialStart(network)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       target=.programs.gp[4][8]$$;
       targ_ld_init="*TrialStart*";
      };
      ProgramCall @[3] {
       name="ProgramCall_ChooseSeqEventnetworkinputdata";
       desc=;
       flags=OFF;
       code_string=;
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="input_data";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="input_data";
	 };
	};
       };
       target=.programs.gp[3][1]$$;
       targ_ld_init="*ChooseSeqEvent*";
      };
      ProgramCall @[4] {
       name="ProgramCall_ChooseRandomEventinputdata";
       desc="pick next event at random..";
       flags=CAN_REVERT_TO_CODE;
       code_string="ChooseRandomEvent(input_data)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="input_data";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="input_data";
	 };
	};
       };
       target=.programs.gp[3][0]$$;
       targ_ld_init="*ChooseRandomEvent*";
      };
      DataVarProg @[5] {
       name="DataVarProg_DataFromtableinp_ialNamevar3var4";
       desc=;
       flags=NEW_EL|CAN_REVERT_TO_CODE;
       code_string="Data From:  table=input_data  row_spec=cur_row  set=from  all_matches=false  var_1=TrialTypeInputs  var_2=TrialName  var_3=?  var_4=? ";
       data_var=.programs.gp[2].gp[0][0].args[1]$$;
       row_spec=CUR_ROW;
       row_var=NULL;
       set_data=0;
       all_matches=0;
       quiet=0;
       var_1=.programs.gp[2].gp[0][0].vars[0]$$;
       var_2=.programs.gp[2].gp[0][0].vars[1]$$;
       var_3=NULL;
       var_4=NULL;
      };
      MemberAssign @[6] {
       name="MemberAssign_networktrialnameTrialName";
       desc=;
       flags=NEW_EL|CAN_REVERT_TO_CODE;
       code_string="network.trial_name = TrialName";
       obj=.programs.gp[2].gp[0][0].args[0]$$;
       path="trial_name";
       expr {
	expr="TrialName";
       };
       update_after=0;
      };
      If @[7] {
       name="If_ifTrialTypeInputscontainsAfter";
       desc=;
       flags=NEW_EL|CAN_REVERT_TO_CODE;
       code_string="if (!(TrialTypeInputs.contains(\"After\")))";
       cond {
	expr="!(TrialTypeInputs.contains(\"After\"))";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	Comment @[0] {
	 name="Comment_AfterhastobeTARGET";
	 desc="= 'After' has to be TARGET";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="// = 'After' has to be TARGET";
	};
	MemberAssign @[1] {
	 name="MemberAssign_WordAfterInOutla_typeLayerTARGET";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="WordAfter_InOut.layer_type = Layer::TARGET";
	 obj=.programs.gp[2].gp[0][0].vars[4]$$;
	 path="layer_type";
	 expr {
	  expr="Layer::TARGET";
	 };
	 update_after=0;
	};
       };
      };
      Else @[8] {
       name="Else_If_ifTrialTypeInputscontainsAfter";
       desc=;
       flags=NEW_EL|CAN_REVERT_TO_CODE;
       code_string="else";
       cond {
	expr=;
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	If @[0] {
	 name="If_ifTrialTypeInputscontainsBefore";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (!(TrialTypeInputs.contains(\"Before\")))";
	 cond {
	  expr="!(TrialTypeInputs.contains(\"Before\"))";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  Comment @[0] {
	   name="Comment_BeforehastobeTARGET";
	   desc="= 'Before' has to be TARGET";
	   flags=CAN_REVERT_TO_CODE;
	   code_string="// = 'Before' has to be TARGET";
	  };
	  MemberAssign @[1] {
	   name="MemberAssign_WordBeforeInOutl_typeLayerTARGET";
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="WordBefore_InOut.layer_type = Layer::TARGET";
	   obj=.programs.gp[2].gp[0][0].vars[2]$$;
	   path="layer_type";
	   expr {
	    expr="Layer::TARGET";
	   };
	   update_after=0;
	  };
	 };
	};
	Else @[1] {
	 name="Else_If_ifTrialTypeInputscontainsBefore";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="else";
	 cond {
	  expr=;
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  Comment @[0] {
	   name="Comment_ActionhastobeTARGET";
	   desc="= 'Action' has to be TARGET";
	   flags=CAN_REVERT_TO_CODE;
	   code_string="// = 'Action' has to be TARGET";
	  };
	  If @[1] {
	   name="If_ifTrialTypeInputscontainsAction";
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="if (!(TrialTypeInputs.contains(\"Action\")))";
	   cond {
	    expr="!(TrialTypeInputs.contains(\"Action\"))";
	   };
	   true_code {
	    name="true_code";
	    el_typ=ProgCode;
	    el_def=0;
	    MemberAssign @[0] {
	     name="MemberAssign_WordActionInOutl_typeLayerTARGET";
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="WordAction_InOut.layer_type = Layer::TARGET";
	     obj=.programs.gp[2].gp[0][0].vars[3]$$;
	     path="layer_type";
	     expr {
	      expr="Layer::TARGET";
	     };
	     update_after=0;
	    };
	   };
	  };
	 };
	};
       };
      };
      ProgramCall @[9] {
       name="ProgramCall_ApplyInputsTrnAc_etworkinputdata";
       desc="apply std external input activations from the input_data table to the network";
       flags=CAN_REVERT_TO_CODE;
       code_string="ApplyInputs_TrnActRel(network, input_data)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=Network;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="input_data";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="input_data";
	 };
	};
       };
       target=.programs.gp[3][3]$$;
       targ_ld_init="*ApplyInputs_TrnActRel*";
      };
      Comment @[10] {
       name="Comment_RunMinusPhase";
       desc="=== Run Minus Phase ===";
       flags=CAN_REVERT_TO_CODE;
       code_string="// === Run Minus Phase ===";
      };
      MethodCall @[11] {
       name="MethodCall_networkmethod";
       desc="initializes various counters at start of settling";
       flags=OFF;
       code_string=;
       result_var=NULL;
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       method=NULL;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig=;
       meth_desc=;
      };
      MemberAssign @[12] {
       name="MemberAssign_networkphaseLeab_tworkMINUSPHASE";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="network.phase = LeabraNetwork::MINUS_PHASE";
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       path="phase";
       expr {
	expr="LeabraNetwork::MINUS_PHASE";
       };
       update_after=0;
      };
      MemberAssign @[13] {
       name="MemberAssign_networkquarter0";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="network.quarter = 0";
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       path="quarter";
       expr {
	expr="0";
       };
       update_after=0;
      };
      MemberAssign @[14] {
       name="MemberAssign_networktimescycleqtrfalse";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="network.times.cycle_qtr = false";
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       path="times.cycle_qtr";
       expr {
	expr="false";
       };
       update_after=0;
      };
      ForLoop @[15] {
       name="ForLoop_fori0i3i";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="for (i = 0; i < 3; i++)";
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	MemberAssign @[0] {
	 name="MemberAssign_networkquarteri";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.quarter = i";
	 obj=$.programs.gp[2].gp[0][0].args[0]$;
	 path="quarter";
	 expr {
	  expr="i";
	 };
	 update_after=0;
	};
	MethodCall @[1] {
	 name="MethodCall_networkQuarterInit";
	 desc="initializes various counters at start of settling";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network->Quarter_Init()";
	 result_var=NULL;
	 obj=$.programs.gp[2].gp[0][0].args[0]$;
	 method=LeabraNetwork::Quarter_Init;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="void Quarter_Init()";
	 meth_desc=" initialize network for quarter-level processing (hard clamp, netscale)";
	};
	ForLoop @[2] {
	 name="ForLoop_forj0j25j";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="for (j = 0; j < 25; j++)";
	 loop_code {
	  name="loop_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MemberAssign @[0] {
	   name="MemberAssign_networkcyclej";
	   desc=;
	   flags=OFF|CAN_REVERT_TO_CODE;
	   code_string="network.phase = LeabraNetwork::MINUS_PHASE";
	   obj=$.programs.gp[2].gp[0][0].args[0]$;
	   path="cycle";
	   expr {
	    expr="j";
	   };
	   update_after=0;
	  };
	  MethodCall @[1] {
	   name="MethodCall_networkCycleRun";
	   desc=;
	   flags=OFF|CAN_REVERT_TO_CODE;
	   code_string="network->Cycle_Run()";
	   result_var=NULL;
	   obj=$.programs.gp[2].gp[0][0].args[0]$;
	   method=LeabraNetwork::Cycle_Run;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	   };
	   meth_sig="void Cycle_Run()";
	   meth_desc=" compute cycle(s) of updating: netinput, inhibition, activations -- multiple cycles can be run depending on lthreads.n_cycles setting and whether multiple threads are actually being used -- see lthreads.n_threads_act";
	  };
	  ProgramCall @[2] {
	   name="ProgramCall_Cyclenetwork";
	   desc="network->Cycle_Run(); network.cycle +=1";
	   flags=CAN_REVERT_TO_CODE;
	   code_string="Cycle(network)";
	   prog_args {
	    name="prog_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=LeabraNetwork;
	     type="LeabraNetwork*";
	     name="network";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="network";
	     };
	    };
	   };
	   target=$.programs.gp[4][11]$;
	   targ_ld_init="*Cycle*";
	  };
	 };
	 init {
	  expr="j = 0";
	 };
	 test {
	  expr="j < 25";
	 };
	 iter {
	  expr="j++";
	 };
	};
	MethodCall @[3] {
	 name="MethodCall_networkQuarterFinal";
	 desc="initializes various counters at start of settling";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network->Quarter_Final()";
	 result_var=NULL;
	 obj=$.programs.gp[2].gp[0][0].args[0]$;
	 method=LeabraNetwork::Quarter_Final;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="void Quarter_Final()";
	 meth_desc=" do final processing after each quarter: ";
	};
       };
       init {
	expr="i = 0";
       };
       test {
	expr="i < 3";
       };
       iter {
	expr="i++";
       };
      };
      ProgramCall @[16] {
       name="ProgramCall_programname";
       desc="settle for minus phase, using ct_time.minus as fixed number of cycles to run";
       flags=OFF;
       code_string=;
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="cycle_max";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network.ct_time.minus";
	 };
	};
       };
       target=NULL;
       targ_ld_init="*SettleMinus*";
      };
      ProgramCall @[17] {
       name="ProgramCall_programname_1";
       desc="settle for minus phase";
       flags=OFF|CAN_REVERT_TO_CODE;
       code_string="SettleMinus(network, 75)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="cycle_max";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="75";
	 };
	};
       };
       target=NULL;
       targ_ld_init="*SettleMinus*";
      };
      MethodCall @[18] {
       name="MethodCall_networkmethod_1";
       desc="perform final operations at end of settling (storing final activations, etc)";
       flags=OFF;
       code_string=;
       result_var=NULL;
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       method=NULL;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig=;
       meth_desc=;
      };
      MethodCall @[19] {
       name="MethodCall_networkQuarterFinal";
       desc="perform final operations at end of settling (storing final activations, etc)";
       flags=OFF|CAN_REVERT_TO_CODE;
       code_string="network->Quarter_Final()";
       result_var=NULL;
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       method=LeabraNetwork::Quarter_Final;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void Quarter_Final()";
       meth_desc=" do final processing after each quarter: ";
      };
      MethodCall @[20] {
       name="MethodCall_networkComputeMinusStats";
       desc="compute trial-level statistics -- only in minus phase!";
       flags=CAN_REVERT_TO_CODE;
       code_string="network->Compute_MinusStats()";
       result_var=NULL;
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       method=LeabraNetwork::Compute_MinusStats;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void Compute_MinusStats()";
       meth_desc=" compute the stats that should be computed at the end of the minus phase: minus_output_name -- typically call this using Compute_PhaseStats which does the appropriate call given the current network phase";
      };
      NetUpdateView @[21] {
       name="NetUpdateView_NetUpdateView";
       desc="update network views, if update_net_view == true";
       flags=CAN_REVERT_TO_CODE;
       code_string="Net Update View";
       network_var=$.programs.gp[2].gp[0][0].args[0]$;
       update_var=.programs.gp[2].gp[0][0].args[2]$$;
      };
      StopStepPoint @[22] {
       name="StopStepPoint_StopStepPoint";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Stop_Step Point";
       cond {
	expr=;
       };
      };
      Comment @[23] {
       name="Comment_RunPlusPhase";
       desc="=== Run Plus Phase ===";
       flags=CAN_REVERT_TO_CODE;
       code_string="// === Run Plus Phase ===";
      };
      ProgramCall @[24] {
       name="ProgramCall_programname_2";
       desc="start the plus phase";
       flags=OFF|CAN_REVERT_TO_CODE;
       code_string="PlusPhaseStart(network)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       target=NULL;
       targ_ld_init="*PlusPhaseStart*";
      };
      MemberAssign @[25] {
       name="MemberAssign_networkphaseLeab_etworkPLUSPHASE";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="network.phase = LeabraNetwork::PLUS_PHASE";
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       path="phase";
       expr {
	expr="LeabraNetwork::PLUS_PHASE";
       };
       update_after=0;
      };
      MemberAssign @[26] {
       name="MemberAssign_networkquarternetworkquarter1";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="network.quarter = network.quarter+1";
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       path="quarter";
       expr {
	expr="network.quarter+1";
       };
       update_after=0;
      };
      MethodCall @[27] {
       name="MethodCall_networkmethod";
       desc="increments other phase state information to prepare for the next phase of settling";
       flags=OFF;
       code_string=;
       result_var=NULL;
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       method=NULL;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig=;
       meth_desc=;
      };
      MethodCall @[28] {
       name="MethodCall_networkmethod_1";
       desc="TEMPORARY!!!!!! increments other phase state information to prepare for the next phase of settling";
       flags=OFF;
       code_string=;
       result_var=NULL;
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       method=NULL;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig=;
       meth_desc=;
      };
      MethodCall @[29] {
       name="MethodCall_networkInitInputData";
       desc="resets input data, before getting new external inputs data from apply inputs call";
       flags=CAN_REVERT_TO_CODE;
       code_string="network->Init_InputData()";
       result_var=NULL;
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       method=Network::Init_InputData;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void Init_InputData()";
       meth_desc=" Initializes external and target inputs";
      };
      ProgramCall @[30] {
       name="ProgramCall_ApplyInputsTrnAc_etworkinputdata_1";
       desc="apply std external input activations from the input_data table to the network";
       flags=CAN_REVERT_TO_CODE;
       code_string="ApplyInputs_TrnActRel(network, input_data)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=Network;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="input_data";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="input_data";
	 };
	};
       };
       target=$.programs.gp[3][3]$;
       targ_ld_init="*ApplyInputs_TrnActRel*";
      };
      MethodCall @[31] {
       name="MethodCall_networkmethod_2";
       desc="initializes various counters at start of settling";
       flags=OFF;
       code_string=;
       result_var=NULL;
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       method=NULL;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig=;
       meth_desc=;
      };
      ProgramCall @[32] {
       name="ProgramCall_Settlenetworknetworkcttimeplus";
       desc="settle for designated plus phase number of cycles";
       flags=OFF;
       code_string=;
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="cycle_max";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network.ct_time.plus";
	 };
	};
       };
       target=.programs.gp[4][10]$$;
       targ_ld_init="*Settle*";
      };
      ProgramCall @[33] {
       name="ProgramCall_Settlenetwork25";
       desc="ct_time.plus too short and can't find it to change it!!!!!!";
       flags=OFF|CAN_REVERT_TO_CODE;
       code_string="Settle(network, 25)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="cycle_max";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="25";
	 };
	};
       };
       target=$.programs.gp[4][10]$;
       targ_ld_init="*Settle*";
      };
      MethodCall @[34] {
       name="MethodCall_networkQuarterInit";
       desc="initializes various counters at start of settling";
       flags=CAN_REVERT_TO_CODE;
       code_string="network->Quarter_Init()";
       result_var=NULL;
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       method=LeabraNetwork::Quarter_Init;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void Quarter_Init()";
       meth_desc=" initialize network for quarter-level processing (hard clamp, netscale)";
      };
      ForLoop @[35] {
       name="ForLoop_fori0i25i";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="for (i = 0; i < 25; i++)";
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	MemberAssign @[0] {
	 name="MemberAssign_networkcyclei";
	 desc=;
	 flags=OFF|CAN_REVERT_TO_CODE;
	 code_string="network.phase = LeabraNetwork::MINUS_PHASE";
	 obj=$.programs.gp[2].gp[0][0].args[0]$;
	 path="cycle";
	 expr {
	  expr="i";
	 };
	 update_after=0;
	};
	MethodCall @[1] {
	 name="MethodCall_networkCycleRun";
	 desc=;
	 flags=OFF|CAN_REVERT_TO_CODE;
	 code_string="network->Cycle_Run()";
	 result_var=NULL;
	 obj=$.programs.gp[2].gp[0][0].args[0]$;
	 method=LeabraNetwork::Cycle_Run;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="void Cycle_Run()";
	 meth_desc=" compute cycle(s) of updating: netinput, inhibition, activations -- multiple cycles can be run depending on lthreads.n_cycles setting and whether multiple threads are actually being used -- see lthreads.n_threads_act";
	};
	ProgramCall @[2] {
	 name="ProgramCall_Cyclenetwork";
	 desc="network->Cycle_Run(); network.cycle +=1";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Cycle(network)";
	 prog_args {
	  name="prog_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=LeabraNetwork;
	   type="LeabraNetwork*";
	   name="network";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 target=$.programs.gp[4][11]$;
	 targ_ld_init="*Cycle*";
	};
       };
       init {
	expr="i = 0";
       };
       test {
	expr="i < 25";
       };
       iter {
	expr="i++";
       };
      };
      MethodCall @[36] {
       name="MethodCall_networkQuarterFinal_1";
       desc="initializes various counters at start of settling";
       flags=CAN_REVERT_TO_CODE;
       code_string="network->Quarter_Final()";
       result_var=NULL;
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       method=LeabraNetwork::Quarter_Final;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void Quarter_Final()";
       meth_desc=" do final processing after each quarter: ";
      };
      MethodCall @[37] {
       name="MethodCall_networkComputePlusStats";
       desc="compute trial-level statistics -- only in minus phase!";
       flags=CAN_REVERT_TO_CODE;
       code_string="network->Compute_PlusStats()";
       result_var=NULL;
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       method=LeabraNetwork::Compute_PlusStats;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void Compute_PlusStats()";
       meth_desc=" compute the stats that should be computed at the end of the plus phase: all the error stats: SSE, PRerr, NormErr, CosErr, ExtRew -- typically call this using Compute_PhaseStats which does the appropriate call given the current network phase";
      };
      MemberAssign @[38] {
       name="MemberAssign_networktrialnameTrialName_1";
       desc=;
       flags=OFF|NEW_EL|CAN_REVERT_TO_CODE;
       code_string="network.trial_name = TrialName";
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       path="trial_name";
       expr {
	expr="TrialName";
       };
       update_after=0;
      };
      MethodCall @[39] {
       name="MethodCall_networkmethod_3";
       desc="perform final operations at end of settling (storing final activations, etc)";
       flags=OFF;
       code_string=;
       result_var=NULL;
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       method=NULL;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig=;
       meth_desc=;
      };
      MethodCall @[40] {
       name="MethodCall_networkQuarterFinal";
       desc="perform final operations at end of settling (storing final activations, etc)";
       flags=OFF|CAN_REVERT_TO_CODE;
       code_string="network->Quarter_Final()";
       result_var=NULL;
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       method=LeabraNetwork::Quarter_Final;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void Quarter_Final()";
       meth_desc=" do final processing after each quarter: ";
      };
      MethodCall @[41] {
       name="MethodCall_networkComputeExtRew";
       desc="get external reward information";
       flags=CAN_REVERT_TO_CODE;
       code_string="network->Compute_ExtRew()";
       result_var=NULL;
       obj=$.programs.gp[2].gp[0][0].args[0]$;
       method=LeabraNetwork::Compute_ExtRew;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void Compute_ExtRew()";
       meth_desc=" compute external reward information: called in plus phase stats";
      };
      NetUpdateView @[42] {
       name="NetUpdateView_NetUpdateView_1";
       desc="update network views, if update_net_view == true";
       flags=CAN_REVERT_TO_CODE;
       code_string="Net Update View";
       network_var=$.programs.gp[2].gp[0][0].args[0]$;
       update_var=$.programs.gp[2].gp[0][0].args[2]$;
      };
      Comment @[43] {
       name="Comment_resetlayerstoINP_nextrandomtrial";
       desc="= reset layers to INPUT for next random trial";
       flags=CAN_REVERT_TO_CODE;
       code_string="// = reset layers to INPUT for next random trial";
      };
      MemberAssign @[44] {
       name="MemberAssign_WordBeforeInOutl_rtypeLayerINPUT";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="WordBefore_InOut.layer_type = Layer::INPUT";
       obj=$.programs.gp[2].gp[0][0].vars[2]$;
       path="layer_type";
       expr {
	expr="Layer::INPUT";
       };
       update_after=0;
      };
      MemberAssign @[45] {
       name="MemberAssign_WordActionInOutl_rtypeLayerINPUT";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="WordAction_InOut.layer_type = Layer::INPUT";
       obj=$.programs.gp[2].gp[0][0].vars[3]$;
       path="layer_type";
       expr {
	expr="Layer::INPUT";
       };
       update_after=0;
      };
      MemberAssign @[46] {
       name="MemberAssign_WordAfterInOutla_rtypeLayerINPUT";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="WordAfter_InOut.layer_type = Layer::INPUT";
       obj=$.programs.gp[2].gp[0][0].vars[4]$;
       path="layer_type";
       expr {
	expr="Layer::INPUT";
       };
       update_after=0;
      };
      MethodCall @[47] {
       name="MethodCall_basictraintimeEndTimer";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="basic_train_time->EndTimer()";
       result_var=NULL;
       obj=$.programs.gp[2].gp[0][0].objs_vars[0]$;
       method=TimeUsed::EndTimer;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void EndTimer()";
       meth_desc=" record the current time as the ending time, and compute difference as the time used";
      };
     };
     step_prog=NULL;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=0;
      wiki=;
      url="local";
      full_url="local";
      text_size=1;
      text=;
      html_text=;
     };
    };
   };
   Program_Group @.gp[1] {
    name="TstGoalDir";
    el_typ=Program;
    el_def=0;
    tags=;
    desc=;
    debug_mode=0;
    Program @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[2].gp[1][0].doc$$: };
     };
     name="TstGoalDirTrial";
     short_nm="TsGDrT";
     tags=;
     desc="one trial of testing the goal-directed constraint satisfaction effect -- pretty much a standard Leabra minus-plus trial, but with no training (i.e., COMP not TARG)";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author=;
     email=;
     flags=2;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=taNBase;
      el_def=0;
      TimeUsed @[0] {name="BasicTrainTime": start={usr=112107: sys=19711: tot=158095723417: }: end={usr=112105: sys=19710: tot=158095723414: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
     };
     objs_vars {
      name="objs_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="basic_train_time";
       var_type=T_Object;
       object_type=TimeUsed;
       completion_type=;
       object_val=.programs.gp[2].gp[1][0].objs[0]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=LeabraNetwork;
       completion_type=;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to operate on -- updates batch counter on network and passes it to train program";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="input_data";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=$.data.gp[0][2]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="update_net_view";
       var_type=T_Bool;
       bool_val=1;
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="if true, will update network views at end of settling";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="TrialTypeInputGoal";
       var_type=T_String;
       string_val="Current+Goal";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="TrialName";
       var_type=T_String;
       string_val="S0+S8->A0_2";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="WordGoal_InOut";
       var_type=T_Object;
       object_type=LeabraLayer;
       completion_type=;
       object_val=.networks[0].layers.gp[0][2]$$;
       object_scope=NULL;
       objs_ptr=0;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="WordBefore_InOut";
       var_type=T_Object;
       object_type=LeabraLayer;
       completion_type=;
       object_val=$.networks[0].layers.gp[1][0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="WordAfter_InOut";
       var_type=T_Object;
       object_type=LeabraLayer;
       completion_type=;
       object_val=$.networks[0].layers.gp[1][2]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="WordAction_InOut";
       var_type=T_Object;
       object_type=LeabraLayer;
       completion_type=;
       object_val=$.networks[0].layers.gp[1][1]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[6] {
       name="ActualAction_Output";
       var_type=T_Object;
       object_type=LeabraLayer;
       completion_type=;
       object_val=.networks[0].layers.gp[0][1]$$;
       object_scope=NULL;
       objs_ptr=0;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[7] {
       name="ActualState_Input";
       var_type=T_Object;
       object_type=LeabraLayer;
       completion_type=;
       object_val=.networks[0].layers.gp[0][0]$$;
       object_scope=NULL;
       objs_ptr=0;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[8] {
       name="i";
       var_type=T_Int;
       int_val=2;
       completion_type=;
       object_scope=NULL;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[9] {
       name="j";
       var_type=T_Int;
       int_val=49;
       completion_type=;
       object_scope=NULL;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_basictraintimeResetUsed";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="basic_train_time->ResetUsed()";
       result_var=NULL;
       obj=.programs.gp[2].gp[1][0].objs_vars[0]$$;
       method=TimeUsed::ResetUsed;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void ResetUsed()";
       meth_desc=" reset time used information";
      };
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_basictraintimeStartTimerfalse";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="basic_train_time->StartTimer(false)";
       result_var=NULL;
       obj=$.programs.gp[2].gp[1][0].objs_vars[0]$;
       method=TimeUsed::StartTimer;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="reset_used";
	 required=0;
	 def_val="true";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="void StartTimer(bool reset_used = true)";
       meth_desc=" record the current time as the starting time, and optionally reset the time used information";
      };
      Comment @[1] {
       name="Comment_StartTrial";
       desc="=== Start Trial ===";
       flags=CAN_REVERT_TO_CODE;
       code_string="// === Start Trial ===";
      };
      ProgramCall @[2] {
       name="ProgramCall_TrialStartnetwork";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="TrialStart(network)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       target=$.programs.gp[4][8]$;
       targ_ld_init="*TrialStart*";
      };
      ProgramCall @[3] {
       name="ProgramCall_ChooseSeqEventnetworkinputdata";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="ChooseSeqEvent(network, input_data)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="input_data";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="input_data";
	 };
	};
       };
       target=$.programs.gp[3][1]$;
       targ_ld_init="*ChooseSeqEvent*";
      };
      ProgramCall @[4] {
       name="ProgramCall_ChooseRandomEventinputdata";
       desc="pick next event at random..";
       flags=OFF;
       code_string=;
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="input_data";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="input_data";
	 };
	};
       };
       target=$.programs.gp[3][0]$;
       targ_ld_init="*ChooseRandomEvent*";
      };
      DataVarProg @[5] {
       name="DataVarProg_DataFromtableinp_ialNamevar3var4";
       desc=;
       flags=NEW_EL|CAN_REVERT_TO_CODE;
       code_string="Data From:  table=input_data  row_spec=cur_row  set=from  all_matches=false  var_1=TrialTypeInputGoal  var_2=TrialName  var_3=?  var_4=? ";
       data_var=.programs.gp[2].gp[1][0].args[1]$$;
       row_spec=CUR_ROW;
       row_var=NULL;
       set_data=0;
       all_matches=0;
       quiet=0;
       var_1=.programs.gp[2].gp[1][0].vars[0]$$;
       var_2=.programs.gp[2].gp[1][0].vars[1]$$;
       var_3=NULL;
       var_4=NULL;
      };
      MemberAssign @[6] {
       name="MemberAssign_ActualStateInput_rtypeLayerINPUT";
       desc="just making sure it's the right layer type";
       flags=CAN_REVERT_TO_CODE;
       code_string="ActualState_Input.layer_type = Layer::INPUT";
       obj=.programs.gp[2].gp[1][0].vars[7]$$;
       path="layer_type";
       expr {
	expr="Layer::INPUT";
       };
       update_after=0;
      };
      MemberAssign @[7] {
       name="MemberAssign_WordGoalInOutlayertypeLayerINPUT";
       desc="just making sure";
       flags=CAN_REVERT_TO_CODE;
       code_string="WordGoal_InOut.layer_type = Layer::INPUT";
       obj=.programs.gp[2].gp[1][0].vars[2]$$;
       path="layer_type";
       expr {
	expr="Layer::INPUT";
       };
       update_after=0;
      };
      MemberAssign @[8] {
       name="MemberAssign_WordBeforeInOutl_rtypeLayerINPUT";
       desc="make sure SSE not counted";
       flags=CAN_REVERT_TO_CODE;
       code_string="WordBefore_InOut.layer_type = Layer::INPUT";
       obj=.programs.gp[2].gp[1][0].vars[3]$$;
       path="layer_type";
       expr {
	expr="Layer::INPUT";
       };
       update_after=0;
      };
      MemberAssign @[9] {
       name="MemberAssign_WordAfterInOutla_rtypeLayerINPUT";
       desc="make sure SSE not counted";
       flags=CAN_REVERT_TO_CODE;
       code_string="WordAfter_InOut.layer_type = Layer::INPUT";
       obj=.programs.gp[2].gp[1][0].vars[4]$$;
       path="layer_type";
       expr {
	expr="Layer::INPUT";
       };
       update_after=0;
      };
      MemberAssign @[10] {
       name="MemberAssign_WordActionInOutl_rtypeLayerINPUT";
       desc="make sure SSE not counted";
       flags=CAN_REVERT_TO_CODE;
       code_string="WordAction_InOut.layer_type = Layer::INPUT";
       obj=.programs.gp[2].gp[1][0].vars[5]$$;
       path="layer_type";
       expr {
	expr="Layer::INPUT";
       };
       update_after=0;
      };
      MemberAssign @[11] {
       name="MemberAssign_ActualActionOutp_typeLayerOUTPUT";
       desc="for comparison only - no learning";
       flags=CAN_REVERT_TO_CODE;
       code_string="ActualAction_Output.layer_type = Layer::OUTPUT";
       obj=.programs.gp[2].gp[1][0].vars[6]$$;
       path="layer_type";
       expr {
	expr="Layer::OUTPUT";
       };
       update_after=0;
      };
      ProgramCall @[12] {
       name="ProgramCall_ApplyInputsTstGo_etworkinputdata";
       desc="apply std external input activations from the input_data table to the network";
       flags=CAN_REVERT_TO_CODE;
       code_string="ApplyInputs_TstGoalDir(network, input_data)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=Network;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="input_data";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="input_data";
	 };
	};
       };
       target=.programs.gp[3][4]$$;
       targ_ld_init="*ApplyInputs_TstGoalDir*";
      };
      Comment @[13] {
       name="Comment_RunMinusPhase";
       desc="=== Run Minus Phase ===";
       flags=CAN_REVERT_TO_CODE;
       code_string="// === Run Minus Phase ===";
      };
      MethodCall @[14] {
       name="MethodCall_networkmethod";
       desc="initializes various counters at start of settling";
       flags=OFF;
       code_string=;
       result_var=NULL;
       obj=.programs.gp[2].gp[1][0].args[0]$$;
       method=NULL;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig=;
       meth_desc=;
      };
      ProgramCall @[15] {
       name="ProgramCall_programname";
       desc="settle for minus phase, using ct_time.minus as fixed number of cycles to run";
       flags=OFF;
       code_string=;
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="cycle_max";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network.ct_time.minus";
	 };
	};
       };
       target=NULL;
       targ_ld_init="*SettleMinus*";
      };
      ProgramCall @[16] {
       name="ProgramCall_programname_1";
       desc="settle for minus phase, using ct_time.minus as fixed number of cycles to run";
       flags=OFF|CAN_REVERT_TO_CODE;
       code_string="SettleMinus(network, 150)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="cycle_max";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="150";
	 };
	};
       };
       target=NULL;
       targ_ld_init="*SettleMinus*";
      };
      MemberAssign @[17] {
       name="MemberAssign_networktrialnameTrialName";
       desc=;
       flags=NON_STD|NEW_EL|CAN_REVERT_TO_CODE;
       code_string="network.trial_name = TrialName";
       obj=$.programs.gp[2].gp[1][0].args[0]$;
       path="trial_name";
       expr {
	expr="TrialName";
       };
       update_after=0;
      };
      MemberAssign @[18] {
       name="MemberAssign_networkphaseLeab_tworkMINUSPHASE";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="network.phase = LeabraNetwork::MINUS_PHASE";
       obj=$.programs.gp[2].gp[1][0].args[0]$;
       path="phase";
       expr {
	expr="LeabraNetwork::MINUS_PHASE";
       };
       update_after=0;
      };
      MemberAssign @[19] {
       name="MemberAssign_networkquarter0";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="network.quarter = 0";
       obj=$.programs.gp[2].gp[1][0].args[0]$;
       path="quarter";
       expr {
	expr="0";
       };
       update_after=0;
      };
      ForLoop @[20] {
       name="ForLoop_fori0i3i";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="for (i = 0; i < 3; i++)";
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	MemberAssign @[0] {
	 name="MemberAssign_networkquarteri";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.quarter = i";
	 obj=$.programs.gp[2].gp[1][0].args[0]$;
	 path="quarter";
	 expr {
	  expr="i";
	 };
	 update_after=0;
	};
	MethodCall @[1] {
	 name="MethodCall_networkQuarterInit";
	 desc="initializes various counters at start of settling";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network->Quarter_Init()";
	 result_var=NULL;
	 obj=$.programs.gp[2].gp[1][0].args[0]$;
	 method=LeabraNetwork::Quarter_Init;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="void Quarter_Init()";
	 meth_desc=" initialize network for quarter-level processing (hard clamp, netscale)";
	};
	ForLoop @[2] {
	 name="ForLoop_forj0j50j";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="for (j = 0; j < 50; j++)";
	 loop_code {
	  name="loop_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MemberAssign @[0] {
	   name="MemberAssign_networkcyclej";
	   desc=;
	   flags=OFF|CAN_REVERT_TO_CODE;
	   code_string="network.phase = LeabraNetwork::MINUS_PHASE";
	   obj=$.programs.gp[2].gp[1][0].args[0]$;
	   path="cycle";
	   expr {
	    expr="j";
	   };
	   update_after=0;
	  };
	  MethodCall @[1] {
	   name="MethodCall_networkCycleRun";
	   desc=;
	   flags=OFF|CAN_REVERT_TO_CODE;
	   code_string="network->Cycle_Run()";
	   result_var=NULL;
	   obj=$.programs.gp[2].gp[1][0].args[0]$;
	   method=LeabraNetwork::Cycle_Run;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	   };
	   meth_sig="void Cycle_Run()";
	   meth_desc=" compute cycle(s) of updating: netinput, inhibition, activations -- multiple cycles can be run depending on lthreads.n_cycles setting and whether multiple threads are actually being used -- see lthreads.n_threads_act";
	  };
	  ProgramCall @[2] {
	   name="ProgramCall_Cyclenetwork";
	   desc="network->Cycle_Run(); network.cycle +=1";
	   flags=CAN_REVERT_TO_CODE;
	   code_string="Cycle(network)";
	   prog_args {
	    name="prog_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=LeabraNetwork;
	     type="LeabraNetwork*";
	     name="network";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="network";
	     };
	    };
	   };
	   target=$.programs.gp[4][11]$;
	   targ_ld_init="*Cycle*";
	  };
	 };
	 init {
	  expr="j = 0";
	 };
	 test {
	  expr="j < 50";
	 };
	 iter {
	  expr="j++";
	 };
	};
	MethodCall @[3] {
	 name="MethodCall_networkQuarterFinal";
	 desc="initializes various counters at start of settling";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network->Quarter_Final()";
	 result_var=NULL;
	 obj=$.programs.gp[2].gp[1][0].args[0]$;
	 method=LeabraNetwork::Quarter_Final;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="void Quarter_Final()";
	 meth_desc=" do final processing after each quarter: ";
	};
       };
       init {
	expr="i = 0";
       };
       test {
	expr="i < 3";
       };
       iter {
	expr="i++";
       };
      };
      MethodCall @[21] {
       name="MethodCall_networkmethod_1";
       desc="perform final operations at end of settling (storing final activations, etc)";
       flags=OFF;
       code_string=;
       result_var=NULL;
       obj=$.programs.gp[2].gp[1][0].args[0]$;
       method=NULL;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig=;
       meth_desc=;
      };
      MethodCall @[22] {
       name="MethodCall_networkComputeTrialStats";
       desc="compute trial-level statistics -- only in minus phase!";
       flags=CAN_REVERT_TO_CODE;
       code_string="network->Compute_TrialStats()";
       result_var=NULL;
       obj=$.programs.gp[2].gp[1][0].args[0]$;
       method=LeabraNetwork::Compute_TrialStats;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void Compute_TrialStats()";
       meth_desc=" compute trial-level statistics (SSE and others defined by specific algorithms) do not call this function anymore -- it is obsolete -- please use Compute_PhaseStats or Compute_MinusStats / Compute_PlusStats for more appropriate stats computation at the right time";
      };
      NetUpdateView @[23] {
       name="NetUpdateView_NetUpdateView";
       desc="update network views, if update_net_view == true";
       flags=CAN_REVERT_TO_CODE;
       code_string="Net Update View";
       network_var=$.programs.gp[2].gp[1][0].args[0]$;
       update_var=.programs.gp[2].gp[1][0].args[2]$$;
      };
      StopStepPoint @[24] {
       name="StopStepPoint_StopStepPoint";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Stop_Step Point";
       cond {
	expr=;
       };
      };
      Comment @[25] {
       name="Comment_RunPlusPhase";
       desc="=== Run Plus Phase ===";
       flags=CAN_REVERT_TO_CODE;
       code_string="// === Run Plus Phase ===";
      };
      ProgramCall @[26] {
       name="ProgramCall_programname_2";
       desc="start the plus phase";
       flags=OFF;
       code_string=;
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       target=NULL;
       targ_ld_init="*PlusPhaseStart*";
      };
      ProgramCall @[27] {
       name="ProgramCall_ApplyInputsTstGo_etworkinputdata_1";
       desc="apply std external input activations from the input_data table to the network";
       flags=OFF;
       code_string=;
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=Network;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="input_data";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="input_data";
	 };
	};
       };
       target=$.programs.gp[3][4]$;
       targ_ld_init="*ApplyInputs_TstGoalDir*";
      };
      MethodCall @[28] {
       name="MethodCall_networkmethod_2";
       desc="initializes various counters at start of settling";
       flags=OFF;
       code_string=;
       result_var=NULL;
       obj=$.programs.gp[2].gp[1][0].args[0]$;
       method=NULL;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig=;
       meth_desc=;
      };
      ProgramCall @[29] {
       name="ProgramCall_Settlenetworknetworkcttimeplus";
       desc="settle for designated plus phase number of cycles";
       flags=OFF;
       code_string=;
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="cycle_max";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network.ct_time.plus";
	 };
	};
       };
       target=$.programs.gp[4][10]$;
       targ_ld_init="*Settle*";
      };
      ProgramCall @[30] {
       name="ProgramCall_Settlenetwork150";
       desc="settle for designated plus phase number of cycles";
       flags=OFF;
       code_string=;
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="cycle_max";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="150";
	 };
	};
       };
       target=$.programs.gp[4][10]$;
       targ_ld_init="*Settle*";
      };
      MemberAssign @[31] {
       name="MemberAssign_networktrialnameTrialName_1";
       desc=;
       flags=OFF|NEW_EL;
       code_string=;
       obj=$.programs.gp[2].gp[1][0].args[0]$;
       path="trial_name";
       expr {
	expr="TrialName";
       };
       update_after=0;
      };
      MethodCall @[32] {
       name="MethodCall_networkmethod_3";
       desc="perform final operations at end of settling (storing final activations, etc)";
       flags=OFF;
       code_string=;
       result_var=NULL;
       obj=$.programs.gp[2].gp[1][0].args[0]$;
       method=NULL;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig=;
       meth_desc=;
      };
      MethodCall @[33] {
       name="MethodCall_networkComputeExtRew";
       desc="get external reward information";
       flags=OFF;
       code_string=;
       result_var=NULL;
       obj=$.programs.gp[2].gp[1][0].args[0]$;
       method=LeabraNetwork::Compute_ExtRew;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void Compute_ExtRew()";
       meth_desc=" compute external reward information: called in plus phase stats";
      };
      NetUpdateView @[34] {
       name="NetUpdateView_NetUpdateView_1";
       desc="update network views, if update_net_view == true";
       flags=OFF;
       code_string=;
       network_var=$.programs.gp[2].gp[1][0].args[0]$;
       update_var=$.programs.gp[2].gp[1][0].args[2]$;
      };
      Comment @[35] {
       name="Comment_resetlayersjustt_nextrandomtrial";
       desc="= reset layers just to make sure for next random trial";
       flags=CAN_REVERT_TO_CODE;
       code_string="// = reset layers just to make sure for next random trial";
      };
      MemberAssign @[36] {
       name="MemberAssign_WordGoalInOutlayertypeLayerINPUT_1";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="WordGoal_InOut.layer_type = Layer::INPUT";
       obj=$.programs.gp[2].gp[1][0].vars[2]$;
       path="layer_type";
       expr {
	expr="Layer::INPUT";
       };
       update_after=0;
      };
      MemberAssign @[37] {
       name="MemberAssign_ActualActionOutp_typeLayerTARGET";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="ActualAction_Output.layer_type = Layer::TARGET";
       obj=$.programs.gp[2].gp[1][0].vars[6]$;
       path="layer_type";
       expr {
	expr="Layer::TARGET";
       };
       update_after=0;
      };
      MemberAssign @[38] {
       name="MemberAssign_ActualStateInput_rtypeLayerINPUT_1";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="ActualState_Input.layer_type = Layer::INPUT";
       obj=$.programs.gp[2].gp[1][0].vars[7]$;
       path="layer_type";
       expr {
	expr="Layer::INPUT";
       };
       update_after=0;
      };
      MethodCall @[39] {
       name="MethodCall_basictraintimeEndTimer";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="basic_train_time->EndTimer()";
       result_var=NULL;
       obj=$.programs.gp[2].gp[1][0].objs_vars[0]$;
       method=TimeUsed::EndTimer;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void EndTimer()";
       meth_desc=" record the current time as the ending time, and compute difference as the time used";
      };
     };
     step_prog=NULL;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=0;
      wiki=;
      url="local";
      full_url="local";
      text_size=1;
      text=;
      html_text=;
     };
    };
   };
  };
  Program_Group @.gp[3] {
   name="EnviroProgs";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   debug_mode=0;
   Program @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[3][0].doc$$: };
    };
    name="ChooseRandomEvent";
    short_nm="ChRndm";
    tags=;
    desc="choose an event at random to present on current trial";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="event_idx";
      var_type=T_Int;
      int_val=19;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="event to present";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     RandomCall @[0] {
      name="RandomCall_eventidxRandomIn_oNinputdatarows";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="event_idx = Random::IntZeroN(input_data.rows, )";
      result_var=.programs.gp[3][0].vars[0]$$;
      object_type=Random;
      method=Random::IntZeroN;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="n";
	required=1;
	def_val=;
	prev_expr="input_data.rows";
	expr {
	 expr="input_data.rows";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="thr_no";
	required=0;
	def_val="-1";
	prev_expr=;
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[1] {
      name="MethodCall_inputdataReadItemeventidx";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="input_data->ReadItem(event_idx)";
      result_var=NULL;
      obj=.programs.gp[3][0].args[0]$$;
      method=DataTable::ReadItem;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="idx";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="event_idx";
	};
       };
      };
      meth_sig="bool ReadItem(int idx)";
      meth_desc=" goes directly (random access) to row idx (- = count back from last row available, otherwise must be in range 0 <= idx < rows) so that it is now available for GetData routines (which use read_idx for their row number), returns true if row exists and was read";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[1] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[3][1].doc$$: };
    };
    name="ChooseSeqEvent";
    short_nm="ChSqvn";
    tags=;
    desc="choose next event in input data in sequence according to current network trial counter -- choses at random if trial > number of rows in table";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="Network to which to apply inputs";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][2]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="event_idx";
      var_type=T_Int;
      int_val=6;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="event to present";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     If @[0] {
      name="If_ifnetworktrialinputdatarows";
      desc="if over count, choose a random new event -- shouldn't happen in general but it can, esp with dmem";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network->trial >= input_data.rows)";
      cond {
       expr="network->trial >= input_data.rows";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       RandomCall @[0] {
	name="RandomCall_eventidxRandomIn_oNinputdatarows";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="event_idx = Random::IntZeroN(input_data.rows, )";
	result_var=.programs.gp[3][1].vars[0]$$;
	object_type=Random;
	method=Random::IntZeroN;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=int;
	  type="int";
	  name="n";
	  required=1;
	  def_val=;
	  prev_expr="input_data.rows";
	  expr {
	   expr="input_data.rows";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=int;
	  type="int";
	  name="thr_no";
	  required=0;
	  def_val="-1";
	  prev_expr=;
	  expr {
	   expr=;
	  };
	 };
	};
       };
       MethodCall @[1] {
	name="MethodCall_inputdataReadItemeventidx";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="input_data->ReadItem(event_idx)";
	result_var=NULL;
	obj=.programs.gp[3][1].args[1]$$;
	method=DataTable::ReadItem;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=int;
	  type="int";
	  name="idx";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="event_idx";
	  };
	 };
	};
	meth_sig="bool ReadItem(int idx)";
	meth_desc=" goes directly (random access) to row idx (- = count back from last row available, otherwise must be in range 0 <= idx < rows) so that it is now available for GetData routines (which use read_idx for their row number), returns true if row exists and was read";
       };
      };
     };
     Else @[1] {
      name="Else_If_ifnetworktrialinputdatarows";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="else";
      cond {
       expr=;
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_inputdataReadItemnetworktrial";
	desc="just read the next trial in input data";
	flags=CAN_REVERT_TO_CODE;
	code_string="input_data->ReadItem(network->trial)";
	result_var=NULL;
	obj=$.programs.gp[3][1].args[1]$;
	method=DataTable::ReadItem;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=int;
	  type="int";
	  name="idx";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network->trial";
	  };
	 };
	};
	meth_sig="bool ReadItem(int idx)";
	meth_desc=" goes directly (random access) to row idx (- = count back from last row available, otherwise must be in range 0 <= idx < rows) so that it is now available for GetData routines (which use read_idx for their row number), returns true if row exists and was read";
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[2] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[3][2].doc$$: };
    };
    name="ApplyInputs";
    short_nm="Inputs";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.data.gp[0][1]$;
      network=$.networks[0]$;
      layer_data {
       name="layer_data";
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	off=0;
	col_name="WordAction_InOut";
	net_target=LAYER;
	layer_name="WordAction_InOut";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="RandomSpec_8": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	off=0;
	col_name="Goal_Input";
	net_target=LAYER;
	layer_name="Goal_Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="RandomSpec_11": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	off=0;
	col_name="WordBefore_InOut";
	net_target=LAYER;
	layer_name="WordBefore_InOut";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="RandomSpec_18": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[3] {
	off=0;
	col_name="WordAfter_InOut";
	net_target=LAYER;
	layer_name="WordAfter_InOut";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="RandomSpec_19": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="layer_writer_0";
      var_type=T_Object;
      object_type=LayerWriter;
      completion_type=;
      object_val=.programs.gp[3][2].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_layerwriter0SetD_nputdatanetwork";
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->SetDataNetwork(input_data, network)";
      result_var=NULL;
      obj=.programs.gp[3][2].objs_vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="db";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* db, Network* net)";
      meth_desc=" set the data table and network pointers -- convenience function for programs ";
     };
     MethodCall @[1] {
      name="MethodCall_layerwriter0AutoConfigtrue";
      desc="configure to fit the network and input data -- this may cause spurious warning messages and problems in some cases so just turn it OFF if necessary";
      flags=OFF|NON_STD|WARNING;
      code_string=;
      result_var=NULL;
      obj=$.programs.gp[3][2].objs_vars[0]$;
      method=LayerWriter::AutoConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="remove_unused";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void AutoConfig(bool remove_unused = true)";
      meth_desc=" do a 'best guess' configuration of items by matching up like-named data Channels and network Layers -- if remove_unused is true, then layer writer elements that existed previously but were not found in input data and network are removed";
     };
     MethodCall @[2] {
      name="MethodCall_layerwriter0CheckConfigfalse";
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[3][2].objs_vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_layerwriter0SetD_nputdatanetwork";
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->SetDataNetwork(input_data, network)";
      result_var=NULL;
      obj=$.programs.gp[3][2].objs_vars[0]$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="db";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* db, Network* net)";
      meth_desc=" set the data table and network pointers -- convenience function for programs ";
     };
     MethodCall @[1] {
      name="MethodCall_layerwriter0ApplyInputData";
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->ApplyInputData()";
      result_var=NULL;
      obj=$.programs.gp[3][2].objs_vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="bool ApplyInputData()";
      meth_desc=" apply data to the layers, using the network's current context settings (TEST,TRAIN,etc) -- returns success";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[3] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[3][3].doc$$: };
    };
    name="ApplyInputs_TrnActRel";
    short_nm="pplTrn";
    tags="Network, InputData, Apply";
    desc="train action-relation version";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.data.gp[0][1]$;
      network=$.networks[0]$;
      layer_data {
       name="layer_data";
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	off=0;
	col_name="WordAction_InOut";
	net_target=LAYER;
	layer_name="WordAction_InOut";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	off=0;
	col_name="Goal_Input";
	net_target=LAYER;
	layer_name="Goal_Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	off=0;
	col_name="WordBefore_InOut";
	net_target=LAYER;
	layer_name="WordBefore_InOut";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=TARG;
	noise {name="RandomSpec_18": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[3] {
	off=0;
	col_name="WordAfter_InOut";
	net_target=LAYER;
	layer_name="WordAfter_InOut";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="RandomSpec_19": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="layer_writer_0";
      var_type=T_Object;
      object_type=LayerWriter;
      completion_type=;
      object_val=.programs.gp[3][3].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_layerwriter0SetD_nputdatanetwork";
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->SetDataNetwork(input_data, network)";
      result_var=NULL;
      obj=.programs.gp[3][3].objs_vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="db";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* db, Network* net)";
      meth_desc=" set the data table and network pointers -- convenience function for programs ";
     };
     MethodCall @[1] {
      name="MethodCall_layerwriter0AutoConfigfalse";
      desc="configure to fit the network and input data -- this may cause spurious warning messages and problems in some cases so just turn it OFF if necessary";
      flags=NON_STD|WARNING|CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->AutoConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[3][3].objs_vars[0]$;
      method=LayerWriter::AutoConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="remove_unused";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="void AutoConfig(bool remove_unused = true)";
      meth_desc=" do a 'best guess' configuration of items by matching up like-named data Channels and network Layers -- if remove_unused is true, then layer writer elements that existed previously but were not found in input data and network are removed";
     };
     MethodCall @[2] {
      name="MethodCall_layerwriter0CheckConfigfalse";
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[3][3].objs_vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_layerwriter0SetD_nputdatanetwork";
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->SetDataNetwork(input_data, network)";
      result_var=NULL;
      obj=$.programs.gp[3][3].objs_vars[0]$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="db";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* db, Network* net)";
      meth_desc=" set the data table and network pointers -- convenience function for programs ";
     };
     MethodCall @[1] {
      name="MethodCall_layerwriter0ApplyInputData";
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->ApplyInputData()";
      result_var=NULL;
      obj=$.programs.gp[3][3].objs_vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="bool ApplyInputData()";
      meth_desc=" apply data to the layers, using the network's current context settings (TEST,TRAIN,etc) -- returns success";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[4] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[3][4].doc$$: };
    };
    name="ApplyInputs_TstGoalDir";
    short_nm="pplTsG";
    tags="Network, InputData, Apply";
    desc="train goal-directed test version";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.data.gp[0][2]$;
      network=$.networks[0]$;
      layer_data {
       name="layer_data";
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	off=0;
	col_name="ActualAction_Output";
	net_target=LAYER;
	layer_name="ActualAction_Output";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=COMP;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	off=0;
	col_name="Goal_Input";
	net_target=LAYER;
	layer_name="Goal_Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	off=0;
	col_name="ActualState_Input";
	net_target=LAYER;
	layer_name="ActualState_Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="RandomSpec_18": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="layer_writer_0";
      var_type=T_Object;
      object_type=LayerWriter;
      completion_type=;
      object_val=.programs.gp[3][4].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][2]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_layerwriter0SetD_nputdatanetwork";
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->SetDataNetwork(input_data, network)";
      result_var=NULL;
      obj=.programs.gp[3][4].objs_vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="db";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* db, Network* net)";
      meth_desc=" set the data table and network pointers -- convenience function for programs ";
     };
     MethodCall @[1] {
      name="MethodCall_layerwriter0AutoConfigfalse";
      desc="configure to fit the network and input data -- this may cause spurious warning messages and problems in some cases so just turn it OFF if necessary";
      flags=OFF|NON_STD|WARNING;
      code_string=;
      result_var=NULL;
      obj=$.programs.gp[3][4].objs_vars[0]$;
      method=LayerWriter::AutoConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="remove_unused";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="void AutoConfig(bool remove_unused = true)";
      meth_desc=" do a 'best guess' configuration of items by matching up like-named data Channels and network Layers -- if remove_unused is true, then layer writer elements that existed previously but were not found in input data and network are removed";
     };
     MethodCall @[2] {
      name="MethodCall_layerwriter0CheckConfigfalse";
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[3][4].objs_vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_layerwriter0SetD_nputdatanetwork";
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->SetDataNetwork(input_data, network)";
      result_var=NULL;
      obj=$.programs.gp[3][4].objs_vars[0]$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="db";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* db, Network* net)";
      meth_desc=" set the data table and network pointers -- convenience function for programs ";
     };
     MethodCall @[1] {
      name="MethodCall_layerwriter0ApplyInputData";
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->ApplyInputData()";
      result_var=NULL;
      obj=$.programs.gp[3][4].objs_vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="bool ApplyInputData()";
      meth_desc=" apply data to the layers, using the network's current context settings (TEST,TRAIN,etc) -- returns success";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program_Group @.gp[0] {
    name="TrnActRel";
    el_typ=Program;
    el_def=0;
    tags=;
    desc=;
    debug_mode=0;
    Program @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[3].gp[0][0].doc$$: };
     };
     name="WriteInputData_TrnActionRelation";
     short_nm="WrtDtT";
     tags=;
     desc=;
     version {
      major=0;
      minor=0;
      step=0;
     };
     author=;
     email=;
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=DataTable;
      el_def=0;
      DataTable @[0] {
       name="TrialTypes";
       desc=;
       data {
	name="data";
	el_typ=String_Data;
	el_def=0;
	String_Data @[0] {
	 name="TypeOfTrial";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [3] "BeforeAction";"ActionAfter";"BeforeAfter";	 };
	};
       };
       data_flags=SAVE_ROWS|AUTO_CALC;
       auto_load=NO_AUTO_LOAD;
       auto_load_file=;
       row_height=1;
       max_col_width=50;
       keygen 4 0=0;
       row_indexes {
	name="row_indexes";
       [3] 0;1;2;       };
       last_sort_spec {
	name="last_sort_spec";
	ops {
	 name="ops";
	 el_typ=DataSortEl;
	 el_def=0;
	};
       };
       row_with_hilite=-1;
      };
      DataTable @[1] {
       name="WordsForBeforeStates";
       desc=;
       data {
	name="data";
	el_typ=String_Data;
	el_def=0;
	String_Data @[0] {
	 name="BeforeState";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [15] "W_B_S0";"W_B_S1";"W_B_S2";"W_B_S3";"W_B_S4";"W_B_S5";"W_B_S6";"W_B_S7";"W_B_S8";"W_B_S9";
"W_B_S10";"W_B_S11";"W_B_S12";"W_B_S13";"W_B_S14";	 };
	};
       };
       data_flags=SAVE_ROWS|AUTO_CALC;
       auto_load=NO_AUTO_LOAD;
       auto_load_file=;
       row_height=1;
       max_col_width=50;
       keygen 4 0=0;
       row_indexes {
	name="row_indexes";
       [15] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;       };
       last_sort_spec {
	name="last_sort_spec";
	ops {
	 name="ops";
	 el_typ=DataSortEl;
	 el_def=0;
	};
       };
       row_with_hilite=-1;
      };
      DataTable @[2] {
       name="WordsForAfterStates";
       desc=;
       data {
	name="data";
	el_typ=String_Data;
	el_def=0;
	String_Data @[0] {
	 name="AfterState";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [15] "W_A_S0";"W_A_S1";"W_A_S2";"W_A_S3";"W_A_S4";"W_A_S5";"W_A_S6";"W_A_S7";"W_A_S8";"W_A_S9";
"W_A_S10";"W_A_S11";"W_A_S12";"W_A_S13";"W_A_S14";	 };
	};
       };
       data_flags=SAVE_ROWS|AUTO_CALC;
       auto_load=NO_AUTO_LOAD;
       auto_load_file=;
       row_height=1;
       max_col_width=50;
       keygen 4 0=0;
       row_indexes {
	name="row_indexes";
       [15] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;       };
       last_sort_spec {
	name="last_sort_spec";
	ops {
	 name="ops";
	 el_typ=DataSortEl;
	 el_def=0;
	};
       };
       row_with_hilite=-1;
      };
      DataTable @[3] {
       name="WordsForActions";
       desc=;
       data {
	name="data";
	el_typ=String_Data;
	el_def=0;
	String_Data @[0] {
	 name="Action";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [15] "W_A0_1";"W_A1_2";"W_A2_3";"W_A3_4";"W_A4_5";"W_A5_6";"W_A6_7";"W_A7_8";"W_A8_9";"W_A9_10";
"W_A10_11";"W_A11_12";"W_A12_13";"W_A13_14";"W_A14_15";	 };
	};
       };
       data_flags=SAVE_ROWS|AUTO_CALC;
       auto_load=NO_AUTO_LOAD;
       auto_load_file=;
       row_height=1;
       max_col_width=50;
       keygen 4 0=0;
       row_indexes {
	name="row_indexes";
       [15] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;       };
       last_sort_spec {
	name="last_sort_spec";
	ops {
	 name="ops";
	 el_typ=DataSortEl;
	 el_def=0;
	};
       };
       row_with_hilite=-1;
      };
      DataTable @[4] {
       name="MASTER_AllBeforeAction";
       desc=;
       data {
	name="data";
	el_typ=String_Data;
	el_def=0;
	String_Data @[0] {
	 name="BeforeInput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_B_S0";"W_B_S0";"W_B_S0";"W_B_S1";"W_B_S1";"W_B_S1";"W_B_S2";"W_B_S2";"W_B_S2";"W_B_S3";
"W_B_S3";"W_B_S3";	 };
	};
	String_Data @[1] {
	 name="ActionInput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_A0_1";"W_A0_2";"W_A0_3";"W_A1_4";"W_A1_5";"W_A1_6";"W_A2_7";"W_A2_8";"W_A2_9";"W_A3_10";
"W_A3_11";"W_A3_12";	 };
	};
	String_Data @[2] {
	 name="AfterOutput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_A_S1";"W_A_S2";"W_A_S3";"W_A_S4";"W_A_S5";"W_A_S6";"W_A_S7";"W_A_S8";"W_A_S9";"W_A_S10";
"W_A_S11";"W_A_S12";	 };
	};
       };
       data_flags=SAVE_ROWS|AUTO_CALC;
       auto_load=NO_AUTO_LOAD;
       auto_load_file=;
       row_height=1;
       max_col_width=50;
       keygen 4 0=0;
       row_indexes {
	name="row_indexes";
       [12] 0;1;2;3;4;5;6;7;8;9;
10;11;       };
       last_sort_spec {
	name="last_sort_spec";
	ops {
	 name="ops";
	 el_typ=DataSortEl;
	 el_def=0;
	};
       };
       row_with_hilite=-1;
      };
      DataTable @[5] {
       name="AllBeforeActionTrials";
       desc=;
       data {
	name="data";
	el_typ=String_Data;
	el_def=0;
	String_Data @[0] {
	 name="BeforeInput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_B_S0";"W_B_S0";"W_B_S0";"W_B_S1";"W_B_S1";"W_B_S1";"W_B_S2";"W_B_S2";"W_B_S2";"W_B_S3";
"W_B_S3";"W_B_S3";	 };
	};
	String_Data @[1] {
	 name="ActionInput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_A0_1";"W_A0_2";"W_A0_3";"W_A1_4";"W_A1_5";"W_A1_6";"W_A2_7";"W_A2_8";"W_A2_9";"W_A3_10";
"W_A3_11";"W_A3_12";	 };
	};
	String_Data @[2] {
	 name="AfterOutput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_A_S1";"W_A_S2";"W_A_S3";"W_A_S4";"W_A_S5";"W_A_S6";"W_A_S7";"W_A_S8";"W_A_S9";"W_A_S10";
"W_A_S11";"W_A_S12";	 };
	};
       };
       data_flags=SAVE_ROWS|AUTO_CALC;
       auto_load=NO_AUTO_LOAD;
       auto_load_file=;
       row_height=1;
       max_col_width=50;
       keygen 4 0=0;
       row_indexes {
	name="row_indexes";
       [12] 0;1;2;3;4;5;6;7;8;9;
10;11;       };
       last_sort_spec {
	name="last_sort_spec";
	ops {
	 name="ops";
	 el_typ=DataSortEl;
	 el_def=0;
	};
       };
       row_with_hilite=-1;
      };
      DataTable @[6] {
       name="AllActionAfterTrials";
       desc=;
       data {
	name="data";
	el_typ=String_Data;
	el_def=0;
	String_Data @[0] {
	 name="BeforeOutput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_B_S0";"W_B_S0";"W_B_S0";"W_B_S1";"W_B_S1";"W_B_S1";"W_B_S2";"W_B_S2";"W_B_S2";"W_B_S3";
"W_B_S3";"W_B_S3";	 };
	};
	String_Data @[1] {
	 name="ActionInput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_A0_1";"W_A0_2";"W_A0_3";"W_A1_4";"W_A1_5";"W_A1_6";"W_A2_7";"W_A2_8";"W_A2_9";"W_A3_10";
"W_A3_11";"W_A3_12";	 };
	};
	String_Data @[2] {
	 name="AfterInput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_A_S1";"W_A_S2";"W_A_S3";"W_A_S4";"W_A_S5";"W_A_S6";"W_A_S7";"W_A_S8";"W_A_S9";"W_A_S10";
"W_A_S11";"W_A_S12";	 };
	};
       };
       data_flags=SAVE_ROWS|AUTO_CALC;
       auto_load=NO_AUTO_LOAD;
       auto_load_file=;
       row_height=1;
       max_col_width=50;
       keygen 4 0=0;
       row_indexes {
	name="row_indexes";
       [12] 0;1;2;3;4;5;6;7;8;9;
10;11;       };
       last_sort_spec {
	name="last_sort_spec";
	ops {
	 name="ops";
	 el_typ=DataSortEl;
	 el_def=0;
	};
       };
       row_with_hilite=-1;
      };
      DataTable @[7] {
       name="AllBeforeAfterTrials";
       desc=;
       data {
	name="data";
	el_typ=String_Data;
	el_def=0;
	String_Data @[0] {
	 name="BeforeInput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_B_S0";"W_B_S0";"W_B_S0";"W_B_S1";"W_B_S1";"W_B_S1";"W_B_S2";"W_B_S2";"W_B_S2";"W_B_S3";
"W_B_S3";"W_B_S3";	 };
	};
	String_Data @[1] {
	 name="ActionOutput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_A0_1";"W_A0_2";"W_A0_3";"W_A1_4";"W_A1_5";"W_A1_6";"W_A2_7";"W_A2_8";"W_A2_9";"W_A3_10";
"W_A3_11";"W_A3_12";	 };
	};
	String_Data @[2] {
	 name="AfterInput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_A_S1";"W_A_S2";"W_A_S3";"W_A_S4";"W_A_S5";"W_A_S6";"W_A_S7";"W_A_S8";"W_A_S9";"W_A_S10";
"W_A_S11";"W_A_S12";	 };
	};
       };
       data_flags=SAVE_ROWS|AUTO_CALC;
       auto_load=NO_AUTO_LOAD;
       auto_load_file=;
       row_height=1;
       max_col_width=50;
       keygen 4 0=0;
       row_indexes {
	name="row_indexes";
       [12] 0;1;2;3;4;5;6;7;8;9;
10;11;       };
       last_sort_spec {
	name="last_sort_spec";
	ops {
	 name="ops";
	 el_typ=DataSortEl;
	 el_def=0;
	};
       };
       row_with_hilite=-1;
      };
     };
     objs_vars {
      name="objs_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="trial_types";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.programs.gp[3].gp[0][0].objs[0]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="words_for_before_states";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.programs.gp[3].gp[0][0].objs[1]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="words_for_after_states";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.programs.gp[3].gp[0][0].objs[2]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="words_for_actions";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.programs.gp[3].gp[0][0].objs[3]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="master_all_before_action";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.programs.gp[3].gp[0][0].objs[4]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="all_before_action_trials";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.programs.gp[3].gp[0][0].objs[5]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[6] {
       name="all_action_after_trials";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.programs.gp[3].gp[0][0].objs[6]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[7] {
       name="all_before_after_trials";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.programs.gp[3].gp[0][0].objs[7]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
      DynEnumType @[0] {
       name="TrialType";
       desc="kinds of action-relation trial types, defined by two input args; output is the third (missing) arg";
       enums {
	name="enums";
	el_typ=DynEnumItem;
	el_def=0;
	DynEnumItem @[0] {
	 name="BeforeAction";
	 value=0;
	 desc="Before state + action given as INPUTs; after state is TARGET";
	};
	DynEnumItem @[1] {
	 name="ActionAfter";
	 value=1;
	 desc=;
	};
	DynEnumItem @[2] {
	 name="BeforeAfter";
	 value=2;
	 desc=;
	};
       };
       bits=0;
      };
      DynEnumType @[1] {
       name="WordBefore_InOut";
       desc=;
       enums {
	name="enums";
	el_typ=DynEnumItem;
	el_def=0;
	DynEnumItem @[0] {
	 name="W_B_S0";
	 value=0;
	 desc=;
	};
	DynEnumItem @[1] {
	 name="W_B_S1";
	 value=1;
	 desc=;
	};
	DynEnumItem @[2] {
	 name="W_B_S2";
	 value=2;
	 desc=;
	};
	DynEnumItem @[3] {
	 name="W_B_S3";
	 value=3;
	 desc=;
	};
	DynEnumItem @[4] {
	 name="W_B_S4";
	 value=4;
	 desc=;
	};
	DynEnumItem @[5] {
	 name="W_B_S5";
	 value=5;
	 desc=;
	};
	DynEnumItem @[6] {
	 name="W_B_S6";
	 value=6;
	 desc=;
	};
	DynEnumItem @[7] {
	 name="W_B_S7";
	 value=7;
	 desc=;
	};
	DynEnumItem @[8] {
	 name="W_B_S8";
	 value=8;
	 desc=;
	};
	DynEnumItem @[9] {
	 name="W_B_S9";
	 value=9;
	 desc=;
	};
	DynEnumItem @[10] {
	 name="W_B_S10";
	 value=10;
	 desc=;
	};
	DynEnumItem @[11] {
	 name="W_B_S11";
	 value=11;
	 desc=;
	};
	DynEnumItem @[12] {
	 name="W_B_S12";
	 value=12;
	 desc=;
	};
	DynEnumItem @[13] {
	 name="W_B_S_NULL1";
	 value=13;
	 desc=;
	};
	DynEnumItem @[14] {
	 name="W_B_S_NULL2";
	 value=14;
	 desc=;
	};
       };
       bits=0;
      };
      DynEnumType @[2] {
       name="WordAfter_InOut";
       desc=;
       enums {
	name="enums";
	el_typ=DynEnumItem;
	el_def=0;
	DynEnumItem @[0] {
	 name="W_A_S0";
	 value=0;
	 desc=;
	};
	DynEnumItem @[1] {
	 name="W_A_S1";
	 value=1;
	 desc=;
	};
	DynEnumItem @[2] {
	 name="W_A_S2";
	 value=2;
	 desc=;
	};
	DynEnumItem @[3] {
	 name="W_A_S3";
	 value=3;
	 desc=;
	};
	DynEnumItem @[4] {
	 name="W_A_S4";
	 value=4;
	 desc=;
	};
	DynEnumItem @[5] {
	 name="W_A_S5";
	 value=5;
	 desc=;
	};
	DynEnumItem @[6] {
	 name="W_A_S6";
	 value=6;
	 desc=;
	};
	DynEnumItem @[7] {
	 name="W_A_S7";
	 value=7;
	 desc=;
	};
	DynEnumItem @[8] {
	 name="W_A_S8";
	 value=8;
	 desc=;
	};
	DynEnumItem @[9] {
	 name="W_A_S9";
	 value=9;
	 desc=;
	};
	DynEnumItem @[10] {
	 name="W_A_S10";
	 value=10;
	 desc=;
	};
	DynEnumItem @[11] {
	 name="W_A_S11";
	 value=11;
	 desc=;
	};
	DynEnumItem @[12] {
	 name="W_A_S12";
	 value=12;
	 desc=;
	};
	DynEnumItem @[13] {
	 name="W_A_S_NULL1";
	 value=13;
	 desc=;
	};
	DynEnumItem @[14] {
	 name="W_A_S_NULL2";
	 value=14;
	 desc=;
	};
       };
       bits=0;
      };
      DynEnumType @[3] {
       name="WordAction_InOut";
       desc="words for actions to go from one specific state to another";
       enums {
	name="enums";
	el_typ=DynEnumItem;
	el_def=0;
	DynEnumItem @[0] {
	 name="W_A0_1";
	 value=0;
	 desc="word for action to go from S0 to S1; used as input";
	};
	DynEnumItem @[1] {
	 name="W_A0_2";
	 value=1;
	 desc=;
	};
	DynEnumItem @[2] {
	 name="W_A0_3";
	 value=2;
	 desc=;
	};
	DynEnumItem @[3] {
	 name="W_A1_4";
	 value=3;
	 desc=;
	};
	DynEnumItem @[4] {
	 name="W_A1_5";
	 value=4;
	 desc=;
	};
	DynEnumItem @[5] {
	 name="W_A1_6";
	 value=5;
	 desc=;
	};
	DynEnumItem @[6] {
	 name="W_A2_7";
	 value=6;
	 desc=;
	};
	DynEnumItem @[7] {
	 name="W_A2_8";
	 value=7;
	 desc=;
	};
	DynEnumItem @[8] {
	 name="W_A2_9";
	 value=8;
	 desc=;
	};
	DynEnumItem @[9] {
	 name="W_A3_10";
	 value=9;
	 desc=;
	};
	DynEnumItem @[10] {
	 name="W_A3_11";
	 value=10;
	 desc=;
	};
	DynEnumItem @[11] {
	 name="W_A3_12";
	 value=11;
	 desc=;
	};
	DynEnumItem @[12] {
	 name="W_A_NULL1";
	 value=12;
	 desc=;
	};
	DynEnumItem @[13] {
	 name="W_A_NULL2";
	 value=13;
	 desc=;
	};
	DynEnumItem @[14] {
	 name="W_A_NULL3";
	 value=14;
	 desc=;
	};
       };
       bits=0;
      };
      DynEnumType @[4] {
       name="Nodes_States";
       desc="states of the world as represented in an associative semantic network (anterior temporal lobe?)";
       enums {
	name="enums";
	el_typ=DynEnumItem;
	el_def=0;
	DynEnumItem @[0] {
	 name="S0";
	 value=0;
	 desc=;
	};
	DynEnumItem @[1] {
	 name="S1";
	 value=1;
	 desc=;
	};
	DynEnumItem @[2] {
	 name="S2";
	 value=2;
	 desc=;
	};
	DynEnumItem @[3] {
	 name="S3";
	 value=3;
	 desc=;
	};
	DynEnumItem @[4] {
	 name="S4";
	 value=4;
	 desc=;
	};
	DynEnumItem @[5] {
	 name="S5";
	 value=5;
	 desc=;
	};
	DynEnumItem @[6] {
	 name="S6";
	 value=6;
	 desc=;
	};
	DynEnumItem @[7] {
	 name="S7";
	 value=7;
	 desc=;
	};
	DynEnumItem @[8] {
	 name="S8";
	 value=8;
	 desc=;
	};
	DynEnumItem @[9] {
	 name="S9";
	 value=9;
	 desc=;
	};
	DynEnumItem @[10] {
	 name="S10";
	 value=10;
	 desc=;
	};
	DynEnumItem @[11] {
	 name="S11";
	 value=11;
	 desc=;
	};
	DynEnumItem @[12] {
	 name="S12";
	 value=12;
	 desc=;
	};
	DynEnumItem @[13] {
	 name="S_NULL1";
	 value=13;
	 desc=;
	};
	DynEnumItem @[14] {
	 name="S_NULL2";
	 value=14;
	 desc=;
	};
       };
       bits=0;
      };
      DynEnumType @[5] {
       name="Nodes_Actions";
       desc="actions as represented in an assoc. semant. net. (ant. temp. lobe?)";
       enums {
	name="enums";
	el_typ=DynEnumItem;
	el_def=0;
	DynEnumItem @[0] {
	 name="A0_1";
	 value=0;
	 desc=;
	};
	DynEnumItem @[1] {
	 name="A0_2";
	 value=1;
	 desc=;
	};
	DynEnumItem @[2] {
	 name="A0_3";
	 value=2;
	 desc=;
	};
	DynEnumItem @[3] {
	 name="A1_4";
	 value=3;
	 desc=;
	};
	DynEnumItem @[4] {
	 name="A1_5";
	 value=4;
	 desc=;
	};
	DynEnumItem @[5] {
	 name="A1_6";
	 value=5;
	 desc=;
	};
	DynEnumItem @[6] {
	 name="A2_7";
	 value=6;
	 desc=;
	};
	DynEnumItem @[7] {
	 name="A2_8";
	 value=7;
	 desc=;
	};
	DynEnumItem @[8] {
	 name="A2_9";
	 value=8;
	 desc=;
	};
	DynEnumItem @[9] {
	 name="A3_10";
	 value=9;
	 desc=;
	};
	DynEnumItem @[10] {
	 name="A3_11";
	 value=10;
	 desc=;
	};
	DynEnumItem @[11] {
	 name="A3_12";
	 value=11;
	 desc=;
	};
	DynEnumItem @[12] {
	 name="A_NULL1";
	 value=12;
	 desc=;
	};
	DynEnumItem @[13] {
	 name="A_NULL2";
	 value=13;
	 desc=;
	};
	DynEnumItem @[14] {
	 name="A_NULL3";
	 value=14;
	 desc=;
	};
       };
       bits=0;
      };
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="trial_type";
       var_type=T_DynEnum;
       completion_type=;
       object_scope=NULL;
       dyn_enum_val {
	user_data_=NULL;
	enum_type=.programs.gp[3].gp[0][0].types[0]$$;
	value=2;
       };
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="TypeOfTrial";
       var_type=T_String;
       string_val="BeforeAction";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="data_loop_order";
       var_type=T_HardEnum;
       int_val=0;
       completion_type=;
       object_scope=NULL;
       hard_enum_type=DataLoop::Order;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="data_loop_index";
       var_type=T_Int;
       int_val=12;
       completion_type=;
       object_scope=NULL;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="BeforeState";
       var_type=T_String;
       string_val="W_B_S14";
       completion_type=;
       object_scope=NULL;
       flags=SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="AfterState";
       var_type=T_String;
       string_val="W_A_S14";
       completion_type=;
       object_scope=NULL;
       flags=SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[6] {
       name="Action";
       var_type=T_String;
       string_val="W_A14_15";
       completion_type=;
       object_scope=NULL;
       flags=SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[7] {
       name="before_state";
       var_type=T_DynEnum;
       completion_type=;
       object_scope=NULL;
       dyn_enum_val {
	user_data_=NULL;
	enum_type=.programs.gp[3].gp[0][0].types[1]$$;
	value=3;
       };
       flags=SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[8] {
       name="after_state";
       var_type=T_DynEnum;
       completion_type=;
       object_scope=NULL;
       dyn_enum_val {
	user_data_=NULL;
	enum_type=.programs.gp[3].gp[0][0].types[2]$$;
	value=12;
       };
       flags=SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[9] {
       name="action";
       var_type=T_DynEnum;
       completion_type=;
       object_scope=NULL;
       dyn_enum_val {
	user_data_=NULL;
	enum_type=.programs.gp[3].gp[0][0].types[3]$$;
	value=11;
       };
       flags=SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[10] {
       name="BeforeInput";
       var_type=T_String;
       string_val="W_B_S3";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[11] {
       name="ActionInput";
       var_type=T_String;
       string_val="W_A3_12";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[12] {
       name="AfterOutput";
       var_type=T_String;
       string_val="W_A_S12";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[13] {
       name="AfterInput";
       var_type=T_String;
       string_val="W_A_S12";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[14] {
       name="BeforeOutput";
       var_type=T_String;
       string_val="W_B_S3";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[15] {
       name="ActionOutput";
       var_type=T_String;
       string_val="W_A3_12";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[16] {
       name="ActRelTrn_InputData";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=$.data.gp[0][1]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[17] {
       name="TrialName";
       var_type=T_String;
       string_val="S3+S12->A3_12";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[18] {
       name="TrialTypeInputs";
       var_type=T_String;
       string_val="Before+After";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       name="AssignExpr_TypeOfTrialBeforeAction";
       desc="insignificant initialization";
       flags=CAN_REVERT_TO_CODE;
       code_string="TypeOfTrial = \"BeforeAction\"";
       result_var=.programs.gp[3].gp[0][0].vars[1]$$;
       expr {
	expr="\"BeforeAction\"";
       };
      };
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      LocalVars @[0] {
       name="LocalVars_LocalVars1vars";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="LocalVars (1 vars)";
       local_vars {
	name="local_vars";
	el_typ=ProgVar;
	el_def=0;
	ProgVar @[0] {
	 name="i";
	 var_type=T_Int;
	 int_val=0;
	 completion_type=;
	 object_scope=NULL;
	 flags=LOCAL_VAR|USED|EDIT_VAL;
	 reference=0;
	 desc=;
	 init_from=NULL;
	};
       };
      };
      Comment @[1] {
       name="Comment_buildstatictable_mentoutoncedone";
       desc="= build static tables; can comment out once done ";
       flags=CAN_REVERT_TO_CODE;
       code_string="// = build static tables; can comment out once done ";
      };
      Comment @[2] {
       name="Comment_NOTEonlyonetrans_hstateinitially";
       desc="= NOTE: only one transition for each state initially";
       flags=CAN_REVERT_TO_CODE;
       code_string="// = NOTE: only one transition for each state initially";
      };
      ForLoop @[3] {
       name="ForLoop_fori0i15i";
       desc="NOTE: no longer correct; transitions now hierarchical";
       flags=OFF;
       code_string=;
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	AssignExpr @[0] {
	 name="AssignExpr_BeforeStateWBSstringi";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=.programs.gp[3].gp[0][0].vars[4]$$;
	 expr {
	  expr="\"W_B_S\" + (string)i";
	 };
	};
	AssignExpr @[1] {
	 name="AssignExpr_AfterStateWASstringi";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=.programs.gp[3].gp[0][0].vars[5]$$;
	 expr {
	  expr="\"W_A_S\" + (string)i";
	 };
	};
	AssignExpr @[2] {
	 name="AssignExpr_ActionWAstringistringi1";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=.programs.gp[3].gp[0][0].vars[6]$$;
	 expr {
	  expr="\"W_A\" + (string)i + \"_\" + (string)(i+1)";
	 };
	};
	DataVarProg @[3] {
	 name="DataVarProg_DataTotablewords_atevar2var3var4";
	 desc=;
	 flags=0;
	 code_string=;
	 data_var=.programs.gp[3].gp[0][0].objs_vars[1]$$;
	 row_spec=ROW_NUM;
	 row_var=.programs.gp[3].gp[0][0].prog_code[0].local_vars[0]$$;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[0][0].vars[4]$;
	 var_2=NULL;
	 var_3=NULL;
	 var_4=NULL;
	};
	DataVarProg @[4] {
	 name="DataVarProg_DataTotablewords_atevar2var3var4";
	 desc=;
	 flags=0;
	 code_string=;
	 data_var=.programs.gp[3].gp[0][0].objs_vars[2]$$;
	 row_spec=ROW_NUM;
	 row_var=$.programs.gp[3].gp[0][0].prog_code[0].local_vars[0]$;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[0][0].vars[5]$;
	 var_2=NULL;
	 var_3=NULL;
	 var_4=NULL;
	};
	DataVarProg @[5] {
	 name="DataVarProg_DataTotablewords_ionvar2var3var4";
	 desc=;
	 flags=0;
	 code_string=;
	 data_var=.programs.gp[3].gp[0][0].objs_vars[3]$$;
	 row_spec=ROW_NUM;
	 row_var=$.programs.gp[3].gp[0][0].prog_code[0].local_vars[0]$;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[0][0].vars[6]$;
	 var_2=NULL;
	 var_3=NULL;
	 var_4=NULL;
	};
       };
       init {
	expr="i = 0";
       };
       test {
	expr="i < 15";
       };
       iter {
	expr="i++";
       };
      };
      Comment @[4] {
       name="Comment_buildallthetrials";
       desc="= build all the trials";
       flags=CAN_REVERT_TO_CODE;
       code_string="// = build all the trials";
      };
      DataLoop @[5] {
       name="DataLoop_DataLoopSEQUENTI_ardatalooporder";
       desc="loop over the three general trial types: BeforeAction, ActionAfter, BeforeAfter";
       flags=CAN_REVERT_TO_CODE;
       code_string="Data Loop (SEQUENTIAL):  table=trial_types  index=data_loop_index  order_var=data_loop_order ";
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	DataVarProg @[0] {
	 name="DataVarProg_DataFromtabletri_ialvar2var3var4";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Data From:  table=trial_types  row_spec=cur_row  set=from  all_matches=false  var_1=TypeOfTrial  var_2=?  var_3=?  var_4=? ";
	 data_var=.programs.gp[3].gp[0][0].objs_vars[0]$$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=0;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[0][0].vars[1]$;
	 var_2=NULL;
	 var_3=NULL;
	 var_4=NULL;
	};
	AssignExpr @[1] {
	 name="AssignExpr_trialtypeTypeOfTrial";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="trial_type = TypeOfTrial";
	 result_var=.programs.gp[3].gp[0][0].vars[0]$$;
	 expr {
	  expr="TypeOfTrial";
	 };
	};
	PrintVar @[2] {
	 name="PrintVar_PrintTypeOfTrialtrialtype";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Print  TypeOfTrial trial_type";
	 message=;
	 print_var=$.programs.gp[3].gp[0][0].vars[1]$;
	 print_var2=$.programs.gp[3].gp[0][0].vars[0]$;
	 print_var3=NULL;
	 print_var4=NULL;
	 print_var5=NULL;
	 print_var6=NULL;
	 debug=0;
	};
	Switch @[3] {
	 name="Switch_switchtrialtype";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="switch(trial_type)";
	 switch_var=$.programs.gp[3].gp[0][0].vars[0]$;
	 cases {
	  name="cases";
	  el_typ=CaseBlock;
	  el_def=0;
	  CaseBlock @[0] {
	   name="CaseBlock_caseBeforeAction";
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="case: BeforeAction";
	   prog_code {
	    name="prog_code";
	    el_typ=ProgCode;
	    el_def=0;
	    Comment @[0] {
	     name="Comment_buildallthecombi_tatesandactions";
	     desc="= build all the combinations of before states and actions ";
	     flags=CAN_REVERT_TO_CODE;
	     code_string="// = build all the combinations of before states and actions ";
	    };
	    Comment @[1] {
	     name="Comment_NOTEnolongercorr_nowhierarchical";
	     desc="= NOTE: no longer correct; transitions now hierarchical";
	     flags=CAN_REVERT_TO_CODE;
	     code_string="// = NOTE: no longer correct; transitions now hierarchical";
	    };
	    MethodCall @[2] {
	     name="MethodCall_allbeforeactiontrialsReset";
	     desc=;
	     flags=OFF;
	     code_string=;
	     result_var=NULL;
	     obj=.programs.gp[3].gp[0][0].objs_vars[5]$$;
	     method=DataTable::Reset;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	     };
	     meth_sig="void Reset()";
	     meth_desc=" remove all columns (and data) -- this cannot be undone!";
	    };
	    DataProcCall @[3] {
	     name="DataProcCall_taDataProcConcat_WordsForActions";
	     desc=;
	     flags=OFF;
	     code_string=;
	     result_var=NULL;
	     object_type=taDataProc;
	     method=taDataProc::ConcatCols;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=DataTable_ptr;
	       type="DataTable*";
	       name="dest";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="AllBeforeActionTrials";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=DataTable_ptr;
	       type="DataTable*";
	       name="src_a";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="WordsForBeforeStates";
	       };
	      };
	      ProgArg @[2] {
	       arg_type=DataTable_ptr;
	       type="DataTable*";
	       name="src_b";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="WordsForActions";
	       };
	      };
	     };
	    };
	    MethodCall @[4] {
	     name="MethodCall_allbeforeactiont_tateBeforeInput";
	     desc=;
	     flags=OFF;
	     code_string=;
	     result_var=NULL;
	     obj=$.programs.gp[3].gp[0][0].objs_vars[5]$;
	     method=DataTable::RenameCol;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="cur_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"BeforeState\"";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="new_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"BeforeInput\"";
	       };
	      };
	     };
	     meth_sig="bool RenameCol(taString& cur_nm, taString& new_nm)";
	     meth_desc=" rename column with current name cur_nm to new name new_nm (returns false if ccur_nm not found)";
	    };
	    MethodCall @[5] {
	     name="MethodCall_allbeforeactiont_tionActionInput";
	     desc=;
	     flags=OFF;
	     code_string=;
	     result_var=NULL;
	     obj=$.programs.gp[3].gp[0][0].objs_vars[5]$;
	     method=DataTable::RenameCol;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="cur_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"Action\"";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="new_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"ActionInput\"";
	       };
	      };
	     };
	     meth_sig="bool RenameCol(taString& cur_nm, taString& new_nm)";
	     meth_desc=" rename column with current name cur_nm to new name new_nm (returns false if ccur_nm not found)";
	    };
	    MethodCall @[6] {
	     name="MethodCall_allbeforeactiont_ringAfterOutput";
	     desc=;
	     flags=OFF;
	     code_string=;
	     result_var=NULL;
	     obj=$.programs.gp[3].gp[0][0].objs_vars[5]$;
	     method=DataTable::NewColString;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="col_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"AfterOutput\"";
	       };
	      };
	     };
	     meth_sig="String_Data_ptr NewColString(taString& col_nm)";
	     meth_desc=" create new column of string data";
	    };
	    MethodCall @[7] {
	     name="MethodCall_allbeforeactiont_alsRemoveRows11";
	     desc="last 'before' state has no 'after' state";
	     flags=OFF;
	     code_string=;
	     result_var=NULL;
	     obj=$.programs.gp[3].gp[0][0].objs_vars[5]$;
	     method=DataTable::RemoveRows;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=int;
	       type="int";
	       name="st_row";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="-1";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=int;
	       type="int";
	       name="n_rows";
	       required=0;
	       def_val="1";
	       prev_expr=;
	       expr {
		expr="1";
	       };
	      };
	     };
	     meth_sig="bool RemoveRows(int st_row, int n_rows = 1)";
	     meth_desc=" Remove n rows of data, starting at st_row. st_row = -1 means last row, and n_rows = -1 means remove from starting row to end, n_rows = -2 means remove upto and including the next to last row, etc.";
	    };
	    Comment @[8] {
	     name="Comment_buildtheaftercolumn";
	     desc="= build the 'after' column";
	     flags=CAN_REVERT_TO_CODE;
	     code_string="// = build the 'after' column";
	    };
	    ForLoop @[9] {
	     name="ForLoop_fori0iAllBeforeActionTrialsrowsi";
	     desc=;
	     flags=OFF;
	     code_string=;
	     loop_code {
	      name="loop_code";
	      el_typ=ProgCode;
	      el_def=0;
	      Comment @[0] {
	       name="Comment_notetranslationo_haftercellupone";
	       desc="= note translation of each 'after' cell up one";
	       flags=0;
	       code_string=;
	      };
	      MethodCall @[1] {
	       name="MethodCall_allbeforeactiont_tesAfterStatei1";
	       desc=;
	       flags=0;
	       code_string=;
	       result_var=NULL;
	       obj=$.programs.gp[3].gp[0][0].objs_vars[5]$;
	       method=DataTable::CopyCell;
	       meth_args {
		name="meth_args";
		el_typ=ProgArg;
		el_def=0;
		ProgArg @[0] {
		 arg_type=const_Variant_ref;
		 type="Variant&";
		 name="dest_col";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="\"AfterOutput\"";
		 };
		};
		ProgArg @[1] {
		 arg_type=int;
		 type="int";
		 name="dest_row";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="i";
		 };
		};
		ProgArg @[2] {
		 arg_type=const_DataTable_ref;
		 type="DataTable&";
		 name="src";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="WordsForAfterStates";
		 };
		};
		ProgArg @[3] {
		 arg_type=const_Variant_ref;
		 type="Variant&";
		 name="src_col";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="\"AfterState\"";
		 };
		};
		ProgArg @[4] {
		 arg_type=int;
		 type="int";
		 name="src_row";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="i+1";
		 };
		};
	       };
	       meth_sig="bool CopyCell(Variant& dest_col, int dest_row, DataTable& src, Variant& src_col, int src_row)";
	       meth_desc=" copy one cell (indexed by column, row) from source to this data table in given col,row cell -- is robust to differences in type and matrix sizing (returns false if not successful) -- column can be specified as either integer index or a string that is then used to find the given column name";
	      };
	     };
	     init {
	      expr="i = 0";
	     };
	     test {
	      expr="i < AllBeforeActionTrials.rows";
	     };
	     iter {
	      expr="i++";
	     };
	    };
	   };
	   case_val {
	    expr="BeforeAction";
	   };
	   is_default=0;
	  };
	  CaseBlock @[1] {
	   name="CaseBlock_caseActionAfter";
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="case: ActionAfter";
	   prog_code {
	    name="prog_code";
	    el_typ=ProgCode;
	    el_def=0;
	    Comment @[0] {
	     name="Comment_samebeforeafterd_eforeActioncase";
	     desc="= same before-after data as BeforeAction case";
	     flags=CAN_REVERT_TO_CODE;
	     code_string="// = same before-after data as BeforeAction case";
	    };
	    Comment @[1] {
	     name="Comment_justrenamecolumns";
	     desc="= just rename columns";
	     flags=CAN_REVERT_TO_CODE;
	     code_string="// = just rename columns";
	    };
	    DataProcCall @[2] {
	     name="DataProcCall_taDataProcCopyDa_oreactiontrials";
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="taDataProc::CopyData(all_action_after_trials, all_before_action_trials)";
	     result_var=NULL;
	     object_type=taDataProc;
	     method=taDataProc::CopyData;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=DataTable_ptr;
	       type="DataTable*";
	       name="dest";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="all_action_after_trials";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=DataTable_ptr;
	       type="DataTable*";
	       name="src";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="all_before_action_trials";
	       };
	      };
	     };
	    };
	    MethodCall @[3] {
	     name="MethodCall_allactionaftertr_putBeforeOutput";
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="all_action_after_trials->RenameCol(\"BeforeInput\", \"BeforeOutput\")";
	     result_var=NULL;
	     obj=.programs.gp[3].gp[0][0].objs_vars[6]$$;
	     method=DataTable::RenameCol;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="cur_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"BeforeInput\"";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="new_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"BeforeOutput\"";
	       };
	      };
	     };
	     meth_sig="bool RenameCol(taString& cur_nm, taString& new_nm)";
	     meth_desc=" rename column with current name cur_nm to new name new_nm (returns false if ccur_nm not found)";
	    };
	    MethodCall @[4] {
	     name="MethodCall_allactionaftertr_utputAfterInput";
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="all_action_after_trials->RenameCol(\"AfterOutput\", \"AfterInput\")";
	     result_var=NULL;
	     obj=$.programs.gp[3].gp[0][0].objs_vars[6]$;
	     method=DataTable::RenameCol;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="cur_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"AfterOutput\"";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="new_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"AfterInput\"";
	       };
	      };
	     };
	     meth_sig="bool RenameCol(taString& cur_nm, taString& new_nm)";
	     meth_desc=" rename column with current name cur_nm to new name new_nm (returns false if ccur_nm not found)";
	    };
	   };
	   case_val {
	    expr="ActionAfter";
	   };
	   is_default=0;
	  };
	  CaseBlock @[2] {
	   name="CaseBlock_caseBeforeAfter";
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="case: BeforeAfter";
	   prog_code {
	    name="prog_code";
	    el_typ=ProgCode;
	    el_def=0;
	    Comment @[0] {
	     name="Comment_justrenamecolumnsagain";
	     desc="= just rename columns again";
	     flags=CAN_REVERT_TO_CODE;
	     code_string="// = just rename columns again";
	    };
	    DataProcCall @[1] {
	     name="DataProcCall_taDataProcCopyDa_oreactiontrials";
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="taDataProc::CopyData(all_before_after_trials, all_before_action_trials)";
	     result_var=NULL;
	     object_type=taDataProc;
	     method=taDataProc::CopyData;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=DataTable_ptr;
	       type="DataTable*";
	       name="dest";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="all_before_after_trials";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=DataTable_ptr;
	       type="DataTable*";
	       name="src";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="all_before_action_trials";
	       };
	      };
	     };
	    };
	    MethodCall @[2] {
	     name="MethodCall_allbeforeaftertr_utputAfterInput";
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="all_before_after_trials->RenameCol(\"AfterOutput\", \"AfterInput\")";
	     result_var=NULL;
	     obj=.programs.gp[3].gp[0][0].objs_vars[7]$$;
	     method=DataTable::RenameCol;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="cur_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"AfterOutput\"";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="new_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"AfterInput\"";
	       };
	      };
	     };
	     meth_sig="bool RenameCol(taString& cur_nm, taString& new_nm)";
	     meth_desc=" rename column with current name cur_nm to new name new_nm (returns false if ccur_nm not found)";
	    };
	    MethodCall @[3] {
	     name="MethodCall_allbeforeaftertr_putActionOutput";
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="all_before_after_trials->RenameCol(\"ActionInput\", \"ActionOutput\")";
	     result_var=NULL;
	     obj=$.programs.gp[3].gp[0][0].objs_vars[7]$;
	     method=DataTable::RenameCol;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="cur_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"ActionInput\"";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="new_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"ActionOutput\"";
	       };
	      };
	     };
	     meth_sig="bool RenameCol(taString& cur_nm, taString& new_nm)";
	     meth_desc=" rename column with current name cur_nm to new name new_nm (returns false if ccur_nm not found)";
	    };
	   };
	   case_val {
	    expr="BeforeAfter";
	   };
	   is_default=0;
	  };
	 };
	};
       };
       data_var=$.programs.gp[3].gp[0][0].objs_vars[0]$;
       index_var=.programs.gp[3].gp[0][0].vars[3]$$;
       order_var=.programs.gp[3].gp[0][0].vars[2]$$;
       order=SEQUENTIAL;
      };
      Comment @[6] {
       name="Comment_nowloopthruthe3t_einputdatatable";
       desc="= now loop thru the 3 tables to write the input data table";
       flags=CAN_REVERT_TO_CODE;
       code_string="// = now loop thru the 3 tables to write the input data table";
      };
      MethodCall @[7] {
       name="MethodCall_ActRelTrnInputDataResetData";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="ActRelTrn_InputData->ResetData()";
       result_var=NULL;
       obj=.programs.gp[3].gp[0][0].vars[16]$$;
       method=DataTable::ResetData;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void ResetData()";
       meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
      };
      DataLoop @[8] {
       name="DataLoop_DataLoopSEQUENTI_ardatalooporder_1";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Data Loop (SEQUENTIAL):  table=all_before_action_trials  index=data_loop_index  order_var=data_loop_order ";
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	DataVarProg @[0] {
	 name="DataVarProg_DataFromtableall_AfterOutputvar4";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Data From:  table=all_before_action_trials  row_spec=cur_row  set=from  all_matches=false  var_1=BeforeInput  var_2=ActionInput  var_3=AfterOutput  var_4=? ";
	 data_var=$.programs.gp[3].gp[0][0].objs_vars[5]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=0;
	 all_matches=0;
	 quiet=0;
	 var_1=.programs.gp[3].gp[0][0].vars[10]$$;
	 var_2=.programs.gp[3].gp[0][0].vars[11]$$;
	 var_3=.programs.gp[3].gp[0][0].vars[12]$$;
	 var_4=NULL;
	};
	AssignExpr @[1] {
	 name="AssignExpr_TrialNameBeforeI_erOutputafterWA";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="TrialName = BeforeInput.after(\"W_B_\") + \"+\" + ActionInput.after(\"W_\") + \"->\" + AfterOutput.after(\"W_A_\")";
	 result_var=.programs.gp[3].gp[0][0].vars[17]$$;
	 expr {
	  expr="BeforeInput.after(\"W_B_\") + \"+\" + ActionInput.after(\"W_\") + \"->\" + AfterOutput.after(\"W_A_\")";
	 };
	};
	AssignExpr @[2] {
	 name="AssignExpr_TrialTypeInputsBeforeAction";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="TrialTypeInputs = \"Before+Action\"";
	 result_var=.programs.gp[3].gp[0][0].vars[18]$$;
	 expr {
	  expr="\"Before+Action\"";
	 };
	};
	MethodCall @[3] {
	 name="MethodCall_ActRelTrnInputDataAddBlankRow";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="ActRelTrn_InputData->AddBlankRow()";
	 result_var=NULL;
	 obj=$.programs.gp[3].gp[0][0].vars[16]$;
	 method=DataTable::AddBlankRow;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="int AddBlankRow()";
	 meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	};
	DataVarProg @[4] {
	 name="DataVarProg_DataTotableActRe_eInputsvar3var4";
	 desc="scalar, string data";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Data To:  table=ActRelTrn_InputData  row_spec=cur_row  set=to  all_matches=false  var_1=TrialName  var_2=TrialTypeInputs  var_3=?  var_4=? ";
	 data_var=$.programs.gp[3].gp[0][0].vars[16]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[0][0].vars[17]$;
	 var_2=$.programs.gp[3].gp[0][0].vars[18]$;
	 var_3=NULL;
	 var_4=NULL;
	};
	DataVarProgMatrix @[5] {
	 name="DataVarProgMatrix_DataTotableActRe_ar1var2var3var4";
	 desc="matrix data";
	 flags=OFF;
	 code_string=;
	 data_var=$.programs.gp[3].gp[0][0].vars[16]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=NULL;
	 var_2=NULL;
	 var_3=NULL;
	 var_4=NULL;
	};
	AssignExpr @[6] {
	 name="AssignExpr_beforestateBeforeInput";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="before_state = BeforeInput";
	 result_var=.programs.gp[3].gp[0][0].vars[7]$$;
	 expr {
	  expr="BeforeInput";
	 };
	};
	AssignExpr @[7] {
	 name="AssignExpr_actionActionInput";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="action = ActionInput";
	 result_var=.programs.gp[3].gp[0][0].vars[9]$$;
	 expr {
	  expr="ActionInput";
	 };
	};
	AssignExpr @[8] {
	 name="AssignExpr_afterstateAfterOutput";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="after_state = AfterOutput";
	 result_var=.programs.gp[3].gp[0][0].vars[8]$$;
	 expr {
	  expr="AfterOutput";
	 };
	};
	SetUnitsVar @[9] {
	 name="SetUnitsVar_setunitsvarunit1_afterstateunit4";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="set units var: unit_1=before_state unit_2=action unit_3=after_state unit_4=? ";
	 input_data_var=$.programs.gp[3].gp[0][0].vars[16]$;
	 set_nm=0;
	 offset=NULL;
	 unit_1=$.programs.gp[3].gp[0][0].vars[7]$;
	 unit_2=$.programs.gp[3].gp[0][0].vars[9]$;
	 unit_3=$.programs.gp[3].gp[0][0].vars[8]$;
	 unit_4=NULL;
	};
	MethodCall @[10] {
	 name="MethodCall_ActRelTrnInputDataWriteClose";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="ActRelTrn_InputData->WriteClose()";
	 result_var=NULL;
	 obj=$.programs.gp[3].gp[0][0].vars[16]$;
	 method=DataTable::WriteClose;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="void WriteClose()";
	 meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
	};
       };
       data_var=$.programs.gp[3].gp[0][0].objs_vars[5]$;
       index_var=$.programs.gp[3].gp[0][0].vars[3]$;
       order_var=$.programs.gp[3].gp[0][0].vars[2]$;
       order=SEQUENTIAL;
      };
      DataLoop @[9] {
       name="DataLoop_DataLoopSEQUENTI_ardatalooporder_2";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Data Loop (SEQUENTIAL):  table=all_action_after_trials  index=data_loop_index  order_var=data_loop_order ";
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	DataVarProg @[0] {
	 name="DataVarProg_DataFromtableall_eforeOutputvar4";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Data From:  table=all_action_after_trials  row_spec=cur_row  set=from  all_matches=false  var_1=ActionInput  var_2=AfterInput  var_3=BeforeOutput  var_4=? ";
	 data_var=$.programs.gp[3].gp[0][0].objs_vars[6]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=0;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[0][0].vars[11]$;
	 var_2=.programs.gp[3].gp[0][0].vars[13]$$;
	 var_3=.programs.gp[3].gp[0][0].vars[14]$$;
	 var_4=NULL;
	};
	AssignExpr @[1] {
	 name="AssignExpr_TrialNameActionI_reOutputafterWB";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="TrialName = ActionInput.after(\"W_\") + \"+\" + AfterInput.after(\"W_A_\") + \"->\" + BeforeOutput.after(\"W_B_\")";
	 result_var=$.programs.gp[3].gp[0][0].vars[17]$;
	 expr {
	  expr="ActionInput.after(\"W_\") + \"+\" + AfterInput.after(\"W_A_\") + \"->\" + BeforeOutput.after(\"W_B_\")";
	 };
	};
	AssignExpr @[2] {
	 name="AssignExpr_TrialTypeInputsActionAfter";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="TrialTypeInputs = \"Action+After\"";
	 result_var=$.programs.gp[3].gp[0][0].vars[18]$;
	 expr {
	  expr="\"Action+After\"";
	 };
	};
	MethodCall @[3] {
	 name="MethodCall_ActRelTrnInputDataAddBlankRow";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="ActRelTrn_InputData->AddBlankRow()";
	 result_var=NULL;
	 obj=$.programs.gp[3].gp[0][0].vars[16]$;
	 method=DataTable::AddBlankRow;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="int AddBlankRow()";
	 meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	};
	DataVarProg @[4] {
	 name="DataVarProg_DataTotableActRe_eInputsvar3var4";
	 desc="scalar, string data";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Data To:  table=ActRelTrn_InputData  row_spec=cur_row  set=to  all_matches=false  var_1=TrialName  var_2=TrialTypeInputs  var_3=?  var_4=? ";
	 data_var=$.programs.gp[3].gp[0][0].vars[16]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[0][0].vars[17]$;
	 var_2=$.programs.gp[3].gp[0][0].vars[18]$;
	 var_3=NULL;
	 var_4=NULL;
	};
	DataVarProgMatrix @[5] {
	 name="DataVarProgMatrix_DataTotableActRe_ar1var2var3var4";
	 desc="matrix data";
	 flags=OFF;
	 code_string=;
	 data_var=$.programs.gp[3].gp[0][0].vars[16]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=NULL;
	 var_2=NULL;
	 var_3=NULL;
	 var_4=NULL;
	};
	AssignExpr @[6] {
	 name="AssignExpr_beforestateBeforeOutput";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="before_state = BeforeOutput";
	 result_var=$.programs.gp[3].gp[0][0].vars[7]$;
	 expr {
	  expr="BeforeOutput";
	 };
	};
	AssignExpr @[7] {
	 name="AssignExpr_actionActionInput";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="action = ActionInput";
	 result_var=$.programs.gp[3].gp[0][0].vars[9]$;
	 expr {
	  expr="ActionInput";
	 };
	};
	AssignExpr @[8] {
	 name="AssignExpr_afterstateAfterInput";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="after_state = AfterInput";
	 result_var=$.programs.gp[3].gp[0][0].vars[8]$;
	 expr {
	  expr="AfterInput";
	 };
	};
	SetUnitsVar @[9] {
	 name="SetUnitsVar_setunitsvarunit1_afterstateunit4";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="set units var: unit_1=before_state unit_2=action unit_3=after_state unit_4=? ";
	 input_data_var=$.programs.gp[3].gp[0][0].vars[16]$;
	 set_nm=0;
	 offset=NULL;
	 unit_1=$.programs.gp[3].gp[0][0].vars[7]$;
	 unit_2=$.programs.gp[3].gp[0][0].vars[9]$;
	 unit_3=$.programs.gp[3].gp[0][0].vars[8]$;
	 unit_4=NULL;
	};
	MethodCall @[10] {
	 name="MethodCall_ActRelTrnInputDataWriteClose";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="ActRelTrn_InputData->WriteClose()";
	 result_var=NULL;
	 obj=$.programs.gp[3].gp[0][0].vars[16]$;
	 method=DataTable::WriteClose;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="void WriteClose()";
	 meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
	};
       };
       data_var=$.programs.gp[3].gp[0][0].objs_vars[6]$;
       index_var=$.programs.gp[3].gp[0][0].vars[3]$;
       order_var=$.programs.gp[3].gp[0][0].vars[2]$;
       order=SEQUENTIAL;
      };
      DataLoop @[10] {
       name="DataLoop_DataLoopSEQUENTI_ardatalooporder_3";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Data Loop (SEQUENTIAL):  table=all_before_after_trials  index=data_loop_index  order_var=data_loop_order ";
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	DataVarProg @[0] {
	 name="DataVarProg_DataFromtableall_ctionOutputvar4";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Data From:  table=all_before_after_trials  row_spec=cur_row  set=from  all_matches=false  var_1=BeforeInput  var_2=AfterInput  var_3=ActionOutput  var_4=? ";
	 data_var=$.programs.gp[3].gp[0][0].objs_vars[7]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=0;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[0][0].vars[10]$;
	 var_2=$.programs.gp[3].gp[0][0].vars[13]$;
	 var_3=.programs.gp[3].gp[0][0].vars[15]$$;
	 var_4=NULL;
	};
	AssignExpr @[1] {
	 name="AssignExpr_TrialNameBeforeI_ionOutputafterW";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="TrialName = BeforeInput.after(\"W_B_\") + \"+\" + AfterInput.after(\"W_A_\") + \"->\" + ActionOutput.after(\"W_\")";
	 result_var=$.programs.gp[3].gp[0][0].vars[17]$;
	 expr {
	  expr="BeforeInput.after(\"W_B_\") + \"+\" + AfterInput.after(\"W_A_\") + \"->\" + ActionOutput.after(\"W_\")";
	 };
	};
	AssignExpr @[2] {
	 name="AssignExpr_TrialTypeInputsBeforeAfter";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="TrialTypeInputs = \"Before+After\"";
	 result_var=$.programs.gp[3].gp[0][0].vars[18]$;
	 expr {
	  expr="\"Before+After\"";
	 };
	};
	MethodCall @[3] {
	 name="MethodCall_ActRelTrnInputDataAddBlankRow";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="ActRelTrn_InputData->AddBlankRow()";
	 result_var=NULL;
	 obj=$.programs.gp[3].gp[0][0].vars[16]$;
	 method=DataTable::AddBlankRow;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="int AddBlankRow()";
	 meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	};
	DataVarProg @[4] {
	 name="DataVarProg_DataTotableActRe_eInputsvar3var4";
	 desc="scalar, string data";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Data To:  table=ActRelTrn_InputData  row_spec=cur_row  set=to  all_matches=false  var_1=TrialName  var_2=TrialTypeInputs  var_3=?  var_4=? ";
	 data_var=$.programs.gp[3].gp[0][0].vars[16]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[0][0].vars[17]$;
	 var_2=$.programs.gp[3].gp[0][0].vars[18]$;
	 var_3=NULL;
	 var_4=NULL;
	};
	DataVarProgMatrix @[5] {
	 name="DataVarProgMatrix_DataTotableActRe_ar1var2var3var4";
	 desc="matrix data";
	 flags=OFF;
	 code_string=;
	 data_var=$.programs.gp[3].gp[0][0].vars[16]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=NULL;
	 var_2=NULL;
	 var_3=NULL;
	 var_4=NULL;
	};
	AssignExpr @[6] {
	 name="AssignExpr_beforestateBeforeInput";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="before_state = BeforeInput";
	 result_var=$.programs.gp[3].gp[0][0].vars[7]$;
	 expr {
	  expr="BeforeInput";
	 };
	};
	AssignExpr @[7] {
	 name="AssignExpr_actionActionOutput";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="action = ActionOutput";
	 result_var=$.programs.gp[3].gp[0][0].vars[9]$;
	 expr {
	  expr="ActionOutput";
	 };
	};
	AssignExpr @[8] {
	 name="AssignExpr_afterstateAfterInput";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="after_state = AfterInput";
	 result_var=$.programs.gp[3].gp[0][0].vars[8]$;
	 expr {
	  expr="AfterInput";
	 };
	};
	SetUnitsVar @[9] {
	 name="SetUnitsVar_setunitsvarunit1_afterstateunit4";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="set units var: unit_1=before_state unit_2=action unit_3=after_state unit_4=? ";
	 input_data_var=$.programs.gp[3].gp[0][0].vars[16]$;
	 set_nm=0;
	 offset=NULL;
	 unit_1=$.programs.gp[3].gp[0][0].vars[7]$;
	 unit_2=$.programs.gp[3].gp[0][0].vars[9]$;
	 unit_3=$.programs.gp[3].gp[0][0].vars[8]$;
	 unit_4=NULL;
	};
	MethodCall @[10] {
	 name="MethodCall_ActRelTrnInputDataWriteClose";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="ActRelTrn_InputData->WriteClose()";
	 result_var=NULL;
	 obj=$.programs.gp[3].gp[0][0].vars[16]$;
	 method=DataTable::WriteClose;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="void WriteClose()";
	 meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
	};
       };
       data_var=$.programs.gp[3].gp[0][0].objs_vars[7]$;
       index_var=$.programs.gp[3].gp[0][0].vars[3]$;
       order_var=$.programs.gp[3].gp[0][0].vars[2]$;
       order=SEQUENTIAL;
      };
     };
     step_prog=NULL;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=0;
      wiki=;
      url="local";
      full_url="local";
      text_size=1;
      text=;
      html_text=;
     };
    };
   };
   Program_Group @.gp[1] {
    name="TstGoalDir";
    el_typ=Program;
    el_def=0;
    tags=;
    desc=;
    debug_mode=0;
    Program @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[3].gp[1][0].doc$$: };
     };
     name="WriteInputData_TstGoalDirectedTrials";
     short_nm="WrtDtT";
     tags=;
     desc=;
     version {
      major=0;
      minor=0;
      step=0;
     };
     author=;
     email=;
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=DataTable;
      el_def=0;
      DataTable @[0] {
       name="TrialTypes";
       desc=;
       data {
	name="data";
	el_typ=String_Data;
	el_def=0;
	String_Data @[0] {
	 name="TypeOfTrial";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [3] "BeforeAction";"ActionAfter";"BeforeAfter";	 };
	};
       };
       data_flags=SAVE_ROWS|AUTO_CALC;
       auto_load=NO_AUTO_LOAD;
       auto_load_file=;
       row_height=1;
       max_col_width=50;
       keygen 4 0=0;
       row_indexes {
	name="row_indexes";
       [3] 0;1;2;       };
       last_sort_spec {
	name="last_sort_spec";
	ops {
	 name="ops";
	 el_typ=DataSortEl;
	 el_def=0;
	};
       };
       row_with_hilite=-1;
      };
      DataTable @[1] {
       name="WordsForActualStates";
       desc=;
       data {
	name="data";
	el_typ=String_Data;
	el_def=0;
	String_Data @[0] {
	 name="BeforeState";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [15] "W_B_S0";"W_B_S1";"W_B_S2";"W_B_S3";"W_B_S4";"W_B_S5";"W_B_S6";"W_B_S7";"W_B_S8";"W_B_S9";
"W_B_S10";"W_B_S11";"W_B_S12";"W_B_S13";"W_B_S14";	 };
	};
       };
       data_flags=SAVE_ROWS|AUTO_CALC;
       auto_load=NO_AUTO_LOAD;
       auto_load_file=;
       row_height=1;
       max_col_width=50;
       keygen 4 0=0;
       row_indexes {
	name="row_indexes";
       [15] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;       };
       last_sort_spec {
	name="last_sort_spec";
	ops {
	 name="ops";
	 el_typ=DataSortEl;
	 el_def=0;
	};
       };
       row_with_hilite=-1;
      };
      DataTable @[2] {
       name="WordsForGoalStates";
       desc=;
       data {
	name="data";
	el_typ=String_Data;
	el_def=0;
	String_Data @[0] {
	 name="AfterState";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [11] "W_G_S4";"W_G_S5";"W_G_S6";"W_G_S7";"W_G_S8";"W_G_S9";"W_G_S10";"W_G_S11";"W_G_S12";"W_G_S13";
"W_G_S14";	 };
	};
       };
       data_flags=SAVE_ROWS|AUTO_CALC;
       auto_load=NO_AUTO_LOAD;
       auto_load_file=;
       row_height=1;
       max_col_width=50;
       keygen 4 0=0;
       row_indexes {
	name="row_indexes";
       [11] 0;1;2;3;4;5;6;7;8;9;
10;       };
       last_sort_spec {
	name="last_sort_spec";
	ops {
	 name="ops";
	 el_typ=DataSortEl;
	 el_def=0;
	};
       };
       row_with_hilite=-1;
      };
      DataTable @[3] {
       name="WordsForActions";
       desc=;
       data {
	name="data";
	el_typ=String_Data;
	el_def=0;
	String_Data @[0] {
	 name="Action";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [15] "W_A0_1";"W_A1_2";"W_A2_3";"W_A3_4";"W_A4_5";"W_A5_6";"W_A6_7";"W_A7_8";"W_A8_9";"W_A9_10";
"W_A10_11";"W_A11_12";"W_A12_13";"W_A13_14";"W_A14_15";	 };
	};
       };
       data_flags=SAVE_ROWS|AUTO_CALC;
       auto_load=NO_AUTO_LOAD;
       auto_load_file=;
       row_height=1;
       max_col_width=50;
       keygen 4 0=0;
       row_indexes {
	name="row_indexes";
       [15] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;       };
       last_sort_spec {
	name="last_sort_spec";
	ops {
	 name="ops";
	 el_typ=DataSortEl;
	 el_def=0;
	};
       };
       row_with_hilite=-1;
      };
      DataTable @[4] {
       name="MASTER_AllBeforeAction";
       desc=;
       data {
	name="data";
	el_typ=String_Data;
	el_def=0;
	String_Data @[0] {
	 name="BeforeInput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_B_S0";"W_B_S0";"W_B_S0";"W_B_S1";"W_B_S1";"W_B_S1";"W_B_S2";"W_B_S2";"W_B_S2";"W_B_S3";
"W_B_S3";"W_B_S3";	 };
	};
	String_Data @[1] {
	 name="ActionInput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_A0_1";"W_A0_2";"W_A0_3";"W_A1_4";"W_A1_5";"W_A1_6";"W_A2_7";"W_A2_8";"W_A2_9";"W_A3_10";
"W_A3_11";"W_A3_12";	 };
	};
	String_Data @[2] {
	 name="AfterOutput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_A_S1";"W_A_S2";"W_A_S3";"W_A_S4";"W_A_S5";"W_A_S6";"W_A_S7";"W_A_S8";"W_A_S9";"W_A_S10";
"W_A_S11";"W_A_S12";	 };
	};
       };
       data_flags=SAVE_ROWS|AUTO_CALC;
       auto_load=NO_AUTO_LOAD;
       auto_load_file=;
       row_height=1;
       max_col_width=50;
       keygen 4 0=0;
       row_indexes {
	name="row_indexes";
       [12] 0;1;2;3;4;5;6;7;8;9;
10;11;       };
       last_sort_spec {
	name="last_sort_spec";
	ops {
	 name="ops";
	 el_typ=DataSortEl;
	 el_def=0;
	};
       };
       row_with_hilite=-1;
      };
      DataTable @[5] {
       name="DEADAllBeforeActionTrials";
       desc=;
       data {
	name="data";
	el_typ=String_Data;
	el_def=0;
	String_Data @[0] {
	 name="BeforeInput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_B_S0";"W_B_S0";"W_B_S0";"W_B_S1";"W_B_S1";"W_B_S1";"W_B_S2";"W_B_S2";"W_B_S2";"W_B_S3";
"W_B_S3";"W_B_S3";	 };
	};
	String_Data @[1] {
	 name="ActionInput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_A0_1";"W_A0_2";"W_A0_3";"W_A1_4";"W_A1_5";"W_A1_6";"W_A2_7";"W_A2_8";"W_A2_9";"W_A3_10";
"W_A3_11";"W_A3_12";	 };
	};
	String_Data @[2] {
	 name="AfterOutput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_A_S1";"W_A_S2";"W_A_S3";"W_A_S4";"W_A_S5";"W_A_S6";"W_A_S7";"W_A_S8";"W_A_S9";"W_A_S10";
"W_A_S11";"W_A_S12";	 };
	};
       };
       data_flags=SAVE_ROWS|AUTO_CALC;
       auto_load=NO_AUTO_LOAD;
       auto_load_file=;
       row_height=1;
       max_col_width=50;
       keygen 4 0=0;
       row_indexes {
	name="row_indexes";
       [12] 0;1;2;3;4;5;6;7;8;9;
10;11;       };
       last_sort_spec {
	name="last_sort_spec";
	ops {
	 name="ops";
	 el_typ=DataSortEl;
	 el_def=0;
	};
       };
       row_with_hilite=-1;
      };
      DataTable @[6] {
       name="DEADAllActionAfterTrials";
       desc=;
       data {
	name="data";
	el_typ=String_Data;
	el_def=0;
	String_Data @[0] {
	 name="BeforeOutput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_B_S0";"W_B_S0";"W_B_S0";"W_B_S1";"W_B_S1";"W_B_S1";"W_B_S2";"W_B_S2";"W_B_S2";"W_B_S3";
"W_B_S3";"W_B_S3";	 };
	};
	String_Data @[1] {
	 name="ActionInput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_A0_1";"W_A0_2";"W_A0_3";"W_A1_4";"W_A1_5";"W_A1_6";"W_A2_7";"W_A2_8";"W_A2_9";"W_A3_10";
"W_A3_11";"W_A3_12";	 };
	};
	String_Data @[2] {
	 name="AfterInput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [12] "W_A_S1";"W_A_S2";"W_A_S3";"W_A_S4";"W_A_S5";"W_A_S6";"W_A_S7";"W_A_S8";"W_A_S9";"W_A_S10";
"W_A_S11";"W_A_S12";	 };
	};
       };
       data_flags=SAVE_ROWS|AUTO_CALC;
       auto_load=NO_AUTO_LOAD;
       auto_load_file=;
       row_height=1;
       max_col_width=50;
       keygen 4 0=0;
       row_indexes {
	name="row_indexes";
       [12] 0;1;2;3;4;5;6;7;8;9;
10;11;       };
       last_sort_spec {
	name="last_sort_spec";
	ops {
	 name="ops";
	 el_typ=DataSortEl;
	 el_def=0;
	};
       };
       row_with_hilite=-1;
      };
      DataTable @[7] {
       name="AllCurrentGoalTrials";
       desc=;
       data {
	name="data";
	el_typ=String_Data;
	el_def=0;
	String_Data @[0] {
	 name="CurrentInput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [9] "W_C_S0";"W_C_S0";"W_C_S0";"W_C_S0";"W_C_S0";"W_C_S0";"W_C_S0";"W_C_S0";"W_C_S0";	 };
	};
	String_Data @[1] {
	 name="ActionOutput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [9] "W_A0_1";"W_A0_1";"W_A0_1";"W_A0_2";"W_A0_2";"W_A0_2";"W_A0_3";"W_A0_3";"W_A0_3";	 };
	};
	String_Data @[2] {
	 name="GoalInput";
	 col_flags=SAVE_DATA|AUTO_WIDTH;
	 is_matrix=0;
	 cell_geom{ 1;	 };
	 calc_expr {
	  expr=;
	 };
	 dim_names {
	  name="dim_names";
	 [0] 	 };
	 width=16;
	 matrix_col_width=10;
	 ar {
	  name="ar";
	 [9] "W_G_S4";"W_G_S5";"W_G_S6";"W_G_S7";"W_G_S8";"W_G_S9";"W_G_S10";"W_G_S11";"W_G_S12";	 };
	};
       };
       data_flags=SAVE_ROWS|AUTO_CALC;
       auto_load=NO_AUTO_LOAD;
       auto_load_file=;
       row_height=1;
       max_col_width=50;
       keygen 4 0=0;
       row_indexes {
	name="row_indexes";
       [9] 0;1;2;3;4;5;6;7;8;       };
       last_sort_spec {
	name="last_sort_spec";
	ops {
	 name="ops";
	 el_typ=DataSortEl;
	 el_def=0;
	};
       };
       row_with_hilite=-1;
      };
     };
     objs_vars {
      name="objs_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="trial_types";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.programs.gp[3].gp[1][0].objs[0]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="words_for_actual_states";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.programs.gp[3].gp[1][0].objs[1]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="words_for_goal_states";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.programs.gp[3].gp[1][0].objs[2]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="words_for_actions";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.programs.gp[3].gp[1][0].objs[3]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="master_all_before_action";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.programs.gp[3].gp[1][0].objs[4]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="deadall_before_action_trials";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.programs.gp[3].gp[1][0].objs[5]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[6] {
       name="deadall_action_after_trials";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.programs.gp[3].gp[1][0].objs[6]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[7] {
       name="all_current_goal_trials";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=.programs.gp[3].gp[1][0].objs[7]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
      DynEnumType @[0] {
       name="TrialType";
       desc="kinds of action-relation trial types, defined by two input args; output is the third (missing) arg";
       enums {
	name="enums";
	el_typ=DynEnumItem;
	el_def=0;
	DynEnumItem @[0] {
	 name="BeforeAction";
	 value=0;
	 desc="Before state + action given as INPUTs; after state is TARGET";
	};
	DynEnumItem @[1] {
	 name="ActionAfter";
	 value=1;
	 desc=;
	};
	DynEnumItem @[2] {
	 name="BeforeAfter";
	 value=2;
	 desc=;
	};
       };
       bits=0;
      };
      DynEnumType @[1] {
       name="WordActual_InOut";
       desc="for starters, S0 the only initial state";
       enums {
	name="enums";
	el_typ=DynEnumItem;
	el_def=0;
	DynEnumItem @[0] {
	 name="W_C_S0";
	 value=0;
	 desc=;
	};
       };
       bits=0;
      };
      DynEnumType @[2] {
       name="ActualState_Input";
       desc="for starters, S0 the only initial state";
       enums {
	name="enums";
	el_typ=DynEnumItem;
	el_def=0;
	DynEnumItem @[0] {
	 name="W_C_S0";
	 value=0;
	 desc=;
	};
       };
       bits=0;
      };
      DynEnumType @[3] {
       name="Goal_Input";
       desc="states 0 - 3 can't be goals";
       enums {
	name="enums";
	el_typ=DynEnumItem;
	el_def=0;
	DynEnumItem @[0] {
	 name="W_G_S4";
	 value=4;
	 desc=;
	};
	DynEnumItem @[1] {
	 name="W_G_S5";
	 value=5;
	 desc=;
	};
	DynEnumItem @[2] {
	 name="W_G_S6";
	 value=6;
	 desc=;
	};
	DynEnumItem @[3] {
	 name="W_G_S7";
	 value=7;
	 desc=;
	};
	DynEnumItem @[4] {
	 name="W_G_S8";
	 value=8;
	 desc=;
	};
	DynEnumItem @[5] {
	 name="W_G_S9";
	 value=9;
	 desc=;
	};
	DynEnumItem @[6] {
	 name="W_G_S10";
	 value=10;
	 desc=;
	};
	DynEnumItem @[7] {
	 name="W_G_S11";
	 value=11;
	 desc=;
	};
	DynEnumItem @[8] {
	 name="W_G_S12";
	 value=12;
	 desc=;
	};
       };
       bits=0;
      };
      DynEnumType @[4] {
       name="WordAction_InOut";
       desc="words for actions to go from one specific state to another";
       enums {
	name="enums";
	el_typ=DynEnumItem;
	el_def=0;
	DynEnumItem @[0] {
	 name="W_A0_1";
	 value=0;
	 desc="word for action to go from S0 to S1; used as input";
	};
	DynEnumItem @[1] {
	 name="W_A0_2";
	 value=1;
	 desc=;
	};
	DynEnumItem @[2] {
	 name="W_A0_3";
	 value=2;
	 desc=;
	};
	DynEnumItem @[3] {
	 name="W_A1_4";
	 value=3;
	 desc=;
	};
	DynEnumItem @[4] {
	 name="W_A1_5";
	 value=4;
	 desc=;
	};
	DynEnumItem @[5] {
	 name="W_A1_6";
	 value=5;
	 desc=;
	};
	DynEnumItem @[6] {
	 name="W_A2_7";
	 value=6;
	 desc=;
	};
	DynEnumItem @[7] {
	 name="W_A2_8";
	 value=7;
	 desc=;
	};
	DynEnumItem @[8] {
	 name="W_A2_9";
	 value=8;
	 desc=;
	};
	DynEnumItem @[9] {
	 name="W_A3_10";
	 value=9;
	 desc=;
	};
	DynEnumItem @[10] {
	 name="W_A3_11";
	 value=10;
	 desc=;
	};
	DynEnumItem @[11] {
	 name="W_A3_12";
	 value=11;
	 desc=;
	};
	DynEnumItem @[12] {
	 name="W_A_NULL1";
	 value=12;
	 desc=;
	};
	DynEnumItem @[13] {
	 name="W_A_NULL2";
	 value=13;
	 desc=;
	};
	DynEnumItem @[14] {
	 name="W_A_NULL3";
	 value=14;
	 desc=;
	};
       };
       bits=0;
      };
      DynEnumType @[5] {
       name="ActualAction_Output";
       desc="words for actions to go from one specific state to another";
       enums {
	name="enums";
	el_typ=DynEnumItem;
	el_def=0;
	DynEnumItem @[0] {
	 name="W_A0_1";
	 value=0;
	 desc="word for action to go from S0 to S1; used as input";
	};
	DynEnumItem @[1] {
	 name="W_A0_2";
	 value=1;
	 desc=;
	};
	DynEnumItem @[2] {
	 name="W_A0_3";
	 value=2;
	 desc=;
	};
	DynEnumItem @[3] {
	 name="W_A1_4";
	 value=3;
	 desc=;
	};
	DynEnumItem @[4] {
	 name="W_A1_5";
	 value=4;
	 desc=;
	};
	DynEnumItem @[5] {
	 name="W_A1_6";
	 value=5;
	 desc=;
	};
	DynEnumItem @[6] {
	 name="W_A2_7";
	 value=6;
	 desc=;
	};
	DynEnumItem @[7] {
	 name="W_A2_8";
	 value=7;
	 desc=;
	};
	DynEnumItem @[8] {
	 name="W_A2_9";
	 value=8;
	 desc=;
	};
	DynEnumItem @[9] {
	 name="W_A3_10";
	 value=9;
	 desc=;
	};
	DynEnumItem @[10] {
	 name="W_A3_11";
	 value=10;
	 desc=;
	};
	DynEnumItem @[11] {
	 name="W_A3_12";
	 value=11;
	 desc=;
	};
	DynEnumItem @[12] {
	 name="W_A_NULL1";
	 value=12;
	 desc=;
	};
	DynEnumItem @[13] {
	 name="W_A_NULL2";
	 value=13;
	 desc=;
	};
	DynEnumItem @[14] {
	 name="W_A_NULL3";
	 value=14;
	 desc=;
	};
       };
       bits=0;
      };
      DynEnumType @[6] {
       name="Nodes_States";
       desc="states of the world as represented in an associative semantic network (anterior temporal lobe?)";
       enums {
	name="enums";
	el_typ=DynEnumItem;
	el_def=0;
	DynEnumItem @[0] {
	 name="S0";
	 value=0;
	 desc=;
	};
	DynEnumItem @[1] {
	 name="S1";
	 value=1;
	 desc=;
	};
	DynEnumItem @[2] {
	 name="S2";
	 value=2;
	 desc=;
	};
	DynEnumItem @[3] {
	 name="S3";
	 value=3;
	 desc=;
	};
	DynEnumItem @[4] {
	 name="S4";
	 value=4;
	 desc=;
	};
	DynEnumItem @[5] {
	 name="S5";
	 value=5;
	 desc=;
	};
	DynEnumItem @[6] {
	 name="S6";
	 value=6;
	 desc=;
	};
	DynEnumItem @[7] {
	 name="S7";
	 value=7;
	 desc=;
	};
	DynEnumItem @[8] {
	 name="S8";
	 value=8;
	 desc=;
	};
	DynEnumItem @[9] {
	 name="S9";
	 value=9;
	 desc=;
	};
	DynEnumItem @[10] {
	 name="S10";
	 value=10;
	 desc=;
	};
	DynEnumItem @[11] {
	 name="S11";
	 value=11;
	 desc=;
	};
	DynEnumItem @[12] {
	 name="S12";
	 value=12;
	 desc=;
	};
	DynEnumItem @[13] {
	 name="S_NULL1";
	 value=13;
	 desc=;
	};
	DynEnumItem @[14] {
	 name="S_NULL2";
	 value=14;
	 desc=;
	};
       };
       bits=0;
      };
      DynEnumType @[7] {
       name="Nodes_Actions";
       desc="actions as represented in an assoc. semant. net. (ant. temp. lobe?)";
       enums {
	name="enums";
	el_typ=DynEnumItem;
	el_def=0;
	DynEnumItem @[0] {
	 name="A0_1";
	 value=0;
	 desc=;
	};
	DynEnumItem @[1] {
	 name="A0_2";
	 value=1;
	 desc=;
	};
	DynEnumItem @[2] {
	 name="A0_3";
	 value=2;
	 desc=;
	};
	DynEnumItem @[3] {
	 name="A1_4";
	 value=3;
	 desc=;
	};
	DynEnumItem @[4] {
	 name="A1_5";
	 value=4;
	 desc=;
	};
	DynEnumItem @[5] {
	 name="A1_6";
	 value=5;
	 desc=;
	};
	DynEnumItem @[6] {
	 name="A2_7";
	 value=6;
	 desc=;
	};
	DynEnumItem @[7] {
	 name="A2_8";
	 value=7;
	 desc=;
	};
	DynEnumItem @[8] {
	 name="A2_9";
	 value=8;
	 desc=;
	};
	DynEnumItem @[9] {
	 name="A3_10";
	 value=9;
	 desc=;
	};
	DynEnumItem @[10] {
	 name="A3_11";
	 value=10;
	 desc=;
	};
	DynEnumItem @[11] {
	 name="A3_12";
	 value=11;
	 desc=;
	};
	DynEnumItem @[12] {
	 name="A_NULL1";
	 value=12;
	 desc=;
	};
	DynEnumItem @[13] {
	 name="A_NULL2";
	 value=13;
	 desc=;
	};
	DynEnumItem @[14] {
	 name="A_NULL3";
	 value=14;
	 desc=;
	};
       };
       bits=0;
      };
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="trial_type";
       var_type=T_DynEnum;
       completion_type=;
       object_scope=NULL;
       dyn_enum_val {
	user_data_=NULL;
	enum_type=.programs.gp[3].gp[1][0].types[0]$$;
	value=2;
       };
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="TypeOfTrial";
       var_type=T_String;
       string_val="BeforeAction";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="data_loop_order";
       var_type=T_HardEnum;
       int_val=0;
       completion_type=;
       object_scope=NULL;
       hard_enum_type=DataLoop::Order;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="data_loop_index";
       var_type=T_Int;
       int_val=9;
       completion_type=;
       object_scope=NULL;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="BeforeState";
       var_type=T_String;
       string_val="W_B_S14";
       completion_type=;
       object_scope=NULL;
       flags=SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="AfterState";
       var_type=T_String;
       string_val="W_A_S14";
       completion_type=;
       object_scope=NULL;
       flags=SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[6] {
       name="Action";
       var_type=T_String;
       string_val="W_A14_15";
       completion_type=;
       object_scope=NULL;
       flags=SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[7] {
       name="current_state";
       var_type=T_DynEnum;
       completion_type=;
       object_scope=NULL;
       dyn_enum_val {
	user_data_=NULL;
	enum_type=.programs.gp[3].gp[1][0].types[2]$$;
	value=0;
       };
       flags=SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[8] {
       name="goal_state";
       var_type=T_DynEnum;
       completion_type=;
       object_scope=NULL;
       dyn_enum_val {
	user_data_=NULL;
	enum_type=.programs.gp[3].gp[1][0].types[3]$$;
	value=12;
       };
       flags=SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[9] {
       name="action";
       var_type=T_DynEnum;
       completion_type=;
       object_scope=NULL;
       dyn_enum_val {
	user_data_=NULL;
	enum_type=.programs.gp[3].gp[1][0].types[5]$$;
	value=2;
       };
       flags=SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[10] {
       name="CurrentInput";
       var_type=T_String;
       string_val="W_C_S0";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[11] {
       name="ActionInput";
       var_type=T_String;
       string_val="W_A3_12";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[12] {
       name="AfterOutput";
       var_type=T_String;
       string_val="W_A_S12";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[13] {
       name="GoalInput";
       var_type=T_String;
       string_val="W_G_S12";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[14] {
       name="BeforeOutput";
       var_type=T_String;
       string_val="W_B_S3";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[15] {
       name="ActionOutput";
       var_type=T_String;
       string_val="W_A0_3";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[16] {
       name="InputData_TrnActionRelation";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=$.data.gp[0][1]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[17] {
       name="InputData_TestGoalDirectedTrials";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=$.data.gp[0][2]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[18] {
       name="TrialName";
       var_type=T_String;
       string_val="S0+S12->A0_3";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[19] {
       name="TrialTypeInputGoal";
       var_type=T_String;
       string_val="Current+Goal";
       completion_type=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       name="AssignExpr_TypeOfTrialBeforeAction";
       desc="insignificant initialization";
       flags=CAN_REVERT_TO_CODE;
       code_string="TypeOfTrial = \"BeforeAction\"";
       result_var=.programs.gp[3].gp[1][0].vars[1]$$;
       expr {
	expr="\"BeforeAction\"";
       };
      };
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      LocalVars @[0] {
       name="LocalVars_LocalVars1vars";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="LocalVars (1 vars)";
       local_vars {
	name="local_vars";
	el_typ=ProgVar;
	el_def=0;
	ProgVar @[0] {
	 name="i";
	 var_type=T_Int;
	 int_val=0;
	 completion_type=;
	 object_scope=NULL;
	 flags=LOCAL_VAR|USED|EDIT_VAL;
	 reference=0;
	 desc=;
	 init_from=NULL;
	};
       };
      };
      Comment @[1] {
       name="Comment_buildstatictable_mentoutoncedone";
       desc="= build static tables; can comment out once done ";
       flags=CAN_REVERT_TO_CODE;
       code_string="// = build static tables; can comment out once done ";
      };
      Comment @[2] {
       name="Comment_NOTEonlyonetrans_hstateinitially";
       desc="= NOTE: only one transition for each state initially";
       flags=CAN_REVERT_TO_CODE;
       code_string="// = NOTE: only one transition for each state initially";
      };
      ForLoop @[3] {
       name="ForLoop_fori0i15i";
       desc="NOTE: no longer correct; transitions now hierarchical";
       flags=OFF;
       code_string=;
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	AssignExpr @[0] {
	 name="AssignExpr_BeforeStateWBSstringi";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=.programs.gp[3].gp[1][0].vars[4]$$;
	 expr {
	  expr="\"W_B_S\" + (string)i";
	 };
	};
	AssignExpr @[1] {
	 name="AssignExpr_AfterStateWASstringi";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=.programs.gp[3].gp[1][0].vars[5]$$;
	 expr {
	  expr="\"W_A_S\" + (string)i";
	 };
	};
	AssignExpr @[2] {
	 name="AssignExpr_ActionWAstringistringi1";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=.programs.gp[3].gp[1][0].vars[6]$$;
	 expr {
	  expr="\"W_A\" + (string)i + \"_\" + (string)(i+1)";
	 };
	};
	DataVarProg @[3] {
	 name="DataVarProg_DataTotablewords_atevar2var3var4";
	 desc=;
	 flags=0;
	 code_string=;
	 data_var=.programs.gp[3].gp[1][0].objs_vars[1]$$;
	 row_spec=ROW_NUM;
	 row_var=.programs.gp[3].gp[1][0].prog_code[0].local_vars[0]$$;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[1][0].vars[4]$;
	 var_2=NULL;
	 var_3=NULL;
	 var_4=NULL;
	};
	DataVarProg @[4] {
	 name="DataVarProg_DataTotablewords_atevar2var3var4";
	 desc=;
	 flags=0;
	 code_string=;
	 data_var=.programs.gp[3].gp[1][0].objs_vars[2]$$;
	 row_spec=ROW_NUM;
	 row_var=$.programs.gp[3].gp[1][0].prog_code[0].local_vars[0]$;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[1][0].vars[5]$;
	 var_2=NULL;
	 var_3=NULL;
	 var_4=NULL;
	};
	DataVarProg @[5] {
	 name="DataVarProg_DataTotablewords_ionvar2var3var4";
	 desc=;
	 flags=0;
	 code_string=;
	 data_var=.programs.gp[3].gp[1][0].objs_vars[3]$$;
	 row_spec=ROW_NUM;
	 row_var=$.programs.gp[3].gp[1][0].prog_code[0].local_vars[0]$;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[1][0].vars[6]$;
	 var_2=NULL;
	 var_3=NULL;
	 var_4=NULL;
	};
       };
       init {
	expr="i = 0";
       };
       test {
	expr="i < 15";
       };
       iter {
	expr="i++";
       };
      };
      Comment @[4] {
       name="Comment_buildallthetrials";
       desc="= build all the trials";
       flags=CAN_REVERT_TO_CODE;
       code_string="// = build all the trials";
      };
      DataLoop @[5] {
       name="DataLoop_DataLoopSEQUENTI_ardatalooporder";
       desc="loop over the three general trial types: BeforeAction, ActionAfter, BeforeAfter";
       flags=CAN_REVERT_TO_CODE;
       code_string="Data Loop (SEQUENTIAL):  table=trial_types  index=data_loop_index  order_var=data_loop_order ";
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	DataVarProg @[0] {
	 name="DataVarProg_DataFromtabletri_ialvar2var3var4";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Data From:  table=trial_types  row_spec=cur_row  set=from  all_matches=false  var_1=TypeOfTrial  var_2=?  var_3=?  var_4=? ";
	 data_var=.programs.gp[3].gp[1][0].objs_vars[0]$$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=0;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[1][0].vars[1]$;
	 var_2=NULL;
	 var_3=NULL;
	 var_4=NULL;
	};
	AssignExpr @[1] {
	 name="AssignExpr_trialtypeTypeOfTrial";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="trial_type = TypeOfTrial";
	 result_var=.programs.gp[3].gp[1][0].vars[0]$$;
	 expr {
	  expr="TypeOfTrial";
	 };
	};
	PrintVar @[2] {
	 name="PrintVar_PrintTypeOfTrialtrialtype";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Print  TypeOfTrial trial_type";
	 message=;
	 print_var=$.programs.gp[3].gp[1][0].vars[1]$;
	 print_var2=$.programs.gp[3].gp[1][0].vars[0]$;
	 print_var3=NULL;
	 print_var4=NULL;
	 print_var5=NULL;
	 print_var6=NULL;
	 debug=0;
	};
	Switch @[3] {
	 name="Switch_switchtrialtype";
	 desc=;
	 flags=OFF;
	 code_string=;
	 switch_var=$.programs.gp[3].gp[1][0].vars[0]$;
	 cases {
	  name="cases";
	  el_typ=CaseBlock;
	  el_def=0;
	  CaseBlock @[0] {
	   name="CaseBlock_caseBeforeAction";
	   desc=;
	   flags=0;
	   code_string=;
	   prog_code {
	    name="prog_code";
	    el_typ=ProgCode;
	    el_def=0;
	    Comment @[0] {
	     name="Comment_buildallthecombi_tatesandactions";
	     desc="= build all the combinations of before states and actions ";
	     flags=0;
	     code_string=;
	    };
	    Comment @[1] {
	     name="Comment_NOTEnolongercorr_nowhierarchical";
	     desc="= NOTE: no longer correct; transitions now hierarchical";
	     flags=0;
	     code_string=;
	    };
	    MethodCall @[2] {
	     name="MethodCall_deadallbeforeactiontrialsReset";
	     desc=;
	     flags=OFF;
	     code_string=;
	     result_var=NULL;
	     obj=.programs.gp[3].gp[1][0].objs_vars[5]$$;
	     method=DataTable::Reset;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	     };
	     meth_sig="void Reset()";
	     meth_desc=" remove all columns (and data) -- this cannot be undone!";
	    };
	    DataProcCall @[3] {
	     name="DataProcCall_taDataProcConcat_WordsForActions";
	     desc=;
	     flags=OFF;
	     code_string=;
	     result_var=NULL;
	     object_type=taDataProc;
	     method=taDataProc::ConcatCols;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=DataTable_ptr;
	       type="DataTable*";
	       name="dest";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="AllBeforeActionTrials";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=DataTable_ptr;
	       type="DataTable*";
	       name="src_a";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="WordsForBeforeStates";
	       };
	      };
	      ProgArg @[2] {
	       arg_type=DataTable_ptr;
	       type="DataTable*";
	       name="src_b";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="WordsForActions";
	       };
	      };
	     };
	    };
	    MethodCall @[4] {
	     name="MethodCall_deadallbeforeact_tateBeforeInput";
	     desc=;
	     flags=OFF;
	     code_string=;
	     result_var=NULL;
	     obj=$.programs.gp[3].gp[1][0].objs_vars[5]$;
	     method=DataTable::RenameCol;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="cur_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"BeforeState\"";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="new_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"BeforeInput\"";
	       };
	      };
	     };
	     meth_sig="bool RenameCol(taString& cur_nm, taString& new_nm)";
	     meth_desc=" rename column with current name cur_nm to new name new_nm (returns false if ccur_nm not found)";
	    };
	    MethodCall @[5] {
	     name="MethodCall_deadallbeforeact_tionActionInput";
	     desc=;
	     flags=OFF;
	     code_string=;
	     result_var=NULL;
	     obj=$.programs.gp[3].gp[1][0].objs_vars[5]$;
	     method=DataTable::RenameCol;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="cur_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"Action\"";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="new_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"ActionInput\"";
	       };
	      };
	     };
	     meth_sig="bool RenameCol(taString& cur_nm, taString& new_nm)";
	     meth_desc=" rename column with current name cur_nm to new name new_nm (returns false if ccur_nm not found)";
	    };
	    MethodCall @[6] {
	     name="MethodCall_deadallbeforeact_ringAfterOutput";
	     desc=;
	     flags=OFF;
	     code_string=;
	     result_var=NULL;
	     obj=$.programs.gp[3].gp[1][0].objs_vars[5]$;
	     method=DataTable::NewColString;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="col_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"AfterOutput\"";
	       };
	      };
	     };
	     meth_sig="String_Data_ptr NewColString(taString& col_nm)";
	     meth_desc=" create new column of string data";
	    };
	    MethodCall @[7] {
	     name="MethodCall_deadallbeforeact_alsRemoveRows11";
	     desc="last 'before' state has no 'after' state";
	     flags=OFF;
	     code_string=;
	     result_var=NULL;
	     obj=$.programs.gp[3].gp[1][0].objs_vars[5]$;
	     method=DataTable::RemoveRows;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=int;
	       type="int";
	       name="st_row";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="-1";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=int;
	       type="int";
	       name="n_rows";
	       required=0;
	       def_val="1";
	       prev_expr=;
	       expr {
		expr="1";
	       };
	      };
	     };
	     meth_sig="bool RemoveRows(int st_row, int n_rows = 1)";
	     meth_desc=" Remove n rows of data, starting at st_row. st_row = -1 means last row, and n_rows = -1 means remove from starting row to end, n_rows = -2 means remove upto and including the next to last row, etc.";
	    };
	    Comment @[8] {
	     name="Comment_buildtheaftercolumn";
	     desc="= build the 'after' column";
	     flags=0;
	     code_string=;
	    };
	    ForLoop @[9] {
	     name="ForLoop_fori0iAllBeforeActionTrialsrowsi";
	     desc=;
	     flags=OFF;
	     code_string=;
	     loop_code {
	      name="loop_code";
	      el_typ=ProgCode;
	      el_def=0;
	      Comment @[0] {
	       name="Comment_notetranslationo_haftercellupone";
	       desc="= note translation of each 'after' cell up one";
	       flags=0;
	       code_string=;
	      };
	      MethodCall @[1] {
	       name="MethodCall_deadallbeforeact_tesAfterStatei1";
	       desc=;
	       flags=0;
	       code_string=;
	       result_var=NULL;
	       obj=$.programs.gp[3].gp[1][0].objs_vars[5]$;
	       method=DataTable::CopyCell;
	       meth_args {
		name="meth_args";
		el_typ=ProgArg;
		el_def=0;
		ProgArg @[0] {
		 arg_type=const_Variant_ref;
		 type="Variant&";
		 name="dest_col";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="\"AfterOutput\"";
		 };
		};
		ProgArg @[1] {
		 arg_type=int;
		 type="int";
		 name="dest_row";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="i";
		 };
		};
		ProgArg @[2] {
		 arg_type=const_DataTable_ref;
		 type="DataTable&";
		 name="src";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="WordsForAfterStates";
		 };
		};
		ProgArg @[3] {
		 arg_type=const_Variant_ref;
		 type="Variant&";
		 name="src_col";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="\"AfterState\"";
		 };
		};
		ProgArg @[4] {
		 arg_type=int;
		 type="int";
		 name="src_row";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="i+1";
		 };
		};
	       };
	       meth_sig="bool CopyCell(Variant& dest_col, int dest_row, DataTable& src, Variant& src_col, int src_row)";
	       meth_desc=" copy one cell (indexed by column, row) from source to this data table in given col,row cell -- is robust to differences in type and matrix sizing (returns false if not successful) -- column can be specified as either integer index or a string that is then used to find the given column name";
	      };
	     };
	     init {
	      expr="i = 0";
	     };
	     test {
	      expr="i < AllBeforeActionTrials.rows";
	     };
	     iter {
	      expr="i++";
	     };
	    };
	   };
	   case_val {
	    expr="BeforeAction";
	   };
	   is_default=0;
	  };
	  CaseBlock @[1] {
	   name="CaseBlock_caseActionAfter";
	   desc=;
	   flags=0;
	   code_string=;
	   prog_code {
	    name="prog_code";
	    el_typ=ProgCode;
	    el_def=0;
	    Comment @[0] {
	     name="Comment_samebeforeafterd_eforeActioncase";
	     desc="= same before-after data as BeforeAction case";
	     flags=0;
	     code_string=;
	    };
	    Comment @[1] {
	     name="Comment_justrenamecolumns";
	     desc="= just rename columns";
	     flags=0;
	     code_string=;
	    };
	    DataProcCall @[2] {
	     name="DataProcCall_taDataProcCopyDa_oreActionTrials";
	     desc=;
	     flags=0;
	     code_string=;
	     result_var=NULL;
	     object_type=taDataProc;
	     method=taDataProc::CopyData;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=DataTable_ptr;
	       type="DataTable*";
	       name="dest";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="DEADAllActionAfterTrials";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=DataTable_ptr;
	       type="DataTable*";
	       name="src";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="DEADAllBeforeActionTrials";
	       };
	      };
	     };
	    };
	    MethodCall @[3] {
	     name="MethodCall_deadallactionaft_putBeforeOutput";
	     desc=;
	     flags=0;
	     code_string=;
	     result_var=NULL;
	     obj=.programs.gp[3].gp[1][0].objs_vars[6]$$;
	     method=DataTable::RenameCol;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="cur_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"BeforeInput\"";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="new_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"BeforeOutput\"";
	       };
	      };
	     };
	     meth_sig="bool RenameCol(taString& cur_nm, taString& new_nm)";
	     meth_desc=" rename column with current name cur_nm to new name new_nm (returns false if ccur_nm not found)";
	    };
	    MethodCall @[4] {
	     name="MethodCall_deadallactionaft_utputAfterInput";
	     desc=;
	     flags=0;
	     code_string=;
	     result_var=NULL;
	     obj=$.programs.gp[3].gp[1][0].objs_vars[6]$;
	     method=DataTable::RenameCol;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="cur_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"AfterOutput\"";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="new_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"AfterInput\"";
	       };
	      };
	     };
	     meth_sig="bool RenameCol(taString& cur_nm, taString& new_nm)";
	     meth_desc=" rename column with current name cur_nm to new name new_nm (returns false if ccur_nm not found)";
	    };
	   };
	   case_val {
	    expr="ActionAfter";
	   };
	   is_default=0;
	  };
	  CaseBlock @[2] {
	   name="CaseBlock_caseCurrentGoal";
	   desc=;
	   flags=0;
	   code_string=;
	   prog_code {
	    name="prog_code";
	    el_typ=ProgCode;
	    el_def=0;
	    Comment @[0] {
	     name="Comment_justrenamecolumnsagain";
	     desc="= just rename columns again";
	     flags=0;
	     code_string=;
	    };
	    DataProcCall @[1] {
	     name="DataProcCall_taDataProcCopyDa_oreActionTrials";
	     desc=;
	     flags=0;
	     code_string=;
	     result_var=NULL;
	     object_type=taDataProc;
	     method=taDataProc::CopyData;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=DataTable_ptr;
	       type="DataTable*";
	       name="dest";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="AllCurrentGoalTrials";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=DataTable_ptr;
	       type="DataTable*";
	       name="src";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="DEADAllBeforeActionTrials";
	       };
	      };
	     };
	    };
	    MethodCall @[2] {
	     name="MethodCall_allcurrentgoaltr_utputAfterInput";
	     desc=;
	     flags=0;
	     code_string=;
	     result_var=NULL;
	     obj=.programs.gp[3].gp[1][0].objs_vars[7]$$;
	     method=DataTable::RenameCol;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="cur_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"AfterOutput\"";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="new_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"AfterInput\"";
	       };
	      };
	     };
	     meth_sig="bool RenameCol(taString& cur_nm, taString& new_nm)";
	     meth_desc=" rename column with current name cur_nm to new name new_nm (returns false if ccur_nm not found)";
	    };
	    MethodCall @[3] {
	     name="MethodCall_allcurrentgoaltr_putActionOutput";
	     desc=;
	     flags=0;
	     code_string=;
	     result_var=NULL;
	     obj=$.programs.gp[3].gp[1][0].objs_vars[7]$;
	     method=DataTable::RenameCol;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="cur_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"ActionInput\"";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="new_nm";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"ActionOutput\"";
	       };
	      };
	     };
	     meth_sig="bool RenameCol(taString& cur_nm, taString& new_nm)";
	     meth_desc=" rename column with current name cur_nm to new name new_nm (returns false if ccur_nm not found)";
	    };
	   };
	   case_val {
	    expr="CurrentGoal";
	   };
	   is_default=0;
	  };
	 };
	};
       };
       data_var=$.programs.gp[3].gp[1][0].objs_vars[0]$;
       index_var=.programs.gp[3].gp[1][0].vars[3]$$;
       order_var=.programs.gp[3].gp[1][0].vars[2]$$;
       order=SEQUENTIAL;
      };
      Comment @[6] {
       name="Comment_nowloopthruthe3t_einputdatatable";
       desc="= now loop thru the 3 tables to write the input data table";
       flags=CAN_REVERT_TO_CODE;
       code_string="// = now loop thru the 3 tables to write the input data table";
      };
      MethodCall @[7] {
       name="MethodCall_InputDataTestGoa_TrialsResetData";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="InputData_TestGoalDirectedTrials->ResetData()";
       result_var=NULL;
       obj=.programs.gp[3].gp[1][0].vars[17]$$;
       method=DataTable::ResetData;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void ResetData()";
       meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
      };
      DataLoop @[8] {
       name="DataLoop_DataLoopSEQUENTI_ardatalooporder_1";
       desc=;
       flags=OFF;
       code_string=;
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	DataVarProg @[0] {
	 name="DataVarProg_DataFromtabledea_AfterOutputvar4";
	 desc=;
	 flags=0;
	 code_string=;
	 data_var=$.programs.gp[3].gp[1][0].objs_vars[5]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=0;
	 all_matches=0;
	 quiet=0;
	 var_1=.programs.gp[3].gp[1][0].vars[10]$$;
	 var_2=.programs.gp[3].gp[1][0].vars[11]$$;
	 var_3=.programs.gp[3].gp[1][0].vars[12]$$;
	 var_4=NULL;
	};
	AssignExpr @[1] {
	 name="AssignExpr_TrialNameCurrent_erOutputafterWA";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=.programs.gp[3].gp[1][0].vars[18]$$;
	 expr {
	  expr="CurrentInput.after(\"W_B_\") + \"+\" + ActionInput.after(\"W_\") + \"->\" + AfterOutput.after(\"W_A_\")";
	 };
	};
	AssignExpr @[2] {
	 name="AssignExpr_TrialTypeInputGoalBeforeAction";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=.programs.gp[3].gp[1][0].vars[19]$$;
	 expr {
	  expr="\"Before+Action\"";
	 };
	};
	MethodCall @[3] {
	 name="MethodCall_InputDataTrnActi_tionAddBlankRow";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=NULL;
	 obj=.programs.gp[3].gp[1][0].vars[16]$$;
	 method=DataTable::AddBlankRow;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="int AddBlankRow()";
	 meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	};
	DataVarProg @[4] {
	 name="DataVarProg_DataTotableInput_putGoalvar3var4";
	 desc="scalar, string data";
	 flags=0;
	 code_string=;
	 data_var=$.programs.gp[3].gp[1][0].vars[16]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[1][0].vars[18]$;
	 var_2=$.programs.gp[3].gp[1][0].vars[19]$;
	 var_3=NULL;
	 var_4=NULL;
	};
	DataVarProgMatrix @[5] {
	 name="DataVarProgMatrix_DataTotableInput_ar1var2var3var4";
	 desc="matrix data";
	 flags=OFF;
	 code_string=;
	 data_var=$.programs.gp[3].gp[1][0].vars[16]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=NULL;
	 var_2=NULL;
	 var_3=NULL;
	 var_4=NULL;
	};
	AssignExpr @[6] {
	 name="AssignExpr_currentstateCurrentInput";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=.programs.gp[3].gp[1][0].vars[7]$$;
	 expr {
	  expr="CurrentInput";
	 };
	};
	AssignExpr @[7] {
	 name="AssignExpr_actionActionInput";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=.programs.gp[3].gp[1][0].vars[9]$$;
	 expr {
	  expr="ActionInput";
	 };
	};
	AssignExpr @[8] {
	 name="AssignExpr_goalstateAfterOutput";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=.programs.gp[3].gp[1][0].vars[8]$$;
	 expr {
	  expr="AfterOutput";
	 };
	};
	SetUnitsVar @[9] {
	 name="SetUnitsVar_setunitsvarunit1_3goalstateunit4";
	 desc=;
	 flags=0;
	 code_string=;
	 input_data_var=$.programs.gp[3].gp[1][0].vars[16]$;
	 set_nm=0;
	 offset=NULL;
	 unit_1=$.programs.gp[3].gp[1][0].vars[7]$;
	 unit_2=$.programs.gp[3].gp[1][0].vars[9]$;
	 unit_3=$.programs.gp[3].gp[1][0].vars[8]$;
	 unit_4=NULL;
	};
	MethodCall @[10] {
	 name="MethodCall_InputDataTrnActi_ationWriteClose";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=NULL;
	 obj=$.programs.gp[3].gp[1][0].vars[16]$;
	 method=DataTable::WriteClose;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="void WriteClose()";
	 meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
	};
       };
       data_var=$.programs.gp[3].gp[1][0].objs_vars[5]$;
       index_var=$.programs.gp[3].gp[1][0].vars[3]$;
       order_var=$.programs.gp[3].gp[1][0].vars[2]$;
       order=SEQUENTIAL;
      };
      DataLoop @[9] {
       name="DataLoop_DataLoopSEQUENTI_ardatalooporder_2";
       desc=;
       flags=OFF;
       code_string=;
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	DataVarProg @[0] {
	 name="DataVarProg_DataFromtabledea_eforeOutputvar4";
	 desc=;
	 flags=0;
	 code_string=;
	 data_var=$.programs.gp[3].gp[1][0].objs_vars[6]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=0;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[1][0].vars[11]$;
	 var_2=.programs.gp[3].gp[1][0].vars[13]$$;
	 var_3=.programs.gp[3].gp[1][0].vars[14]$$;
	 var_4=NULL;
	};
	AssignExpr @[1] {
	 name="AssignExpr_TrialNameActionI_reOutputafterWB";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=$.programs.gp[3].gp[1][0].vars[18]$;
	 expr {
	  expr="ActionInput.after(\"W_\") + \"+\" + GoalInput.after(\"W_A_\") + \"->\" + BeforeOutput.after(\"W_B_\")";
	 };
	};
	AssignExpr @[2] {
	 name="AssignExpr_TrialTypeInputGoalActionAfter";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=$.programs.gp[3].gp[1][0].vars[19]$;
	 expr {
	  expr="\"Action+After\"";
	 };
	};
	MethodCall @[3] {
	 name="MethodCall_InputDataTrnActi_tionAddBlankRow";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=NULL;
	 obj=$.programs.gp[3].gp[1][0].vars[16]$;
	 method=DataTable::AddBlankRow;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="int AddBlankRow()";
	 meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	};
	DataVarProg @[4] {
	 name="DataVarProg_DataTotableInput_putGoalvar3var4";
	 desc="scalar, string data";
	 flags=0;
	 code_string=;
	 data_var=$.programs.gp[3].gp[1][0].vars[16]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[1][0].vars[18]$;
	 var_2=$.programs.gp[3].gp[1][0].vars[19]$;
	 var_3=NULL;
	 var_4=NULL;
	};
	DataVarProgMatrix @[5] {
	 name="DataVarProgMatrix_DataTotableInput_ar1var2var3var4";
	 desc="matrix data";
	 flags=OFF;
	 code_string=;
	 data_var=$.programs.gp[3].gp[1][0].vars[16]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=NULL;
	 var_2=NULL;
	 var_3=NULL;
	 var_4=NULL;
	};
	AssignExpr @[6] {
	 name="AssignExpr_currentstateBeforeOutput";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=$.programs.gp[3].gp[1][0].vars[7]$;
	 expr {
	  expr="BeforeOutput";
	 };
	};
	AssignExpr @[7] {
	 name="AssignExpr_actionActionInput";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=$.programs.gp[3].gp[1][0].vars[9]$;
	 expr {
	  expr="ActionInput";
	 };
	};
	AssignExpr @[8] {
	 name="AssignExpr_goalstateGoalInput";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=$.programs.gp[3].gp[1][0].vars[8]$;
	 expr {
	  expr="GoalInput";
	 };
	};
	SetUnitsVar @[9] {
	 name="SetUnitsVar_setunitsvarunit1_3goalstateunit4";
	 desc=;
	 flags=0;
	 code_string=;
	 input_data_var=$.programs.gp[3].gp[1][0].vars[16]$;
	 set_nm=0;
	 offset=NULL;
	 unit_1=$.programs.gp[3].gp[1][0].vars[7]$;
	 unit_2=$.programs.gp[3].gp[1][0].vars[9]$;
	 unit_3=$.programs.gp[3].gp[1][0].vars[8]$;
	 unit_4=NULL;
	};
	MethodCall @[10] {
	 name="MethodCall_InputDataTrnActi_ationWriteClose";
	 desc=;
	 flags=0;
	 code_string=;
	 result_var=NULL;
	 obj=$.programs.gp[3].gp[1][0].vars[16]$;
	 method=DataTable::WriteClose;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="void WriteClose()";
	 meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
	};
       };
       data_var=$.programs.gp[3].gp[1][0].objs_vars[6]$;
       index_var=$.programs.gp[3].gp[1][0].vars[3]$;
       order_var=$.programs.gp[3].gp[1][0].vars[2]$;
       order=SEQUENTIAL;
      };
      DataLoop @[10] {
       name="DataLoop_DataLoopSEQUENTI_ardatalooporder_3";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Data Loop (SEQUENTIAL):  table=all_current_goal_trials  index=data_loop_index  order_var=data_loop_order ";
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	DataVarProg @[0] {
	 name="DataVarProg_DataFromtableall_ctionOutputvar4";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Data From:  table=all_current_goal_trials  row_spec=cur_row  set=from  all_matches=false  var_1=CurrentInput  var_2=GoalInput  var_3=ActionOutput  var_4=? ";
	 data_var=$.programs.gp[3].gp[1][0].objs_vars[7]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=0;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[1][0].vars[10]$;
	 var_2=$.programs.gp[3].gp[1][0].vars[13]$;
	 var_3=.programs.gp[3].gp[1][0].vars[15]$$;
	 var_4=NULL;
	};
	AssignExpr @[1] {
	 name="AssignExpr_TrialNameCurrent_ionOutputafterW";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="TrialName = CurrentInput.after(\"W_C_\") + \"+\" + GoalInput.after(\"W_G_\") + \"->\" + ActionOutput.after(\"W_\")";
	 result_var=$.programs.gp[3].gp[1][0].vars[18]$;
	 expr {
	  expr="CurrentInput.after(\"W_C_\") + \"+\" + GoalInput.after(\"W_G_\") + \"->\" + ActionOutput.after(\"W_\")";
	 };
	};
	AssignExpr @[2] {
	 name="AssignExpr_TrialTypeInputGoalCurrentGoal";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="TrialTypeInputGoal = \"Current+Goal\"";
	 result_var=$.programs.gp[3].gp[1][0].vars[19]$;
	 expr {
	  expr="\"Current+Goal\"";
	 };
	};
	MethodCall @[3] {
	 name="MethodCall_InputDataTestGoa_ialsAddBlankRow";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="InputData_TestGoalDirectedTrials->AddBlankRow()";
	 result_var=NULL;
	 obj=$.programs.gp[3].gp[1][0].vars[17]$;
	 method=DataTable::AddBlankRow;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="int AddBlankRow()";
	 meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	};
	DataVarProg @[4] {
	 name="DataVarProg_DataTotableInput_putGoalvar3var4";
	 desc="scalar, string data";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Data To:  table=InputData_TestGoalDirectedTrials  row_spec=cur_row  set=to  all_matches=false  var_1=TrialName  var_2=TrialTypeInputGoal  var_3=?  var_4=? ";
	 data_var=$.programs.gp[3].gp[1][0].vars[17]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=$.programs.gp[3].gp[1][0].vars[18]$;
	 var_2=$.programs.gp[3].gp[1][0].vars[19]$;
	 var_3=NULL;
	 var_4=NULL;
	};
	DataVarProgMatrix @[5] {
	 name="DataVarProgMatrix_DataTotableInput_ar1var2var3var4";
	 desc="matrix data";
	 flags=OFF;
	 code_string=;
	 data_var=$.programs.gp[3].gp[1][0].vars[17]$;
	 row_spec=CUR_ROW;
	 row_var=NULL;
	 set_data=1;
	 all_matches=0;
	 quiet=0;
	 var_1=NULL;
	 var_2=NULL;
	 var_3=NULL;
	 var_4=NULL;
	};
	AssignExpr @[6] {
	 name="AssignExpr_currentstateCurrentInput";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="current_state = CurrentInput";
	 result_var=$.programs.gp[3].gp[1][0].vars[7]$;
	 expr {
	  expr="CurrentInput";
	 };
	};
	AssignExpr @[7] {
	 name="AssignExpr_actionActionOutput";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="action = ActionOutput";
	 result_var=$.programs.gp[3].gp[1][0].vars[9]$;
	 expr {
	  expr="ActionOutput";
	 };
	};
	AssignExpr @[8] {
	 name="AssignExpr_goalstateGoalInput";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="goal_state = GoalInput";
	 result_var=$.programs.gp[3].gp[1][0].vars[8]$;
	 expr {
	  expr="GoalInput";
	 };
	};
	SetUnitsVar @[9] {
	 name="SetUnitsVar_setunitsvarunit1_3goalstateunit4";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="set units var: unit_1=current_state unit_2=action unit_3=goal_state unit_4=? ";
	 input_data_var=$.programs.gp[3].gp[1][0].vars[17]$;
	 set_nm=0;
	 offset=NULL;
	 unit_1=$.programs.gp[3].gp[1][0].vars[7]$;
	 unit_2=$.programs.gp[3].gp[1][0].vars[9]$;
	 unit_3=$.programs.gp[3].gp[1][0].vars[8]$;
	 unit_4=NULL;
	};
	MethodCall @[10] {
	 name="MethodCall_InputDataTestGoa_rialsWriteClose";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="InputData_TestGoalDirectedTrials->WriteClose()";
	 result_var=NULL;
	 obj=$.programs.gp[3].gp[1][0].vars[17]$;
	 method=DataTable::WriteClose;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="void WriteClose()";
	 meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
	};
       };
       data_var=$.programs.gp[3].gp[1][0].objs_vars[7]$;
       index_var=$.programs.gp[3].gp[1][0].vars[3]$;
       order_var=$.programs.gp[3].gp[1][0].vars[2]$;
       order=SEQUENTIAL;
      };
     };
     step_prog=NULL;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=0;
      wiki=;
      url="local";
      full_url="local";
      text_size=1;
      text=;
      html_text=;
     };
    };
   };
   Program_Group @.gp[2] {
    name="StoreRecallState";
    el_typ=Program;
    el_def=0;
    tags=;
    desc=;
    debug_mode=0;
    Program @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[3].gp[2][0].doc$$: };
     };
     name="WriteSingleState";
     short_nm="WrSngS";
     tags=;
     desc=;
     version {
      major=0;
      minor=0;
      step=0;
     };
     author=;
     email=;
     flags=0;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=taNBase;
      el_def=0;
     };
     objs_vars {
      name="objs_vars";
      el_typ=ProgVar;
      el_def=0;
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      LocalVars @[0] {
       name="LocalVars_LocalVars0vars";
       desc=;
       flags=0;
       code_string=;
       local_vars {
	name="local_vars";
	el_typ=ProgVar;
	el_def=0;
       };
      };
     };
     step_prog=NULL;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=0;
      wiki=;
      url="local";
      full_url="local";
      text_size=1;
      text=;
      html_text=;
     };
    };
   };
   Program_Group @.gp[3] {
    name="ActualStatePresentation";
    el_typ=Program;
    el_def=0;
    tags=;
    desc=;
    debug_mode=0;
   };
  };
  Program_Group @.gp[4] {
   name="UtilProgs";
   el_typ=Program;
   el_def=0;
   tags="basic utility programs for doing basic operations shared across multiple programs";
   desc=;
   debug_mode=0;
   Program @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][0].doc$$: };
    };
    name="StdGlobalsInit";
    short_nm="GlobInit";
    tags=;
    desc="initialize standard global params, which live here too -- set other programs to init_from these guys";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="config_id";
      var_type=T_String;
      string_val="goal_dir_test";
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="configuration to use -- lookup in Config table";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="Config";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[3][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trials_per_epoch";
      var_type=T_Int;
      int_val=10;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trials_per_epoch_orig";
      var_type=T_Int;
      int_val=10;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="original specification from Config";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="train_epochs";
      var_type=T_Int;
      int_val=10;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[4] {
      name="save_final_wts";
      var_type=T_Int;
      int_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[5] {
      name="save_wts_interval";
      var_type=T_Int;
      int_val=200;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[6] {
      name="test_interval";
      var_type=T_Int;
      int_val=1000;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[7] {
      name="log_trials";
      var_type=T_Int;
      int_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[8] {
      name="load_weights";
      var_type=T_Bool;
      bool_val=1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[9] {
      name="weights_file";
      var_type=T_String;
      string_val="wts/Telos1_act_rel_trnd.wts";
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[10] {
      name="load_st_epc";
      var_type=T_Int;
      int_val=1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[11] {
      name="lrs_step_epochs";
      var_type=T_Int;
      int_val=50;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     Comment @[0] {
      name="Comment_GrabGlobalParams_currentconfigid";
      desc="== Grab Global Params from Config Table for current config_id ==";
      flags=CAN_REVERT_TO_CODE;
      code_string="// == Grab Global Params from Config Table for current config_id ==";
     };
     DataVarProg @[1] {
      name="DataVarProg_DataFromtableCon_savewtsinterval";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Data From:  table=Config  row_spec=row_val  row_var=config_id  set=from  all_matches=false  var_1=train_epochs  var_2=trials_per_epoch  var_3=save_final_wts  var_4=save_wts_interval ";
      data_var=.programs.gp[4][0].vars[0]$$;
      row_spec=ROW_VAL;
      row_var=.programs.gp[4][0].args[1]$$;
      set_data=0;
      all_matches=0;
      quiet=0;
      var_1=.programs.gp[4][0].vars[3]$$;
      var_2=.programs.gp[4][0].vars[1]$$;
      var_3=.programs.gp[4][0].vars[4]$$;
      var_4=.programs.gp[4][0].vars[5]$$;
     };
     DataVarProg @[2] {
      name="DataVarProg_DataFromtableCon_loadweightsvar4";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Data From:  table=Config  row_spec=row_val  row_var=config_id  set=from  all_matches=false  var_1=test_interval  var_2=log_trials  var_3=load_weights  var_4=? ";
      data_var=$.programs.gp[4][0].vars[0]$;
      row_spec=ROW_VAL;
      row_var=$.programs.gp[4][0].args[1]$;
      set_data=0;
      all_matches=0;
      quiet=0;
      var_1=.programs.gp[4][0].vars[6]$$;
      var_2=.programs.gp[4][0].vars[7]$$;
      var_3=.programs.gp[4][0].vars[8]$$;
      var_4=NULL;
     };
     DataVarProg @[3] {
      name="DataVarProg_DataFromtableCon_r4lrsstepepochs";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Data From:  table=Config  row_spec=row_val  row_var=config_id  set=from  all_matches=false  var_1=weights_file  var_2=?  var_3=load_st_epc  var_4=lrs_step_epochs ";
      data_var=$.programs.gp[4][0].vars[0]$;
      row_spec=ROW_VAL;
      row_var=$.programs.gp[4][0].args[1]$;
      set_data=0;
      all_matches=0;
      quiet=0;
      var_1=.programs.gp[4][0].vars[9]$$;
      var_2=NULL;
      var_3=.programs.gp[4][0].vars[10]$$;
      var_4=.programs.gp[4][0].vars[11]$$;
     };
     AssignExpr @[4] {
      name="AssignExpr_trialsperepochorigtrialsperepoch";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="trials_per_epoch_orig = trials_per_epoch";
      result_var=.programs.gp[4][0].vars[2]$$;
      expr {
       expr="trials_per_epoch";
      };
     };
     If @[5] {
      name="If_iftaMiscdmemnprocs1";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (taMisc::dmem_nprocs > 1)";
      cond {
       expr="taMisc::dmem_nprocs > 1";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       AssignExpr @[0] {
	name="AssignExpr_trialsperepochtr_aMiscdmemnprocs";
	desc="dmem means that each guy does less -- uses randomization to get good mix across processors";
	flags=CAN_REVERT_TO_CODE;
	code_string="trials_per_epoch = trials_per_epoch / taMisc::dmem_nprocs";
	result_var=$.programs.gp[4][0].vars[1]$;
	expr {
	 expr="trials_per_epoch / taMisc::dmem_nprocs";
	};
       };
       If @[1] {
	name="If_iftrialsperepoch_alsperepochorig";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (trials_per_epoch * taMisc::dmem_nprocs < trials_per_epoch_orig)";
	cond {
	 expr="trials_per_epoch * taMisc::dmem_nprocs < trials_per_epoch_orig";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 VarIncr @[0] {
	  name="VarIncr_trialsperepoch1";
	  desc="round up..";
	  flags=CAN_REVERT_TO_CODE;
	  code_string="trials_per_epoch += 1";
	  var=$.programs.gp[4][0].vars[1]$;
	  expr {
	   expr="1";
	  };
	 };
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[1] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][1].doc$$: };
    };
    name="BatchRndSeed";
    short_nm="BatchSeed";
    tags=;
    desc="select random seed based on network batch number";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
     RndSeed_List @[0] {
      name="rnd_seeds";
      seeds {
       name="seeds";
       el_typ=RndSeed;
       el_def=0;
       RndSeed @[0] {
	name="RndSeed_1";
	rnd_seed=4170774314;
       };
       RndSeed @[1] {
	name="RndSeed_2";
	rnd_seed=4170774315;
       };
       RndSeed @[2] {
	name="RndSeed_3";
	rnd_seed=4170774316;
       };
       RndSeed @[3] {
	name="RndSeed_4";
	rnd_seed=4170774317;
       };
       RndSeed @[4] {
	name="RndSeed_5";
	rnd_seed=4170774318;
       };
       RndSeed @[5] {
	name="RndSeed_6";
	rnd_seed=4170774319;
       };
       RndSeed @[6] {
	name="RndSeed_7";
	rnd_seed=4170774320;
       };
       RndSeed @[7] {
	name="RndSeed_8";
	rnd_seed=4170774321;
       };
       RndSeed @[8] {
	name="RndSeed_9";
	rnd_seed=4170774322;
       };
       RndSeed @[9] {
	name="RndSeed_10";
	rnd_seed=4170774323;
       };
       RndSeed @[10] {
	name="RndSeed_11";
	rnd_seed=4170774324;
       };
       RndSeed @[11] {
	name="RndSeed_12";
	rnd_seed=4170774325;
       };
       RndSeed @[12] {
	name="RndSeed_13";
	rnd_seed=4170774326;
       };
       RndSeed @[13] {
	name="RndSeed_14";
	rnd_seed=4170774327;
       };
       RndSeed @[14] {
	name="RndSeed_15";
	rnd_seed=4170774328;
       };
       RndSeed @[15] {
	name="RndSeed_16";
	rnd_seed=4170774329;
       };
       RndSeed @[16] {
	name="RndSeed_17";
	rnd_seed=4170774330;
       };
       RndSeed @[17] {
	name="RndSeed_18";
	rnd_seed=4170774331;
       };
       RndSeed @[18] {
	name="RndSeed_19";
	rnd_seed=4170774332;
       };
       RndSeed @[19] {
	name="RndSeed_20";
	rnd_seed=4170774333;
       };
       RndSeed @[20] {
	name="RndSeed_21";
	rnd_seed=4170774334;
       };
       RndSeed @[21] {
	name="RndSeed_22";
	rnd_seed=4170774335;
       };
       RndSeed @[22] {
	name="RndSeed_23";
	rnd_seed=4170774336;
       };
       RndSeed @[23] {
	name="RndSeed_24";
	rnd_seed=4170774337;
       };
       RndSeed @[24] {
	name="RndSeed_25";
	rnd_seed=4170774338;
       };
      };
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="rnd_seeds";
      var_type=T_Object;
      object_type=RndSeed_List;
      completion_type=;
      object_val=.programs.gp[4][1].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="required for the batch counter";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_rndseedsUseSeedn_dseedsseedssize";
      desc="restore previous random seed (all runs produce same results); change to NewSeed to have new random numbers each time";
      flags=CAN_REVERT_TO_CODE;
      code_string="rnd_seeds->UseSeed(network.batch % rnd_seeds.seeds.size)";
      result_var=NULL;
      obj=.programs.gp[4][1].objs_vars[0]$$;
      method=RndSeed_List::UseSeed;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="idx";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network.batch % rnd_seeds.seeds.size";
	};
       };
      };
      meth_sig="void UseSeed(int idx)";
      meth_desc=" use seed at given index in the list (does OldSeed on it); wraps around (modulus) if idx is > list size (issues warning)";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[2] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][2].doc$$: };
    };
    name="ConfigNetwork";
    short_nm="CfgNet";
    tags=;
    desc="configure the network -- basically selectively lesion different parts that are not needed for a given task";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=String_Matrix;
     el_def=0;
     String_Matrix @[0] {
      name="les_lay_mat";
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="les_lay_mat";
      var_type=T_Object;
      object_type=String_Matrix;
      completion_type=;
      object_val=.programs.gp[4][2].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="required for the batch counter";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="lesion_layers";
      var_type=T_String;
      string_val="WordInOut";
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="a space delimited list of layer group names to lesion";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="i";
      var_type=T_Int;
      int_val=1;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="laygp_nm";
      var_type=T_String;
      string_val="WordInOut";
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="laygp";
      var_type=T_Object;
      object_type=Layer_Group;
      completion_type=;
      object_val=.networks[0].layers.gp[1]$$;
      object_scope=NULL;
      objs_ptr=0;
      flags=SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     Comment @[0] {
      name="Comment_firstunlesioneverything";
      desc="== first unlesion everything ==";
      flags=CAN_REVERT_TO_CODE;
      code_string="// == first unlesion everything ==";
     };
     ForLoop @[1] {
      name="ForLoop_fori0inetworklayersgpsizei";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="for (i = 0; i < network.layers.gp.size; i++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       MemberMethodCall @[0] {
	name="MemberMethodCall_laygpnetworklayersgpSafeEli";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp = network.layers.gp.SafeEl(i)";
	obj=.programs.gp[4][2].args[0]$$;
	path="layers.gp";
	result_var=.programs.gp[4][2].vars[2]$$;
	method=taGroup_Layer_::SafeEl;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=int;
	  type="int";
	  name="idx";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="i";
	  };
	 };
	};
	meth_sig="Layer_ptr SafeEl(int idx)";
	meth_desc=" get element at index";
       };
       MethodCall @[1] {
	name="MethodCall_laygpUnLesionLayers";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp->UnLesionLayers()";
	result_var=NULL;
	obj=$.programs.gp[4][2].vars[2]$;
	method=Layer_Group::UnLesionLayers;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void UnLesionLayers()";
	meth_desc=" un-set the lesion flag on all the layers within this group -- restores them to engage in normal processing";
       };
       MethodCall @[2] {
	name="MethodCall_laygpDeIconifyLayers";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp->DeIconifyLayers()";
	result_var=NULL;
	obj=$.programs.gp[4][2].vars[2]$;
	method=Layer_Group::DeIconifyLayers;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void DeIconifyLayers()";
	meth_desc=" un-set the lesion flag on all the layers within this group";
       };
      };
      init {
       expr="i = 0";
      };
      test {
       expr="i < network.layers.gp.size";
      };
      iter {
       expr="i++";
      };
     };
     Comment @[2] {
      name="Comment_thenlesionnamedones";
      desc="== then lesion named ones ==";
      flags=CAN_REVERT_TO_CODE;
      code_string="// == then lesion named ones ==";
     };
     MethodCall @[3] {
      name="MethodCall_leslaymatFmDelim_inglesionlayers";
      desc="get into easier to use matrix format";
      flags=CAN_REVERT_TO_CODE;
      code_string="les_lay_mat->FmDelimString(lesion_layers, \" \")";
      result_var=NULL;
      obj=.programs.gp[4][2].objs_vars[0]$$;
      method=String_Matrix::FmDelimString;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="str";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="lesion_layers";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="delim";
	required=0;
	def_val=" ";
	prev_expr=;
	expr {
	 expr="\" \"";
	};
       };
      };
      meth_sig="void FmDelimString(taString& str, taString& delim =  )";
      meth_desc=" fill this matrix by parsing given string using given delimiter separating strings -- increases size as necessary to fit everything";
     };
     ForLoop @[4] {
      name="ForLoop_fori0ileslaymatsizei";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="for (i = 0; i < les_lay_mat.size; i++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_laygpnmleslaymatSafeElFlati";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp_nm = les_lay_mat->SafeEl_Flat(i)";
	result_var=.programs.gp[4][2].vars[1]$$;
	obj=$.programs.gp[4][2].objs_vars[0]$;
	method=taMatrixT_taString_::SafeEl_Flat;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=int;
	  type="int";
	  name="idx";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="i";
	  };
	 };
	};
	meth_sig="taString_ref SafeEl_Flat(int idx)";
	meth_desc=" (safely) access the matrix as if it were a flat vector, for reading";
       };
       MemberMethodCall @[1] {
	name="MemberMethodCall_laygpnetworklaye_FindNamelaygpnm";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp = network.layers.gp.FindName(laygp_nm, )";
	obj=$.programs.gp[4][2].args[0]$;
	path="layers.gp";
	result_var=$.programs.gp[4][2].vars[2]$;
	method=taGroup_Layer_::FindName;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="item_nm";
	  required=1;
	  def_val=;
	  prev_expr="laygp_nm";
	  expr {
	   expr="laygp_nm";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=int;
	  type="int";
	  name="start_idx";
	  required=0;
	  def_val="-1";
	  prev_expr=;
	  expr {
	   expr=;
	  };
	 };
	};
	meth_sig="Layer_ptr FindName(taString& item_nm, int start_idx = -1)";
	meth_desc=" Find element in top-level list with given name (nm) (NULL = not here) -- uses hash table if set, and start_idx can speed up search if you have any idea where to start -- does a bidirectional search from that starting location";
       };
       If @[2] {
	name="If_iflaygp";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (!laygp)";
	cond {
	 expr="!laygp";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MiscCall @[0] {
	  name="MiscCall_taMiscErrorlayer_worknetworkname";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="taMisc::Error(\"layer group named:\", laygp_nm, \"not found in network:\", network.name, , , , , )";
	  result_var=NULL;
	  object_type=taMisc;
	  method=taMisc::Error;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="a";
	    required=1;
	    def_val=;
	    prev_expr=;
	    expr {
	     expr="\"layer group named:\"";
	    };
	   };
	   ProgArg @[1] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="b";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr="laygp_nm";
	    };
	   };
	   ProgArg @[2] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="c";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr="\"not found in network:\"";
	    };
	   };
	   ProgArg @[3] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="d";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr="network.name";
	    };
	   };
	   ProgArg @[4] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="e";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[5] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="f";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[6] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="g";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[7] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="h";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[8] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="i";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	  };
	 };
	 IfContinue @[1] {
	  name="IfContinue_continue";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="continue";
	  cond {
	   expr=;
	  };
	 };
	};
       };
       MethodCall @[3] {
	name="MethodCall_laygpLesionLayers";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp->LesionLayers()";
	result_var=NULL;
	obj=$.programs.gp[4][2].vars[2]$;
	method=Layer_Group::LesionLayers;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void LesionLayers()";
	meth_desc=" set the lesion flag on all the layers within this group -- removes them from all processing operations";
       };
       MethodCall @[4] {
	name="MethodCall_laygpIconifyLayers";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp->IconifyLayers()";
	result_var=NULL;
	obj=$.programs.gp[4][2].vars[2]$;
	method=Layer_Group::IconifyLayers;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void IconifyLayers()";
	meth_desc=" iconi";
       };
      };
      init {
       expr="i = 0";
      };
      test {
       expr="i < les_lay_mat.size";
      };
      iter {
       expr="i++";
      };
     };
     MethodCall @[5] {
      name="MethodCall_networkBuild";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Build()";
      result_var=NULL;
      obj=$.programs.gp[4][2].args[0]$;
      method=Network::Build;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Build()";
      meth_desc=" Build the network units and Connect them (calls CheckSpecs/BuildLayers/Units/Prjns and Connect)";
     };
     MethodCall @[6] {
      name="MethodCall_networkUpdtAfterNetMod";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network->UpdtAfterNetMod()";
      result_var=NULL;
      obj=$.programs.gp[4][2].args[0]$;
      method=Network::UpdtAfterNetMod;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void UpdtAfterNetMod()";
      meth_desc=" update network after any network modification (calls appropriate functions)";
     };
     PrintExpr @[7] {
      name="PrintExpr_PrintConsnetwork_tsnetworknunits";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Print \"Cons: \" << network.n_cons << \" Units: \" << network.n_units";
      expr {
       expr="\"Cons: \" << network.n_cons << \" Units: \" << network.n_units";
      };
      debug=0;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[3] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][3].doc$$: };
    };
    name="NetworkToggleLesion";
    short_nm="NtwTgg";
    tags=;
    desc="toggle lesion status on or off in network -- for dynamic speedup..";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=String_Matrix;
     el_def=0;
     String_Matrix @[0] {
      name="les_lay_mat";
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="required for the batch counter";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="lesion_layers";
      var_type=T_String;
      string_val=;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="a space delimited list of layer group names to lesion or unlesion";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="lesion";
      var_type=T_Bool;
      bool_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="if true, lesion the layer groups, otherwise unlesion them";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="les_lay_mat";
      var_type=T_Object;
      object_type=String_Matrix;
      completion_type=;
      object_val=.programs.gp[4][3].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="i";
      var_type=T_Int;
      int_val=4;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="laygp_nm";
      var_type=T_String;
      string_val="Head";
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="laygp";
      var_type=T_Object;
      object_type=Layer_Group;
      completion_type=;
      object_val=NULL;
      object_scope=NULL;
      objs_ptr=0;
      flags=SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_leslaymatFmDelim_inglesionlayers";
      desc="get into easier to use matrix format";
      flags=0;
      code_string=;
      result_var=NULL;
      obj=.programs.gp[4][3].vars[0]$$;
      method=String_Matrix::FmDelimString;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="str";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="lesion_layers";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="delim";
	required=0;
	def_val=" ";
	prev_expr=;
	expr {
	 expr="\" \"";
	};
       };
      };
      meth_sig="void FmDelimString(taString& str, taString& delim =  )";
      meth_desc=" fill this matrix by parsing given string using given delimiter separating strings -- increases size as necessary to fit everything";
     };
     ForLoop @[1] {
      name="ForLoop_fori0ileslaymatsizei";
      desc=;
      flags=0;
      code_string=;
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_laygpnmleslaymatSafeElFlati";
	desc=;
	flags=0;
	code_string=;
	result_var=.programs.gp[4][3].vars[2]$$;
	obj=$.programs.gp[4][3].vars[0]$;
	method=taMatrixT_taString_::SafeEl_Flat;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=int;
	  type="int";
	  name="idx";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="i";
	  };
	 };
	};
	meth_sig="taString_ref SafeEl_Flat(int idx)";
	meth_desc=" (safely) access the matrix as if it were a flat vector, for reading";
       };
       MemberMethodCall @[1] {
	name="MemberMethodCall_laygpnetworklaye_FindNamelaygpnm";
	desc=;
	flags=0;
	code_string=;
	obj=.programs.gp[4][3].args[0]$$;
	path="layers.gp";
	result_var=.programs.gp[4][3].vars[3]$$;
	method=taGroup_Layer_::FindName;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="item_nm";
	  required=1;
	  def_val=;
	  prev_expr="laygp_nm";
	  expr {
	   expr="laygp_nm";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=int;
	  type="int";
	  name="start_idx";
	  required=0;
	  def_val="-1";
	  prev_expr=;
	  expr {
	   expr=;
	  };
	 };
	};
	meth_sig="Layer_ptr FindName(taString& item_nm, int start_idx = -1)";
	meth_desc=" Find element in top-level list with given name (nm) (NULL = not here) -- uses hash table if set, and start_idx can speed up search if you have any idea where to start -- does a bidirectional search from that starting location";
       };
       If @[2] {
	name="If_iflaygp";
	desc=;
	flags=0;
	code_string=;
	cond {
	 expr="!laygp";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MiscCall @[0] {
	  name="MiscCall_taMiscErrorlayer_worknetworkname";
	  desc=;
	  flags=0;
	  code_string=;
	  result_var=NULL;
	  object_type=taMisc;
	  method=taMisc::Error;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="a";
	    required=1;
	    def_val=;
	    prev_expr=;
	    expr {
	     expr="\"layer group named:\"";
	    };
	   };
	   ProgArg @[1] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="b";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr="laygp_nm";
	    };
	   };
	   ProgArg @[2] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="c";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr="\"not found in network:\"";
	    };
	   };
	   ProgArg @[3] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="d";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr="network.name";
	    };
	   };
	   ProgArg @[4] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="e";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[5] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="f";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[6] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="g";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[7] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="h";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[8] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="i";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	  };
	 };
	 IfContinue @[1] {
	  name="IfContinue_continue";
	  desc=;
	  flags=0;
	  code_string=;
	  cond {
	   expr=;
	  };
	 };
	};
       };
       If @[3] {
	name="If_iflesion";
	desc=;
	flags=0;
	code_string=;
	cond {
	 expr="lesion";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  name="MethodCall_laygpLesionLayers";
	  desc=;
	  flags=0;
	  code_string=;
	  result_var=NULL;
	  obj=$.programs.gp[4][3].vars[3]$;
	  method=Layer_Group::LesionLayers;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="void LesionLayers()";
	  meth_desc=" set the lesion flag on all the layers within this group -- removes them from all processing operations";
	 };
	};
       };
       Else @[4] {
	name="Else_If_iflesion";
	desc=;
	flags=0;
	code_string=;
	cond {
	 expr=;
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  name="MethodCall_laygpUnLesionLayers";
	  desc=;
	  flags=0;
	  code_string=;
	  result_var=NULL;
	  obj=$.programs.gp[4][3].vars[3]$;
	  method=Layer_Group::UnLesionLayers;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="void UnLesionLayers()";
	  meth_desc=" un-set the lesion flag on all the layers within this group -- restores them to engage in normal processing";
	 };
	};
       };
      };
      init {
       expr="i = 0";
      };
      test {
       expr="i < les_lay_mat.size";
      };
      iter {
       expr="i++";
      };
     };
     MethodCall @[2] {
      name="MethodCall_networkUpdtAfterNetMod";
      desc=;
      flags=0;
      code_string=;
      result_var=NULL;
      obj=$.programs.gp[4][3].args[0]$;
      method=Network::UpdtAfterNetMod;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void UpdtAfterNetMod()";
      meth_desc=" update network after any network modification (calls appropriate functions)";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[4] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][4].doc$$: };
    };
    name="TrainStart";
    short_nm="TrnStart";
    tags=;
    desc="basic stuff (init weights, load weights etc) at start of training -- also calls EpochStart -- most init progs will call this";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
     RndSeed @[0] {
      name="dmem_rnd_seed";
      rnd_seed=4207452915;
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="dmem_rnd_seed";
      var_type=T_Object;
      object_type=RndSeed;
      completion_type=;
      object_val=.programs.gp[4][4].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="weights_file";
      var_type=T_String;
      string_val="wts/Telos1_act_rel_trnd.wts";
      completion_type=;
      object_scope=NULL;
      flags=CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
      reference=0;
      desc="fm enviro";
      init_from=$.programs.gp[4][0]$;
     };
     ProgVar @[1] {
      name="load_weights";
      var_type=T_Bool;
      bool_val=1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
      reference=0;
      desc="fm enviro";
      init_from=$.programs.gp[4][0]$;
     };
     ProgVar @[2] {
      name="load_st_epc";
      var_type=T_Int;
      int_val=1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
      reference=0;
      desc="fm enviro";
      init_from=$.programs.gp[4][0]$;
     };
     ProgVar @[3] {
      name="lrs_step_epochs";
      var_type=T_Int;
      int_val=50;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
      reference=0;
      desc="fm enviro";
      init_from=$.programs.gp[4][0]$;
     };
     ProgVar @[4] {
      name="LRSConSpec";
      var_type=T_Object;
      object_type=LeabraConSpec;
      completion_type=;
      object_val=.networks[0].specs[8]$$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     ProgramCall @[0] {
      name="ProgramCall_BatchRndSeednetwork";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="BatchRndSeed(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[4][1]$$;
      targ_ld_init="*BatchRndSeed*";
     };
     MethodCall @[1] {
      name="MethodCall_networkBuild";
      desc="needs to have been built by now..";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Build()";
      result_var=NULL;
      obj=.programs.gp[4][4].args[0]$$;
      method=Network::Build;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Build()";
      meth_desc=" Build the network units and Connect them (calls CheckSpecs/BuildLayers/Units/Prjns and Connect)";
     };
     MethodCall @[2] {
      name="MethodCall_networkInitWeights";
      desc="initialize network weights: could also load pre-set weights or something else here";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Init_Weights()";
      result_var=NULL;
      obj=$.programs.gp[4][4].args[0]$;
      method=Network::Init_Weights;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_Weights()";
      meth_desc=" Initialize the weights -- also inits acts, counters and stats -- does unit level threaded and then does Layers after";
     };
     PrintExpr @[3] {
      name="PrintExpr_Printnetworkname_ghtsInitialized";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Print network.name << \" Weights Initialized\"";
      expr {
       expr="network.name << \" Weights Initialized\"";
      };
      debug=0;
     };
     If @[4] {
      name="If_ifloadweightsweightsfilenonempty";
      desc="Load  weights if file is specified";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (load_weights && weights_file.nonempty())";
      cond {
       expr="load_weights && weights_file.nonempty()";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkLoadWeigh_eightsfilefalse";
	desc="Load weights from the specified file";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->LoadWeights(weights_file, false)";
	result_var=NULL;
	obj=$.programs.gp[4][4].args[0]$;
	method=Network::LoadWeights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="fname";
	  required=0;
	  def_val="\"\"";
	  prev_expr=;
	  expr {
	   expr="weights_file";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=bool;
	  type="bool";
	  name="quiet";
	  required=0;
	  def_val="false";
	  prev_expr=;
	  expr {
	   expr="false";
	  };
	 };
	};
	meth_sig="bool LoadWeights(taString& fname, bool quiet = false)";
	meth_desc=" read weight values in from a simple ordered list of weights (fmt is read from file) (leave fname empty to pull up file chooser)";
       };
       PrintVar @[1] {
	name="PrintVar_Printloadedweigh_fileweightsfile";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="Print  \"loaded weights file:\" weights_file";
	message="loaded weights file:";
	print_var=.programs.gp[4][4].vars[0]$$;
	print_var2=NULL;
	print_var3=NULL;
	print_var4=NULL;
	print_var5=NULL;
	print_var6=NULL;
	debug=0;
       };
       MemberAssign @[2] {
	name="MemberAssign_networkepochloadstepc";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="network.epoch = load_st_epc";
	obj=$.programs.gp[4][4].args[0]$;
	path="epoch";
	expr {
	 expr="load_st_epc";
	};
	update_after=1;
       };
      };
     };
     MethodCall @[5] {
      name="MethodCall_LRSConSpecLogLra_dlrsstepepochs7";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LRSConSpec->LogLrateSched(lrs_step_epochs, 7, )";
      result_var=NULL;
      obj=.programs.gp[4][4].vars[4]$$;
      method=LeabraConSpec::LogLrateSched;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="epcs_per_step";
	required=0;
	def_val="50";
	prev_expr="lrs_step_epochs";
	expr {
	 expr="lrs_step_epochs";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_steps";
	required=0;
	def_val="5";
	prev_expr="7";
	expr {
	 expr="7";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="bump_step";
	required=0;
	def_val="-1";
	prev_expr=;
	expr {
	 expr=;
	};
       };
      };
      meth_sig="void LogLrateSched(int epcs_per_step = 50, int n_steps = 5, int bump_step = -1)";
      meth_desc=" establish a logarithmic learning rate schedule with given total number of steps (including first step at lrate) and epochs per step: numbers go down in sequence: 1, .5, .2, .1, .05, .02, .01, etc.. this is a particularly good lrate schedule for large nets on hard tasks -- if bump_step > 0 (3 is a good default), the lrate bumps back up to 1 and back down to that step level, and then proceeds from there -- this can pop a model out of a local minimum and result in better final performance";
     };
     If @[6] {
      name="If_iftaMiscdmemnprocs1";
      desc="if dmem, then from here on out, processors diverge so that lists of objs per processor are different!";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (taMisc::dmem_nprocs > 1)";
      cond {
       expr="taMisc::dmem_nprocs > 1";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_dmemrndseedNewSeed";
	desc="restore previous random seed (all runs produce same results); change to NewSeed to have new random numbers each time";
	flags=CAN_REVERT_TO_CODE;
	code_string="dmem_rnd_seed->NewSeed()";
	result_var=NULL;
	obj=.programs.gp[4][4].objs_vars[0]$$;
	method=RndSeed::NewSeed;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void NewSeed()";
	meth_desc=" set the seed to a new random value (based on time and process id)";
       };
      };
     };
     ProgramCall @[7] {
      name="ProgramCall_EpochStartnetwork";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="EpochStart(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=$.programs.gp[4][6]$;
      targ_ld_init="*EpochStart*";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[5] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][5].doc$$: };
    };
    name="TrainEnd";
    short_nm="TrnEnd";
    tags=;
    desc="end training -- save weights if needed, compute final summary stats -- and set stop_train";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="save_final_wts";
      var_type=T_Bool;
      bool_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
      reference=0;
      desc=;
      init_from=$.programs.gp[4][0]$;
     };
     ProgVar @[1] {
      name="Train";
      var_type=T_Object;
      object_type=Program;
      completion_type=;
      object_val=$.programs.gp[1][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     If @[0] {
      name="If_ifsavefinalwts";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (save_final_wts)";
      cond {
       expr="save_final_wts";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_SaveWeightsSpecsnetwork";
	desc="Always save weights at the end";
	flags=CAN_REVERT_TO_CODE;
	code_string="SaveWeightsSpecs(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.programs.gp[4][12]$;
	targ_ld_init="*SaveWeightsSpecs*";
       };
      };
     };
     MethodCall @[1] {
      name="MethodCall_TrainSetVarstoptraintrue";
      desc="stop training!";
      flags=CAN_REVERT_TO_CODE;
      code_string="Train->SetVar(\"stop_train\", true)";
      result_var=NULL;
      obj=.programs.gp[4][5].vars[1]$$;
      method=Program::SetVar;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="var_nm";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="\"stop_train\"";
	};
       };
       ProgArg @[1] {
	arg_type=const_Variant_ref;
	type="Variant&";
	name="value";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="bool SetVar(taString& var_nm, Variant& value)";
      meth_desc=" set the value of a program variable (only top-level variables in vars or args) -- can be called from within a running program";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[6] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][6].doc$$: };
    };
    name="EpochStart";
    short_nm="EpcStart";
    tags=;
    desc="Start a new epoch";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[1][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="BasicTrainTime";
      var_type=T_Object;
      object_type=TimeUsed;
      completion_type=;
      object_val=NULL;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MemberAssign @[0] {
      name="MemberAssign_networktrial0";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network.trial = 0";
      obj=.programs.gp[4][6].args[0]$$;
      path="trial";
      expr {
       expr="0";
      };
      update_after=0;
     };
     MemberMethodCall @[1] {
      name="MemberMethodCall_networkepochtimeStartTimertrue";
      desc="start the epoch timer to record computation time per epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="network.epoch_time.StartTimer(true)";
      obj=$.programs.gp[4][6].args[0]$;
      path="epoch_time";
      result_var=NULL;
      method=TimeUsed::StartTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void StartTimer(bool reset_used = true)";
      meth_desc=" record the current time as the starting time, and optionally reset the time used information";
     };
     MethodCall @[2] {
      name="MethodCall_BasicTrainTimeResetUsed";
      desc="keep other time info on an epoch basis";
      flags=CAN_REVERT_TO_CODE;
      code_string="BasicTrainTime->ResetUsed()";
      result_var=NULL;
      obj=.programs.gp[4][6].vars[1]$$;
      method=TimeUsed::ResetUsed;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void ResetUsed()";
      meth_desc=" reset time used information";
     };
     MethodCall @[3] {
      name="MethodCall_trialmondataResetData";
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->ResetData()";
      result_var=NULL;
      obj=.programs.gp[4][6].vars[0]$$;
      method=DataTable::ResetData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void ResetData()";
      meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[7] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][7].doc$$: };
    };
    name="EpochEnd";
    short_nm="EpcEnd";
    tags=;
    desc="end of epoch -- relnet and basic stats compute, calls only the core standard monitor, save weights if doing that";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="adapt_rel_abs_netin";
      var_type=T_Bool;
      bool_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc="use the computed rel and abs netin values to adapt the wt_scale.abs and wt_scale.rel params of network conspecs to match target values that are set on the projections -- see conspec rel_net_adapt and layerspec abs_net_adapt parmeters and comments for more information";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="compute_rel_netin";
      var_type=T_Bool;
      bool_val=1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc="call Compute_AvgAbsRelNetin() function to collect relative net input information telling how much each layer receives from each of its receiving projections";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="save_wts_interval";
      var_type=T_Int;
      int_val=200;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
      reference=0;
      desc=;
      init_from=$.programs.gp[4][0]$;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_networkComputeEpochStats";
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_EpochStats()";
      result_var=NULL;
      obj=.programs.gp[4][7].args[0]$$;
      method=Network::Compute_EpochStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_EpochStats()";
      meth_desc=" compute epoch-level statistics; calls DMem_ComputeAggs (if dmem) and EpochSSE -- specific algos may add more";
     };
     If @[1] {
      name="If_ifcomputerelnetin";
      desc=;
      flags=OFF|NEW_EL|CAN_REVERT_TO_CODE;
      code_string="if (compute_rel_netin)";
      cond {
       expr="compute_rel_netin";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkComputeAvgAbsRelNetin";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Compute_AvgAbsRelNetin()";
	result_var=NULL;
	obj=$.programs.gp[4][7].args[0]$;
	method=LeabraNetwork::Compute_AvgAbsRelNetin;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Compute_AvgAbsRelNetin()";
	meth_desc=" compute time-average absolute layer-level and relative netinput from different projections into layers in network (e.g. over epoch timescale)";
       };
       If @[1] {
	name="If_ifadaptrelabsnetin";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (adapt_rel_abs_netin)";
	cond {
	 expr="adapt_rel_abs_netin";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  name="MethodCall_networkmethod";
	  desc=;
	  flags=0;
	  code_string=;
	  result_var=NULL;
	  obj=$.programs.gp[4][7].args[0]$;
	  method=NULL;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig=;
	  meth_desc=;
	 };
	 MethodCall @[1] {
	  name="MethodCall_networkmethod_1";
	  desc=;
	  flags=0;
	  code_string=;
	  result_var=NULL;
	  obj=$.programs.gp[4][7].args[0]$;
	  method=NULL;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig=;
	  meth_desc=;
	 };
	};
       };
      };
     };
     MemberMethodCall @[2] {
      name="MemberMethodCall_networkepochtimeEndTimer";
      desc="start the epoch timer to record computation time per epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="network.epoch_time.EndTimer()";
      obj=$.programs.gp[4][7].args[0]$;
      path="epoch_time";
      result_var=NULL;
      method=TimeUsed::EndTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void EndTimer()";
      meth_desc=" record the current time as the ending time, and compute difference as the time used";
     };
     ProgramCall @[3] {
      name="ProgramCall_LeabraEpochMonitornetwork";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LeabraEpochMonitor(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[4].gp[0][1]$$;
      targ_ld_init="*LeabraEpochMonitor*";
     };
     If @[4] {
      name="If_ifnetworkepochsa_l0networkepoch0";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network->epoch % save_wts_interval == 0 && network->epoch > 0)";
      cond {
       expr="network->epoch % save_wts_interval == 0 && network->epoch > 0";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_SaveWeightsSpecsnetwork";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="SaveWeightsSpecs(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.programs.gp[4][12]$;
	targ_ld_init="*SaveWeightsSpecs*";
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[8] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][8].doc$$: };
    };
    name="TrialStart";
    short_nm="TrStrt";
    tags=;
    desc="start of trial before any input data applied -- prepares for input data to be applied (Init_InputData)";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_networkTrialInit";
      desc="initializes various counters at start of trial";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Init()";
      result_var=NULL;
      obj=.programs.gp[4][8].args[0]$$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Init()";
      meth_desc=" initialize at start of trial (init specs, Decay state)";
     };
     MethodCall @[1] {
      name="MethodCall_networkTrialInitCounters";
      desc="initializes various counters at start of trial";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Init_Counters()";
      result_var=NULL;
      obj=$.programs.gp[4][8].args[0]$;
      method=LeabraNetwork::Trial_Init_Counters;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Init_Counters()";
      meth_desc=" init counters -- network only";
     };
     MethodCall @[2] {
      name="MethodCall_networkInitInputData";
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Init_InputData()";
      result_var=NULL;
      obj=$.programs.gp[4][8].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_InputData()";
      meth_desc=" Initializes external and target inputs";
     };
     MemberAssign @[3] {
      name="MemberAssign_networkcycle0";
      desc="start at 0 cycle";
      flags=CAN_REVERT_TO_CODE;
      code_string="network.cycle = 0";
      obj=$.programs.gp[4][8].args[0]$;
      path="cycle";
      expr {
       expr="0";
      };
      update_after=0;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[9] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][9].doc$$: };
    };
    name="TrialEnd";
    short_nm="TrlEnd";
    tags=;
    desc="standard end-of-trial code -- no monitor calls at all";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="compute_rel_netin";
      var_type=T_Bool;
      bool_val=1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="call ComputeAbsRelNetin() function to collect relative net input information telling how much each layer receives from each of its receiving projections";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_networkTrialFinal";
      desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Final()";
      result_var=NULL;
      obj=.programs.gp[4][9].args[0]$$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Final()";
      meth_desc=" do final processing after trial: Compute_AbsRelNetin";
     };
     If @[1] {
      name="If_ifcomputerelnetin";
      desc=;
      flags=NEW_EL|CAN_REVERT_TO_CODE;
      code_string="if (compute_rel_netin)";
      cond {
       expr="compute_rel_netin";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkComputeAbsRelNetin";
	desc="special for adapting netin";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Compute_AbsRelNetin()";
	result_var=NULL;
	obj=$.programs.gp[4][9].args[0]$;
	method=LeabraNetwork::Compute_AbsRelNetin;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Compute_AbsRelNetin()";
	meth_desc=" compute the absolute layer-level and relative netinput from different projections into layers in network -- this should NOT be called from programs (although previously it was) -- it is automatically called in Trial_Final now, and projection-level netin data is subjected to settings of rel_netin if NETIN_PER_PRJN flag is not set";
       };
      };
     };
     If @[2] {
      name="If_ifnetworkCompute_stnetworktrial1";
      desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network.Compute_Weights_Test(network.trial+1))";
      cond {
       expr="network.Compute_Weights_Test(network.trial+1)";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkComputeWeights";
	desc="update the weight values based on changes computed by trial program";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Compute_Weights()";
	result_var=NULL;
	obj=$.programs.gp[4][9].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Compute_Weights()";
	meth_desc=" update weights for whole net: calls DMem_SumDWts before doing update if in dmem mode";
       };
      };
     };
     NetUpdateView @[3] {
      name="NetUpdateView_NetUpdateView";
      desc="update the network view(s) (only if update_net_view is true)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[4][9].args[0]$;
      update_var=.programs.gp[4][9].vars[1]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[10] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][10].doc$$: };
    };
    name="Settle";
    short_nm="Settle";
    tags=;
    desc="settle network for fixed number of cycles -- see also SettleMinusPhase";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="cycle_max";
      var_type=T_Int;
      int_val=25;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="number of cycles to run -- actually always runs this many cycles -- does not use threshold";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="i";
      var_type=T_Int;
      int_val=25;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     ForLoop @[0] {
      name="ForLoop_fori0icyclemaxi";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="for (i = 0; i < cycle_max; i++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_Cyclenetwork";
	desc="run the cycle program, which computes one cycle of activations";
	flags=CAN_REVERT_TO_CODE;
	code_string="Cycle(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.programs.gp[4][11]$;
	targ_ld_init="*LeabraCycle*";
       };
      };
      init {
       expr="i = 0";
      };
      test {
       expr="i < cycle_max";
      };
      iter {
       expr="i++";
      };
     };
    };
    step_prog=$.programs.gp[4][11]$;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[11] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][11].doc$$: };
    };
    name="Cycle";
    short_nm="Cycle";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_networkCycleRun";
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Cycle_Run()";
      result_var=NULL;
      obj=.programs.gp[4][11].args[0]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Cycle_Run()";
      meth_desc=" compute cycle(s) of updating: netinput, inhibition, activations -- multiple cycles can be run depending on lthreads.n_cycles setting and whether multiple threads are actually being used -- see lthreads.n_threads_act";
     };
     NetUpdateView @[1] {
      name="NetUpdateView_NetUpdateView";
      desc="update network views if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[4][11].args[0]$;
      update_var=$.programs.gp[4][11].vars[0]$;
     };
     MemberAssign @[2] {
      name="MemberAssign_networkcyclenetworkcycle1";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network.cycle = network.cycle + 1";
      obj=$.programs.gp[4][11].args[0]$;
      path="cycle";
      expr {
       expr="network.cycle + 1";
      };
      update_after=0;
     };
    };
    step_prog=NULL;
    step_n=25;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[12] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][12].doc$$: };
    };
    name="SaveWeightsSpecs";
    short_nm="SavWts";
    tags="Weights, Specs";
    desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values
also save specs.";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="tag";
      var_type=T_String;
      string_val="_gui";
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="user defined tag (set by startup script)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="wts_subdir";
      var_type=T_String;
      string_val=;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="subdirectory to save weights in";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="save_specs";
      var_type=T_Bool;
      bool_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="fname";
      var_type=T_String;
      string_val="/Users/thazy/svn_sims/pfc/ef/telos/Telos1_gui.00_0400.wts.gz";
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[4] {
      name="spec_fname";
      var_type=T_String;
      string_val=;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[5] {
      name="epoch_str";
      var_type=T_String;
      string_val="0400";
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="string rep of epoch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="batch_str";
      var_type=T_String;
      string_val="00";
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="string rep of batch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[7] {
      name="final_tag";
      var_type=T_String;
      string_val="_gui.00_0400";
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="batch + epoch";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     If @[0] {
      name="If_iftaMiscdmemproc0";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (taMisc::dmem_proc > 0)";
      cond {
       expr="taMisc::dmem_proc > 0";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       ReturnExpr @[0] {
	name="ReturnExpr_return";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="return ";
	expr {
	 expr=;
	};
       };
      };
     };
     MiscCall @[1] {
      name="MiscCall_batchstrtaMiscLe_osnetworkbatch2";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="batch_str = taMisc::LeadingZeros(network.batch, 2)";
      result_var=.programs.gp[4][12].vars[6]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network.batch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="2";
	};
       };
      };
     };
     MiscCall @[2] {
      name="MiscCall_epochstrtaMiscLe_osnetworkepoch4";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_str = taMisc::LeadingZeros(network.epoch, 4)";
      result_var=.programs.gp[4][12].vars[5]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network.epoch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="4";
	};
       };
      };
     };
     AssignExpr @[3] {
      name="AssignExpr_finaltagtagbatchstrepochstr";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="final_tag = tag + \".\" + batch_str + \"_\" + epoch_str";
      result_var=.programs.gp[4][12].vars[7]$$;
      expr {
       expr="tag + \".\" + batch_str + \"_\" + epoch_str";
      };
     };
     MethodCall @[4] {
      name="MethodCall_fnamenetworkGetF_gwtssubdirfalse";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="fname = network->GetFileNameFmProject(\".wts.gz\", final_tag, wts_subdir, false)";
      result_var=.programs.gp[4][12].vars[3]$$;
      obj=.programs.gp[4][12].args[0]$$;
      method=taBase::GetFileNameFmProject;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="ext";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="\".wts.gz\"";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="tag";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="final_tag";
	};
       };
       ProgArg @[2] {
	arg_type=const_taString_ref;
	type="taString&";
	name="subdir";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="wts_subdir";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="dmem_proc_no";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
      meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
     };
     MethodCall @[5] {
      name="MethodCall_networkSaveWeigh_meNetworkNETFMT";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network->SaveWeights(fname, Network::NET_FMT)";
      result_var=NULL;
      obj=$.programs.gp[4][12].args[0]$;
      method=Network::SaveWeights;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="fname";
	};
       };
       ProgArg @[1] {
	arg_type=Network::WtSaveFormat;
	type="Network::WtSaveFormat";
	name="fmt";
	required=0;
	def_val="Network::NET_FMT";
	prev_expr=;
	expr {
	 expr="Network::NET_FMT";
	};
       };
      };
      meth_sig="void SaveWeights(taString& fname, Network::WtSaveFormat fmt = NET_FMT)";
      meth_desc=" write weight values out in a simple ordered list of weights (optionally in binary fmt) (leave fname empty to pull up file chooser)";
     };
     If @[6] {
      name="If_ifsavespecs";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (save_specs)";
      cond {
       expr="save_specs";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       AssignExpr @[0] {
	name="AssignExpr_specfnamefnamebeforewts1spec";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="spec_fname = fname.before(\".wts\",-1) + \".spec\"";
	result_var=.programs.gp[4][12].vars[4]$$;
	expr {
	 expr="fname.before(\".wts\",-1) + \".spec\"";
	};
       };
       MemberMethodCall @[1] {
	name="MemberMethodCall_networkspecsSaveAsspecfname";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="network.specs.SaveAs(spec_fname)";
	obj=$.programs.gp[4][12].args[0]$;
	path="specs";
	result_var=NULL;
	method=taList_impl::SaveAs;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="fname";
	  required=0;
	  def_val="\"\"";
	  prev_expr=;
	  expr {
	   expr="spec_fname";
	  };
	 };
	};
	meth_sig="int SaveAs(taString& fname)";
	meth_desc=" Saves object data to a new file -- if fname is empty, the user is prompted with a file dialog";
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program_Group @.gp[0] {
    name="Monitors";
    el_typ=Program;
    el_def=0;
    tags=;
    desc=;
    debug_mode=0;
    Program @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4].gp[0][0].doc$$: };
     };
     name="LeabraTrialMonitor";
     short_nm="TrialMon";
     tags="Leabra, Std, Monitor";
     desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author=;
     email=;
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=NetMonitor;
      el_def=0;
      NetMonitor @[0] {
       name="trial_netmon";
       items {
	name="items";
	el_typ=NetMonItem;
	el_def=0;
	ignore_sig=0;
	NetMonItem @[0] {
	 name="batch";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="batch";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[1] {
	 name="epoch";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="epoch";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[2] {
	 name="train_mode";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="train_mode";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[3] {
	 name="trial";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="trial";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[4] {
	 name="tick";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="tick";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[5] {
	 name="trial_name";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="trial_name";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[6] {
	 name="group_name";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="group_name";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[7] {
	 name="rt_cycles";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="rt_cycles";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[8] {
	 name="sse";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="sse";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[9] {
	 name="norm_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="norm_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[10] {
	 name="ext_rew";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="ext_rew";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
       };
       network=$.networks[0]$;
       data=$.data.gp[1][0]$;
       rmv_orphan_cols=1;
      };
     };
     objs_vars {
      name="objs_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="trial_netmon";
       var_type=T_Object;
       object_type=NetMonitor;
       completion_type=;
       object_val=.programs.gp[4].gp[0][0].objs[0]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
       init_from=NULL;
      };
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=Network;
       completion_type=;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to record data from";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="trial_mon_data";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=$.data.gp[1][0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="data table to record trial-level data to (this program writes new data to this table!)";
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_trialnetmonSetDa_lmondatanetwork";
       desc="set the network and datatable for the NetMonitor";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_netmon->SetDataNetwork(trial_mon_data, network)";
       result_var=NULL;
       obj=.programs.gp[4].gp[0][0].objs_vars[0]$$;
       method=NetMonitor::SetDataNetwork;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="dt";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="trial_mon_data";
	 };
	};
	ProgArg @[1] {
	 arg_type=Network_ptr;
	 type="Network*";
	 name="net";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
       meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
      };
      MethodCall @[1] {
       name="MethodCall_trialnetmonCheckConfigfalse";
       desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_netmon->CheckConfig(false)";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][0].objs_vars[0]$;
       method=taBase::CheckConfig;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="bool CheckConfig(bool quiet = false)";
       meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
      };
      MethodCall @[2] {
       name="MethodCall_trialnetmonUpdateMonitorstrue";
       desc="update the monitor items and data schema based on current settings of the NetMonitor object";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_netmon->UpdateMonitors(true)";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][0].objs_vars[0]$;
       method=NetMonitor::UpdateMonitors;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="reset_first";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
       };
       meth_sig="void UpdateMonitors(bool reset_first = false)";
       meth_desc=" old name for UpdateDataTable";
      };
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_trialmondataAddBlankRow";
       desc="add a new blank row to the data";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_mon_data->AddBlankRow()";
       result_var=NULL;
       obj=.programs.gp[4].gp[0][0].vars[0]$$;
       method=DataTable::AddBlankRow;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="int AddBlankRow()";
       meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
      };
      MethodCall @[1] {
       name="MethodCall_trialnetmonGetMonVals";
       desc="get the new monitor data from the network and other sources -- this does the main work";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_netmon->GetMonVals()";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][0].objs_vars[0]$;
       method=NetMonitor::GetMonVals;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void GetMonVals()";
       meth_desc=" get all the values and store in current row of data table -- call in program to get new data";
      };
      MethodCall @[2] {
       name="MethodCall_trialmondataWriteClose";
       desc="update views and other things after writing new data to monitor data table";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_mon_data->WriteClose()";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][0].vars[0]$;
       method=DataTable::WriteClose;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void WriteClose()";
       meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
      };
      MethodCall @[3] {
       name="MethodCall_networkDMemShare_tatrialmondata1";
       desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
       flags=CAN_REVERT_TO_CODE;
       code_string="network->DMem_ShareTrialData(trial_mon_data, 1)";
       result_var=NULL;
       obj=.programs.gp[4].gp[0][0].args[0]$$;
       method=Network::DMem_ShareTrialData;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="dt";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="trial_mon_data";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="n_rows";
	 required=0;
	 def_val="1";
	 prev_expr=;
	 expr {
	  expr="1";
	 };
	};
       };
       meth_sig="void DMem_ShareTrialData(DataTable* dt, int n_rows = 1)";
       meth_desc=" share trial data from given datatable across the trial-level dmem communicator (outer loop) -- each processor gets data from all other processors; if called every trial with n_rows = 1, data will be identical to non-dmem; if called at end of epoch with n_rows = -1 data will be grouped by processor but this is more efficient";
      };
     };
     step_prog=$.programs.gp[4].gp[0][0]$;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=0;
      wiki=;
      url="local";
      full_url="local";
      text_size=1;
      text=;
      html_text=;
     };
    };
    Program @[1] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4].gp[0][1].doc$$: };
     };
     name="LeabraEpochMonitor";
     short_nm="EpcMon";
     tags="Leabra, Std, Monitor";
     desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author=;
     email=;
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=NetMonitor;
      el_def=0;
      NetMonitor @[0] {
       name="epoch_netmon";
       items {
	name="items";
	el_typ=NetMonItem;
	el_def=0;
	ignore_sig=0;
	NetMonItem @[0] {
	 name="batch";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="batch";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[1] {
	 name="epoch";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="epoch";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[2] {
	 name="train_mode";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="train_mode";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[3] {
	 name="avg_sse";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_sse";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[4] {
	 name="cnt_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="cnt_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[5] {
	 name="avg_norm_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_norm_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[6] {
	 name="avg_ext_rew";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_ext_rew";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[7] {
	 name="avg_cycles";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_cycles";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[8] {
	 name="epoch_time_tot";
	 computed=1;
	 object_type=NULL;
	 object=NULL;
	 variable="act";
	 var_label=;
	 name_style=MY_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[9] {
	 name="epoch_time_usr";
	 computed=1;
	 object_type=NULL;
	 object=NULL;
	 variable="act";
	 var_label=;
	 name_style=MY_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[10] {
	 name="netrel";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="prjns.avg_netin_rel";
	 var_label="netrel";
	 name_style=AUTO_NAME;
	 max_name_len=67;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[11] {
	 name="netmax";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_netin.max";
	 var_label="netmax";
	 name_style=AUTO_NAME;
	 max_name_len=12;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
       };
       network=$.networks[0]$;
       data=$.data.gp[1][1]$;
       rmv_orphan_cols=1;
      };
     };
     objs_vars {
      name="objs_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="epoch_netmon";
       var_type=T_Object;
       object_type=NetMonitor;
       completion_type=;
       object_val=.programs.gp[4].gp[0][1].objs[0]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="network monitor object that contains full specs for what to record and where to get it";
       init_from=NULL;
      };
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=Network;
       completion_type=;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to get data from";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="epoch_mon_data";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=$.data.gp[1][1]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="data table to write the epoch data to";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="epoch_timer";
       var_type=T_Object;
       object_type=TimeUsed;
       completion_type=;
       object_val=.networks[0].epoch_time$$;
       object_scope=NULL;
       objs_ptr=0;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       name="AssignExpr_epochtimernetworkepochtime";
       desc="get the epoch timer from current network";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_timer = network.epoch_time";
       result_var=.programs.gp[4].gp[0][1].vars[1]$$;
       expr {
	expr="network.epoch_time";
       };
      };
      MethodCall @[1] {
       name="MethodCall_epochnetmonSetDa_hmondatanetwork";
       desc="set data and network on NetMonitor object";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_netmon->SetDataNetwork(epoch_mon_data, network)";
       result_var=NULL;
       obj=.programs.gp[4].gp[0][1].objs_vars[0]$$;
       method=NetMonitor::SetDataNetwork;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="dt";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="epoch_mon_data";
	 };
	};
	ProgArg @[1] {
	 arg_type=Network_ptr;
	 type="Network*";
	 name="net";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
       meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
      };
      MethodCall @[2] {
       name="MethodCall_epochnetmonCheckConfigfalse";
       desc="check configuration and emit errors/warnings for problems";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_netmon->CheckConfig(false)";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][1].objs_vars[0]$;
       method=taBase::CheckConfig;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="bool CheckConfig(bool quiet = false)";
       meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
      };
      MethodCall @[3] {
       name="MethodCall_epochnetmonUpdateMonitorstrue";
       desc="update the monitor items and data schema based on current settings of NetMonitor";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_netmon->UpdateMonitors(true)";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][1].objs_vars[0]$;
       method=NetMonitor::UpdateMonitors;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="reset_first";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
       };
       meth_sig="void UpdateMonitors(bool reset_first = false)";
       meth_desc=" old name for UpdateDataTable";
      };
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_epochmondataAddBlankRow";
       desc="add a new blank row to the data";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_mon_data->AddBlankRow()";
       result_var=NULL;
       obj=.programs.gp[4].gp[0][1].vars[0]$$;
       method=DataTable::AddBlankRow;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="int AddBlankRow()";
       meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
      };
      MethodCall @[1] {
       name="MethodCall_epochnetmonGetMonVals";
       desc="get the new monitor data and stor it into the data table -- this does the main job here";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_netmon->GetMonVals()";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][1].objs_vars[0]$;
       method=NetMonitor::GetMonVals;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void GetMonVals()";
       meth_desc=" get all the values and store in current row of data table -- call in program to get new data";
      };
      AssignExpr @[2] {
       name="AssignExpr_epochtimernetworkepochtime";
       desc="get the epoch timer from current network";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_timer = network.epoch_time";
       result_var=$.programs.gp[4].gp[0][1].vars[1]$;
       expr {
	expr="network.epoch_time";
       };
      };
      MethodCall @[3] {
       name="MethodCall_epochmondataSetV_csepochtimetot1";
       desc="set the total time to compute the epoch (epoch_time_tot -- wall clock time) to time used data from network timer";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_mon_data->SetValColName(epoch_timer.used.GetTotSecs(), \"epoch_time_tot\", -1, )";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][1].vars[0]$;
       method=DataTable::SetValColName;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="epoch_timer.used.GetTotSecs()";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="col_name";
	 required=1;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="\"epoch_time_tot\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="-1";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="bool SetValColName(Variant& val, taString& col_name, int row, bool quiet = false)";
       meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column name, row; returns 'true' if valid access and set is successful -- quiet = fail quietly";
      };
      MethodCall @[4] {
       name="MethodCall_epochmondataSetV_csepochtimeusr1";
       desc="set the user process time (cpu time for this process, epoch_time_usr) to time used data from network timer";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_mon_data->SetValColName(epoch_timer.used.GetUsrSecs(), \"epoch_time_usr\", -1, )";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][1].vars[0]$;
       method=DataTable::SetValColName;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="epoch_timer.used.GetUsrSecs()";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="col_name";
	 required=1;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="\"epoch_time_usr\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="-1";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="bool SetValColName(Variant& val, taString& col_name, int row, bool quiet = false)";
       meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column name, row; returns 'true' if valid access and set is successful -- quiet = fail quietly";
      };
      MethodCall @[5] {
       name="MethodCall_epochmondataWriteClose";
       desc="update after writing new data to monitor data table";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_mon_data->WriteClose()";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][1].vars[0]$;
       method=DataTable::WriteClose;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void WriteClose()";
       meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
      };
      Comment @[6] {
       name="Comment_NOTEifdoingaTest_atablecorrectly";
       desc="NOTE: if doing a TestEpoch and wanting to include test results in this train epoch log, then see these instructions:
http://grey.colorado.edu/emergent/index.php/Test_Programs
quick summary here:
* Add computed, data_agg, op = LAST items to epoch_netmon to grab from the EpochTestOutputData table.
* duplicate this program, call the new one LeabraEpochMonitor_postest, remove all netmon items for training, leaving only test,
  turn off rmv_orphan_cols flag, and set arg for UpdateMonitors in init_code to false
* in original LeabraEpochMonitor, click OFF flag for WriteClose() line
* in LeabraEpoch add call to LeabraEpochTest, then _posttest after the first LeabraEpochMonitor call.
This will ensure that training data is monitored first, right after the training epoch, and then the test epoch is run,
and the testing data is updated.  The first epoch monitor should have all the items, so that it formats the data table correctly.
 
";
       flags=CAN_REVERT_TO_CODE;
       code_string="// NOTE: if doing a TestEpoch and wanting to include test results in this train epoch log, then see these instructions:
http://grey.colorado.edu/emergent/index.php/Test_Programs
quick summary here:
* Add computed, data_agg, op = LAST items to epoch_netmon to grab from the EpochTestOutputData table.
* duplicate this program, call the new one LeabraEpochMonitor_postest, remove all netmon items for training, leaving only test,
  turn off rmv_orphan_cols flag, and set arg for UpdateMonitors in init_code to false
* in original LeabraEpochMonitor, click OFF flag for WriteClose() line
* in LeabraEpoch add call to LeabraEpochTest, then _posttest after the first LeabraEpochMonitor call.
This will ensure that training data is monitored first, right after the training epoch, and then the test epoch is run,
and the testing data is updated.  The first epoch monitor should have all the items, so that it formats the data table correctly.
 
";
      };
     };
     step_prog=$.programs.gp[4].gp[0][1]$;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=0;
      wiki=;
      url="local";
      full_url="local";
      text_size=1;
      text=;
      html_text=;
     };
    };
   };
  };
 };
 viewers {
  name="viewers";
  el_typ=MainWindowViewer;
  el_def=0;
  MainWindowViewer @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="view_win_lft": value=0: val_type_fixed=0: };
    UserDataItem @[1] {name="view_win_top": value=0.00292113: val_type_fixed=0: };
    UserDataItem @[2] {name="view_win_wd": value=0.9963415: val_type_fixed=0: };
    UserDataItem @[3] {name="view_win_ht": value=0.849075: val_type_fixed=0: };
    UserDataItem @[4] {name="view_win_iconified": value=0: val_type_fixed=0: };
    UserDataItem @[5] {name="view_splitter_state": value=AAAA/wAAAAEAAAADAAABEgAAAdgAAAMXAQAAAAcBAAAAAQE=: val_type_fixed=0: };
   };
   name="Browser3";
   m_data=.$$;
   cur_font_size=12;
   visible=1;
   win_name=".projects[\"Telos1\"] - Telos1.proj";
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   revert_to_tab_no=-1;
   toolbars {
    name="toolbars";
    el_typ=ToolBar;
    el_def=0;
    ToolBar @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {name="view_win_visible": value=1: val_type_fixed=0: };
     };
     name="Application";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name="frames";
    el_typ=BrowseViewerTaBase;
    el_def=0;
    BrowseViewerTaBase @[0] {
     name="Navigator";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$.$;
    };
    PanelViewer @[1] {
     name="Editor";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
    };
    T3PanelViewer @[2] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {name="view_frame_selected": value=1: val_type_fixed=0: };
      UserDataItem @[1] {name="view_panel_selected": value=1: val_type_fixed=0: };
     };
     name="Visualizer";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     panels {
      name="panels";
      el_typ=T3Panel;
      el_def=0;
      T3Panel @[0] {
       name="TelosNet";
       m_data=NULL;
       cur_font_size=12;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	cur_font_size=12;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=NetView;
	 el_def=0;
	 NetView @[0] {
	  name="TelosNet_View";
	  m_data=$.networks[0]$;
	  cur_font_size=12;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  annotations {
	   name="annotations";
	   el_typ=T3Annotation;
	   el_def=0;
	  };
	  annote_children {
	   name="annote_children";
	   el_typ=T3DataView;
	   el_def=0;
	  };
	  display=1;
	  lay_layout=THREE_D;
	  lay_mv=0;
	  net_text=1;
	  net_state_text {
	   name="net_state_text";
	   state_items {
	    name="state_items";
	    el_typ=NetViewStateItem;
	    el_def=0;
	    NetViewStateItem @[0] {name="batch": net_member=1: display=1: width=4: found=1: };
	    NetViewStateItem @[1] {name="epoch": net_member=1: display=1: width=4: found=1: };
	    NetViewStateItem @[2] {name="group": net_member=1: display=0: width=4: found=1: };
	    NetViewStateItem @[3] {name="trial": net_member=1: display=1: width=4: found=1: };
	    NetViewStateItem @[4] {name="tick": net_member=1: display=0: width=4: found=1: };
	    NetViewStateItem @[5] {name="cycle": net_member=1: display=1: width=4: found=1: };
	    NetViewStateItem @[6] {name="time": net_member=1: display=0: width=8: found=1: };
	    NetViewStateItem @[7] {name="total_trials": net_member=1: display=0: width=6: found=1: };
	    NetViewStateItem @[8] {name="sse": net_member=1: display=1: width=8: found=1: };
	    NetViewStateItem @[9] {name="group_name": net_member=1: display=0: width=12: found=1: };
	    NetViewStateItem @[10] {name="trial_name": net_member=1: display=1: width=12: found=1: };
	    NetViewStateItem @[11] {name="output_name": net_member=1: display=1: width=12: found=1: };
	    NetViewStateItem @[12] {name="quarter": net_member=1: display=1: width=4: found=1: };
	    NetViewStateItem @[13] {name="phase": net_member=1: display=0: width=8: found=1: };
	    NetViewStateItem @[14] {name="tot_cycle": net_member=1: display=0: width=8: found=1: };
	    NetViewStateItem @[15] {name="rt_cycles": net_member=1: display=0: width=4: found=1: };
	    NetViewStateItem @[16] {name="ext_rew": net_member=1: display=0: width=8: found=1: };
	    NetViewStateItem @[17] {name="norm_err": net_member=1: display=0: width=8: found=1: };
	    NetViewStateItem @[18] {name="cos_err": net_member=1: display=0: width=8: found=1: };
	    NetViewStateItem @[19] {name="minus_output_name": net_member=1: display=0: width=12: found=1: };
	   };
	   first_pass=0;
	  };
	  show_iconified=0;
	  cur_unit_vals{ act;	  };
	  hot_vars{ targ;ext;act;net;bias_wt;bias_dwt;act_eq;act_m;act_p;act_dif;act_avg;r.wt;r.wt*act;s.wt;r.dwt;s.dwt;gc_i;	  };
	  unit_src_path=".layers.gp[3][0][4]";
	  con_type=ANY_CON;
	  hist_idx=0;
	  hist_save=1;
	  hist_max=100;
	  hist_ff=5;
	  movie_size {x=720: y=720: };
	  unit_disp_mode=UDM_BLOCK;
	  unit_text_disp=UTD_NONE;
	  max_size {x=24: y=18: z=1.5: };
	  max_size2d {x=24: y=20: z=1: };
	  eff_max_size {x=24: y=18: z=1.5: };
	  font_sizes {net_name=0.05: net_vals=0.05: layer=0.04: layer_min=0.01: layer_vals=0.03: prjn=0.01: unit=0.02: un_nm_len=3: un_val_prec=2: };
	  view_params {xy_square=0: unit_spacing=0.05: prjn_disp=L_R_B: prjn_name=0: prjn_width=0.002: prjn_trans=0.5: lay_trans=0.5: unit_trans=0.6: laygp_width=1: show_laygp=1: };
	  wt_line_disp=0;
	  wt_line_width=4;
	  wt_line_thr=0.8;
	  wt_line_swt=1;
	  wt_prjn_k_un=3;
	  wt_prjn_k_gp=1;
	  wt_prjn_lay=.networks[0].layers.gp[3][1]$$;
	  snap_bord_disp=0;
	  snap_bord_width=4;
	  scale {
	   name="scale";
	   chunks=133;
	   min=-0;
	   max=0;
	   last_min=-1;
	   last_max=1;
	   range=0;
	   zero=0;
	   spec=.colorspecs["C_ColdHot"]$$<ColorScaleSpec,C_ColdHot>;
	   auto_scale=1;
	  };
	  scale_ranges {
	   name="scale_ranges";
	   el_typ=ScaleRange;
	   el_def=0;
	   ScaleRange @[0] {
	    var_name="act";
	    auto_scale=1;
	    min=-0;
	    max=0;
	   };
	   ScaleRange @[1] {
	    var_name="net";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[2] {
	    var_name="act_m";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[3] {
	    var_name="act_p";
	    auto_scale=1;
	    min=-0.9828457;
	    max=0.9828457;
	   };
	   ScaleRange @[4] {
	    var_name="targ";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[5] {
	    var_name="ext";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[6] {
	    var_name="act_dif";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[7] {
	    var_name="act_m2";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[8] {
	    var_name="dav";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[9] {
	    var_name="bias.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[10] {
	    var_name="bias.pdw";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[11] {
	    var_name="r.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[12] {
	    var_name="s.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[13] {
	    var_name="r.pdw";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[14] {
	    var_name="s.pdw";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[15] {
	    var_name="act_eq";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[16] {
	    var_name="act_avg";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[17] {
	    var_name="r.wt*act";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[18] {
	    var_name="r.dwt";
	    auto_scale=1;
	    min=-0;
	    max=0;
	   };
	   ScaleRange @[19] {
	    var_name="gc_i";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[20] {
	    var_name="s.dwt";
	    auto_scale=1;
	    min=-0;
	    max=0;
	   };
	  };
	  lay_disp_modes{ ActualState_Input=-1;ActualAction_Output=-1;Goal_Input=-1;WordBefore_InOut=-1;WordAction_InOut=-1;WordAfter_InOut=-1;BeforeState=-1;ActionBetween=-1;AfterState=-1;ActRelHid=-1;StateNodes=-1;ActionNodes=-1;	  };
	  selected_unit_var=;
	 };
	};
       };
       fix_name=0;
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       headlight_intensity=1;
       ambient_light=0;
       camera_params {field_of_view=45: near_distance=0.1: focal=5: far_distance=1000: };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="Full";
	 view_saved=1;
	 pos {x=0.5220015: y=1.109308: z=1.425343: };
	 orient {x=-0.9981974: y=0.05793614: z=-0.01566065: rot=0.3686481: };
	 focal_dist=2.09785;
	};
	T3SavedView @[1] {
	 name="Vw_1";
	 view_saved=1;
	 pos {x=0.5414576: y=1.556784: z=1.232045: };
	 orient {x=-0.9981974: y=0.05793614: z=-0.01566065: rot=0.3686481: };
	 focal_dist=1.890634;
	};
	T3SavedView @[2] {
	 name="Vw_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[6] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[7] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[8] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[9] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3Panel @[1] {
       name="TrialOutputData";
       m_data=NULL;
       cur_font_size=12;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	cur_font_size=12;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=T3DataViewMain;
	 el_def=0;
	 GraphTableView @[0] {
	  name="TrialOutputData_Graph";
	  m_data=$.data.gp[1][0]$;
	  cur_font_size=12;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0: y=0: z=0: }: };
	  children {
	   name="children";
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="batch";
	    m_data=.data.gp[1][0].data[0]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="epoch";
	    m_data=.data.gp[1][0].data[1]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="train_mode";
	    m_data=.data.gp[1][0].data[2]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="trial";
	    m_data=.data.gp[1][0].data[3]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[4] {
	    name="tick";
	    m_data=.data.gp[1][0].data[4]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[5] {
	    name="trial_name";
	    m_data=.data.gp[1][0].data[5]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[6] {
	    name="group_name";
	    m_data=.data.gp[1][0].data[6]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[7] {
	    name="rt_cycles";
	    m_data=.data.gp[1][0].data[7]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=-1: fix_max=0: max=53: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[8] {
	    name="sse";
	    m_data=.data.gp[1][0].data[8]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[9] {
	    name="norm_err";
	    m_data=.data.gp[1][0].data[9]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=1: max=2: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[10] {
	    name="ext_rew";
	    m_data=.data.gp[1][0].data[10]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0: y=0: z=0: }: };
	  annotations {
	   name="annotations";
	   el_typ=T3Annotation;
	   el_def=0;
	  };
	  annote_children {
	   name="annote_children";
	   el_typ=T3DataView;
	   el_def=0;
	  };
	  view_rows=10000;
	  view_range {min=0: max=-1: };
	  page_rows=2725;
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=1;
	  point_size=0.01;
	  point_spacing=1;
	  solid_lines=0;
	  bar_space=0.2;
	  bar_depth=0.01;
	  label_spacing=-1;
	  string_spacing=1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis_label_rot=0;
	  x_axis {
	   name="x_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="trial";
	   col_name_good="trial";
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=1: min=0: fix_max=1: max=49: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  z_axis {
	   name="z_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name="trial";
	   col_name_good="trial";
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  tot_plots=6;
	  plots {
	   name="plots";
	   el_typ=GraphPlotView;
	   el_def=0;
	   GraphPlotView @[0] {
	    name="TrialOutputData_Graph_plot_1";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=1;
	    axis=Y;
	    col_name="sse";
	    col_name_good="sse";
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=1: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[1] {
	    name="TrialOutputData_Graph_plot_2";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=1;
	    axis=Y;
	    col_name="norm_err";
	    col_name_good="norm_err";
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=1: max=2: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="red": r=1: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=SQUARE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[2] {
	    name="TrialOutputData_Graph_plot_3";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=DIAMOND;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[3] {
	    name="TrialOutputData_Graph_plot_4";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="ForestGreen": r=0.1333333: g=0.5450981: b=0.1333333: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=TRIANGLE_UP;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[4] {
	    name="TrialOutputData_Graph_plot_5";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="purple": r=0.5019608: g=0: b=0.5019608: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=TRIANGLE_DN;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[5] {
	    name="TrialOutputData_Graph_plot_6";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=PLUS;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	  };
	  errbars {
	   name="errbars";
	   el_typ=GraphPlotView;
	   el_def=0;
	   GraphPlotView @[0] {
	    name="TrialOutputData_Graph_err_1";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[1] {
	    name="TrialOutputData_Graph_err_2";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[2] {
	    name="TrialOutputData_Graph_err_3";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[3] {
	    name="TrialOutputData_Graph_err_4";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[4] {
	    name="TrialOutputData_Graph_err_5";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[5] {
	    name="TrialOutputData_Graph_err_6";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	  };
	  x_axis_label=;
	  y_axis_label=;
	  alt_y_axis_label=;
	  z_axis_label=;
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=FIXED;
	  color_gp_use_y=0;
	  color_axis {
	   name="color_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  colorscale {
	   name="colorscale";
	   chunks=133;
	   min=-1;
	   max=1;
	   last_min=-1;
	   last_max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs["C_ColdHot"]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name="raster_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       fix_name=0;
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       headlight_intensity=1;
       ambient_light=0;
       camera_params {field_of_view=45: near_distance=0.1: focal=5: far_distance=1000: };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="Vw_0";
	 view_saved=1;
	 pos {x=0.514375: y=0.408: z=2.327597: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=2.317597;
	};
	T3SavedView @[1] {
	 name="Vw_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="Vw_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[6] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[7] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[8] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[9] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3Panel @[2] {
       name="EpochOutputData";
       m_data=NULL;
       cur_font_size=12;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	cur_font_size=12;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=GraphTableView;
	 el_def=0;
	 GraphTableView @[0] {
	  name="EpochOutputData_Graph";
	  m_data=$.data.gp[1][1]$;
	  cur_font_size=12;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name="children";
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="batch";
	    m_data=.data.gp[1][1].data[0]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="epoch";
	    m_data=.data.gp[1][1].data[1]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=173: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="train_mode";
	    m_data=.data.gp[1][1].data[2]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="avg_sse";
	    m_data=.data.gp[1][1].data[3]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=0.52: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[4] {
	    name="cnt_err";
	    m_data=.data.gp[1][1].data[4]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=50: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[5] {
	    name="avg_norm_err";
	    m_data=.data.gp[1][1].data[5]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0.0625: fix_max=0: max=0.5: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[6] {
	    name="avg_ext_rew";
	    m_data=.data.gp[1][1].data[6]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[7] {
	    name="avg_cycles";
	    m_data=.data.gp[1][1].data[7]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[8] {
	    name="epoch_time_tot";
	    m_data=.data.gp[1][1].data[8]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[9] {
	    name="epoch_time_usr";
	    m_data=.data.gp[1][1].data[9]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[10] {
	    name="ActualAction_Output_Fm_ActionNodes_netrel";
	    m_data=.data.gp[1][1].data[10]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[11] {
	    name="BeforeState_Fm_ActRelHid_netrel";
	    m_data=.data.gp[1][1].data[11]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[12] {
	    name="ActionBetween_Fm_ActRelHid_netrel";
	    m_data=.data.gp[1][1].data[12]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[13] {
	    name="AfterState_Fm_ActRelHid_netrel";
	    m_data=.data.gp[1][1].data[13]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[14] {
	    name="AfterState_Fm_StateNodes_netrel";
	    m_data=.data.gp[1][1].data[14]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[15] {
	    name="ActRelHid_Fm_BeforeState_netrel";
	    m_data=.data.gp[1][1].data[15]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[16] {
	    name="ActRelHid_Fm_ActionBetween_netrel";
	    m_data=.data.gp[1][1].data[16]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[17] {
	    name="ActRelHid_Fm_AfterState_netrel";
	    m_data=.data.gp[1][1].data[17]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[18] {
	    name="StateNodes_Fm_StateNodes_netrel";
	    m_data=.data.gp[1][1].data[18]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[19] {
	    name="StateNodes_Fm_BeforeState_netrel";
	    m_data=.data.gp[1][1].data[19]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[20] {
	    name="StateNodes_Fm_AfterState_netrel";
	    m_data=.data.gp[1][1].data[20]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[21] {
	    name="StateNodes_Fm_ActualState_Input_netrel";
	    m_data=.data.gp[1][1].data[21]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[22] {
	    name="StateNodes_Fm_Goal_Input_netrel";
	    m_data=.data.gp[1][1].data[22]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[23] {
	    name="ActionNodes_Fm_StateNodes_netrel";
	    m_data=.data.gp[1][1].data[23]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[24] {
	    name="ActionNodes_Fm_ActionBetween_netrel";
	    m_data=.data.gp[1][1].data[24]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[25] {
	    name="netmax";
	    m_data=.data.gp[1][1].data[25]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  annotations {
	   name="annotations";
	   el_typ=T3Annotation;
	   el_def=0;
	  };
	  annote_children {
	   name="annote_children";
	   el_typ=T3DataView;
	   el_def=0;
	  };
	  view_rows=10000;
	  view_range {min=0: max=430: };
	  page_rows=200278074;
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=0.01;
	  point_spacing=1;
	  solid_lines=0;
	  bar_space=0.2;
	  bar_depth=0.01;
	  label_spacing=-1;
	  string_spacing=1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis_label_rot=0;
	  x_axis {
	   name="x_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="epoch";
	   col_name_good="epoch";
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=430: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  z_axis {
	   name="z_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name="batch";
	   col_name_good="batch";
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  tot_plots=6;
	  plots {
	   name="plots";
	   el_typ=GraphPlotView;
	   el_def=0;
	   GraphPlotView @[0] {
	    name="EpochOutputData_Graph_plot_1";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name="avg_sse";
	    col_name_good="avg_sse";
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=0.52: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[1] {
	    name="EpochOutputData_Graph_plot_2";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name="avg_norm_err";
	    col_name_good="avg_norm_err";
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0.0625: fix_max=0: max=0.5: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="red": r=1: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=SQUARE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[2] {
	    name="EpochOutputData_Graph_plot_3";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=1;
	    axis=Y;
	    col_name="cnt_err";
	    col_name_good="cnt_err";
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=50: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=DIAMOND;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[3] {
	    name="EpochOutputData_Graph_plot_4";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="ForestGreen": r=0.1333333: g=0.5450981: b=0.1333333: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=TRIANGLE_UP;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[4] {
	    name="EpochOutputData_Graph_plot_5";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="purple": r=0.5019608: g=0: b=0.5019608: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=TRIANGLE_DN;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[5] {
	    name="EpochOutputData_Graph_plot_6";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=PLUS;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	  };
	  errbars {
	   name="errbars";
	   el_typ=GraphPlotView;
	   el_def=0;
	   GraphPlotView @[0] {
	    name="EpochOutputData_Graph_err_1";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[1] {
	    name="EpochOutputData_Graph_err_2";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[2] {
	    name="EpochOutputData_Graph_err_3";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[3] {
	    name="EpochOutputData_Graph_err_4";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[4] {
	    name="EpochOutputData_Graph_err_5";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[5] {
	    name="EpochOutputData_Graph_err_6";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	  };
	  x_axis_label=;
	  y_axis_label=;
	  alt_y_axis_label=;
	  z_axis_label=;
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=FIXED;
	  color_gp_use_y=0;
	  color_axis {
	   name="color_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  colorscale {
	   name="colorscale";
	   chunks=133;
	   min=-1;
	   max=1;
	   last_min=-1;
	   last_max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs["C_ColdHot"]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name="raster_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       fix_name=0;
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       headlight_intensity=1;
       ambient_light=0;
       camera_params {field_of_view=45: near_distance=0.1: focal=5: far_distance=1000: };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="Vw_0";
	 view_saved=1;
	 pos {x=1.475278: y=0.4989999: z=1.70049: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.71299;
	};
	T3SavedView @[1] {
	 name="Vw_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="Vw_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[6] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[7] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[8] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[9] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name="docks";
    el_typ=ToolBoxDockViewer;
    el_def=0;
    ToolBoxDockViewer @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {name="view_win_lft": value=0: val_type_fixed=0: };
      UserDataItem @[1] {name="view_win_top": value=0.02629017: val_type_fixed=0: };
      UserDataItem @[2] {name="view_win_wd": value=0.05: val_type_fixed=0: };
      UserDataItem @[3] {name="view_win_ht": value=0.7594936: val_type_fixed=0: };
      UserDataItem @[4] {name="view_win_iconified": value=0: val_type_fixed=0: };
      UserDataItem @[5] {name="view_visible": value=1: val_type_fixed=0: };
     };
     name="Tools";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     win_name=;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 save_view=1;
 save_as_only=0;
 auto_name=1;
 last_change_desc="* everything is now in Layer_Groups and spec groups, for portability between projects
* integrated highvis model for objrec, with separate img filtering pathways, etc
* two 'ticks' per trial: fixate, then recognize -- RobotTrial coordinates -- other progs conditionalize on network.tick
* objs_per_epc in lesson -- only present a limited # of objects per epoch repeatedly over the lesson -- makes the carousel much more efficient
  this is all impl in the new Build_Presentation_Robot
* need to change camera fov for objrec -- not enough resolution for fovea otherwise
* added load_0_epc in lesson -- reinit network.epoch after loading weights -- we load pretrained eye weights, but want to start counter over..
";
 tree_state{ .;.ctrl_panels;.ctrl_panels[0];.ctrl_panels[0].mths;.data;.data.gp[0];.data.gp[1];.data.gp[3];.data.gp[3][0];.programs;.programs.gp[0];.programs.gp[1];.programs.gp[1].gp[0];.programs.gp[1].gp[1];.programs.gp[2];.programs.gp[2].gp[0];.programs.gp[2].gp[1];.programs.gp[3];.programs.gp[4];.programs.gp[4].gp[0];.networks;.networks[0];.networks[0].specs;.networks[0].specs[4];.networks[0].specs[8];.networks[0].specs[9];.networks[0].specs[20];.networks[0].layers;.networks[0].layers.gp[0];.networks[0].layers.gp[0][0];.networks[0].layers.gp[0][1];.networks[0].layers.gp[0][1].projections;.networks[0].layers.gp[0][2];.networks[0].layers.gp[1];.networks[0].layers.gp[1][0];.networks[0].layers.gp[1][0].projections;.networks[0].layers.gp[1][1];.networks[0].layers.gp[1][1].projections;.networks[0].layers.gp[1][2];.networks[0].layers.gp[1][2].projections;.networks[0].layers.gp[2];.networks[0].layers.gp[2][0];.networks[0].layers.gp[2][0].projections;.networks[0].layers.gp[2][1];.networks[0].layers.gp[2][1].projections;.networks[0].layers.gp[2][2];.networks[0].layers.gp[2][2].projections;.networks[0].layers.gp[2][3];.networks[0].layers.gp[2][3].projections;.networks[0].layers.gp[3];.networks[0].layers.gp[3][0];.networks[0].layers.gp[3][0].projections;.networks[0].layers.gp[3][1];.networks[0].layers.gp[3][1].projections;.networks[0].layers.gp[4]; };
 networks {
  name="networks";
  el_typ=LeabraNetwork;
  el_def=0;
  LeabraNetwork @[0] {
   name="TelosNet";
   desc="\"Begin with the end in mind.\"  -Stephen Covey";
   flags=BUILD_INIT_WTS;
   train_mode=TEST;
   wt_update=ON_LINE;
   small_batch_n=10;
   stats {sse_unit_avg=0: sse_sqrt=0: cnt_err_tol=0: prerr=0: };
   n_units=174;
   n_cons=5799;
   max_prjns=5;
   specs {
    name="specs";
    el_typ=LeabraUnitSpec;
    el_def=0;
    LeabraUnitSpec @[0] {
     name="LeabraUnitSpec_0";
     is_used=1;
     used_status=USED;
     desc="NONSTD PARAMS:";
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=LeabraUnitSpec;
      el_def=0;
     };
     bias_spec {type=LeabraBiasSpec: spec=.networks[0].specs[8].children[0]$$: };
     act_range {min=0: max=1: range=1: scale=1: };
     sse_tol=0.5;
     act_fun=NOISY_XX1;
     act {thr=0.5: gain=80: nvar=0.005: avg_correct=1: vm_act_thr=0.01: sig_mult=0.33: sig_mult_pow=0.8: sig_gain=3: interp_range=0.01: gain_cor_range=10: gain_cor=0.1: sig_gain_nvar=600: sig_mult_eff=0.1585484: sig_val_at_0=0.07927421: interp_val=0.3446889: };
     act_misc {rec_nd=1: avg_nd=1: dif_avg=0: net_gain=1: avg_trace=0: lambda=0: avg_tau=200: avg_init=0.15: avg_dt=0.005: };
     spike {rise=0: decay=5: g_gain=5: window=3: act_max_hz=180: int_tau=5: int_dt=0.2: };
     spike_misc {ex=0: exp_slope=0.02: spk_thr=1.2: vm_r=0.3: t_r=6: clamp_max_p=0.11: clamp_type=REGULAR: eff_spk_thr=0.5: };
     opt_thresh {send=0.1: delta=0.005: };
     clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
     vm_range {min=0: max=1: range=1: scale=1: };
     init {v_m=0.4: act=0: netin=0: };
     dt {integ=1: vm_tau=4: net_tau=2: vm_cyc=1: fast_cyc=0: vm_dt=0.25: vm_dt_cyc=0.25: net_dt=0.5: };
     act_avg {ss_tau=4: s_tau=2: m_tau=10: m_in_s=0.1: ss_dt=0.25: s_dt=0.5: m_dt=0.1: s_in_s=0.9: };
     avg_l {init=0.4: gain=2.5: min=0.2: tau=10: lrn_max=0.5: lrn_min=0.0001: dt=0.1: lrn_fact=0.2173478: };
     avg_l_2 {err_mod=1: err_min=0.01: lay_act_thr=0.01: };
     g_bar {e=1: l=0.1: i=1: k=0.2: };
     e_rev {e=1: l=0.15: i=0.15: k=0.1: };
     kna_adapt {on=0: rate_rise=0.8: f_on=1: f_rise=0.05: f_max=0.1: f_tau=50: m_on=1: m_rise=0.02: m_max=0.1: m_tau=200: s_on=1: s_rise=0.001: s_max=1: s_tau=1000: f_dt=0.02: m_dt=0.005: s_dt=0.001: };
     kna_misc {clamp=1: invert_nd=1: max_gc=0.2: max_adapt=0.3: no_targ=1: };
     stp {on=0: algorithm=CYCLES: f_r_ratio=0.02: rec_tau=200: p0=0.2: p0_norm=0.2: kre_tau=100: kre=0.002: fac_tau=4: fac=0.3: thresh=0.5: n_trials=1: rec_prob=0.1: rec_dt=0.005: fac_dt=0.25: kre_dt=0.01: oneo_p0_norm=5: };
     syn_delay {on=0: delay=4: };
     deep_raw_qtr=Q4;
     deep {on=0: role=SUPER: raw_thr_rel=0.1: raw_thr_abs=0.1: mod_min=0.8: mod_thr=0.1: ctxt_prv=0: tick_updt=-1: else_prv=0.9: mod_range=0.2: ctxt_new=1: else_new=0.1: };
     trc {p_only_m=0: thal_gate=0: clamp_net=0: avg_clamp=0: deep_gain=0.2: clip=0: clip_max=0.4: std_gain=0.8: };
     da_mod {on=0: mod_gain=0: minus=0: plus=0.1: da_neg_gain=0.1: da_pos_gain=0.1: };
     noise_type {type=NO_NOISE: trial_fixed=1: };
     noise {name="noise": type=GAUSSIAN: mean=0: var=0.001: par=1: };
    };
    LeabraLayerSpec @[1] {
     name="LeabraLayerSpec_0";
     is_used=0;
     used_status=UNUSED;
     desc=;
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=LeabraLayerSpec;
      el_def=0;
     };
     lay_inhib {on=1: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     unit_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     lay_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     avg_act {targ_init=0.15: fixed=0: use_ext_act=0: use_first=1: tau=100: adjust=1: dt=0.01: };
     inhib_adapt {on=0: tol_pct=0.25: trial_interval=100: tau=200: dt=0.005: };
     inhib_misc {net_thr=0: thr_rel=1: self_fb=0: self_tau=1.4: fb_up_immed=0: self_dt=0.7142857: };
     clamp {hard=1: gain=0.2: avg=0: avg_gain=0.2: };
     decay {trial=1: };
     del_inhib {on=0: prv_trl=0: prv_q=0: };
     margin {pct_marg=0.3: avg_tau=100: adapt_tau=500: tol_pct=0.25: avg_act=0.8: low_thr=0.501: med_thr=0.506: hi_thr=0.508: avg_dt=0.01: adapt_dt=0.002: };
     lay_lrate=1;
     cos_diff {avg_tau=100: lrate_mod=0: lrmod_fm_trc=0: lrmod_z_thr=-1.5: set_net_unlrn=0: avg_dt=0.01: avg_dt_c=0.99: };
     lstats {pre_hog_thr=0.2: hog_thr=0.3: dead_thr=0.01: };
    };
    LeabraLayerSpec @[2] {
     name="SemAssocLayerSpec_State";
     is_used=1;
     used_status=USED;
     desc="lay_inhib.fb = 1; 0.5 pretty good!";
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=LeabraLayerSpec;
      el_def=0;
     };
     lay_inhib {on=1: gi=1.4: ff=1: fb=0.5: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     unit_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     lay_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     avg_act {targ_init=0.15: fixed=0: use_ext_act=0: use_first=1: tau=100: adjust=1: dt=0.01: };
     inhib_adapt {on=0: tol_pct=0.25: trial_interval=100: tau=200: dt=0.005: };
     inhib_misc {net_thr=0: thr_rel=1: self_fb=0: self_tau=1.4: fb_up_immed=0: self_dt=0.7142857: };
     clamp {hard=1: gain=0.2: avg=0: avg_gain=0.2: };
     decay {trial=1: };
     del_inhib {on=0: prv_trl=0: prv_q=0: };
     margin {pct_marg=0.3: avg_tau=100: adapt_tau=500: tol_pct=0.25: avg_act=0.8: low_thr=0.501: med_thr=0.506: hi_thr=0.508: avg_dt=0.01: adapt_dt=0.002: };
     lay_lrate=1;
     cos_diff {avg_tau=100: lrate_mod=0: lrmod_fm_trc=0: lrmod_z_thr=-1.5: set_net_unlrn=0: avg_dt=0.01: avg_dt_c=0.99: };
     lstats {pre_hog_thr=0.2: hog_thr=0.3: dead_thr=0.01: };
    };
    LeabraLayerSpec @[3] {
     name="SemAssocLayerSpec_Action";
     is_used=1;
     used_status=USED;
     desc=;
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=LeabraLayerSpec;
      el_def=0;
     };
     lay_inhib {on=1: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     unit_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     lay_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     avg_act {targ_init=0.15: fixed=0: use_ext_act=0: use_first=1: tau=100: adjust=1: dt=0.01: };
     inhib_adapt {on=0: tol_pct=0.25: trial_interval=100: tau=200: dt=0.005: };
     inhib_misc {net_thr=0: thr_rel=1: self_fb=0: self_tau=1.4: fb_up_immed=0: self_dt=0.7142857: };
     clamp {hard=1: gain=0.2: avg=0: avg_gain=0.2: };
     decay {trial=1: };
     del_inhib {on=0: prv_trl=0: prv_q=0: };
     margin {pct_marg=0.3: avg_tau=100: adapt_tau=500: tol_pct=0.25: avg_act=0.8: low_thr=0.501: med_thr=0.506: hi_thr=0.508: avg_dt=0.01: adapt_dt=0.002: };
     lay_lrate=1;
     cos_diff {avg_tau=100: lrate_mod=0: lrmod_fm_trc=0: lrmod_z_thr=-1.5: set_net_unlrn=0: avg_dt=0.01: avg_dt_c=0.99: };
     lstats {pre_hog_thr=0.2: hog_thr=0.3: dead_thr=0.01: };
    };
    LeabraLayerSpec @[4] {
     name="HiddenLayer";
     is_used=1;
     used_status=USED;
     desc="lay_inhib.gi = 1.5 (experimental); 1.8 (default)";
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=LeabraLayerSpec;
      el_def=0;
      LeabraLayerSpec @[0] {
       name="Input_Output";
       is_used=1;
       used_status=USED;
       desc=;
       unique{ lay_inhib;kwta;clamp;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       lay_inhib {on=1: gi=1.5: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
       unit_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
       lay_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
       avg_act {targ_init=0.15: fixed=0: use_ext_act=0: use_first=1: tau=100: adjust=1: dt=0.01: };
       inhib_adapt {on=0: tol_pct=0.25: trial_interval=100: tau=200: dt=0.005: };
       inhib_misc {net_thr=0: thr_rel=1: self_fb=0: self_tau=1.4: fb_up_immed=0: self_dt=0.7142857: };
       clamp {hard=1: gain=0.2: avg=0: avg_gain=0.2: };
       decay {trial=1: };
       del_inhib {on=0: prv_trl=0: prv_q=0: };
       margin {pct_marg=0.3: avg_tau=100: adapt_tau=500: tol_pct=0.25: avg_act=0.8: low_thr=0.501: med_thr=0.506: hi_thr=0.508: avg_dt=0.01: adapt_dt=0.002: };
       lay_lrate=1;
       cos_diff {avg_tau=100: lrate_mod=0: lrmod_fm_trc=0: lrmod_z_thr=-1.5: set_net_unlrn=0: avg_dt=0.01: avg_dt_c=0.99: };
       lstats {pre_hog_thr=0.2: hog_thr=0.3: dead_thr=0.01: };
      };
     };
     lay_inhib {on=1: gi=1.4: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     unit_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     lay_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     avg_act {targ_init=0.15: fixed=0: use_ext_act=0: use_first=1: tau=100: adjust=1: dt=0.01: };
     inhib_adapt {on=0: tol_pct=0.25: trial_interval=100: tau=200: dt=0.005: };
     inhib_misc {net_thr=0: thr_rel=1: self_fb=0: self_tau=1.4: fb_up_immed=0: self_dt=0.7142857: };
     clamp {hard=1: gain=0.2: avg=0: avg_gain=0.2: };
     decay {trial=1: };
     del_inhib {on=0: prv_trl=0: prv_q=0: };
     margin {pct_marg=0.3: avg_tau=100: adapt_tau=500: tol_pct=0.25: avg_act=0.8: low_thr=0.501: med_thr=0.506: hi_thr=0.508: avg_dt=0.01: adapt_dt=0.002: };
     lay_lrate=1;
     cos_diff {avg_tau=100: lrate_mod=0: lrmod_fm_trc=0: lrmod_z_thr=-1.5: set_net_unlrn=0: avg_dt=0.01: avg_dt_c=0.99: };
     lstats {pre_hog_thr=0.2: hog_thr=0.3: dead_thr=0.01: };
    };
    LeabraLayerSpec @[5] {
     name="Hidden_localist";
     is_used=1;
     used_status=PARENT_USED;
     desc="k=1 kwta; lay_inhib.gi = 1.8 (default); 1.6 (experimental)";
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=LeabraLayerSpec;
      el_def=0;
      LeabraLayerSpec @[0] {
       name="Input_Output";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ lay_inhib;kwta;clamp;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       lay_inhib {on=1: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
       unit_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
       lay_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
       avg_act {targ_init=0.15: fixed=0: use_ext_act=0: use_first=1: tau=100: adjust=1: dt=0.01: };
       inhib_adapt {on=0: tol_pct=0.25: trial_interval=100: tau=200: dt=0.005: };
       inhib_misc {net_thr=0: thr_rel=1: self_fb=0: self_tau=1.4: fb_up_immed=0: self_dt=0.7142857: };
       clamp {hard=1: gain=0.2: avg=0: avg_gain=0.2: };
       decay {trial=1: };
       del_inhib {on=0: prv_trl=0: prv_q=0: };
       margin {pct_marg=0.3: avg_tau=100: adapt_tau=500: tol_pct=0.25: avg_act=0.8: low_thr=0.501: med_thr=0.506: hi_thr=0.508: avg_dt=0.01: adapt_dt=0.002: };
       lay_lrate=1;
       cos_diff {avg_tau=100: lrate_mod=0: lrmod_fm_trc=0: lrmod_z_thr=-1.5: set_net_unlrn=0: avg_dt=0.01: avg_dt_c=0.99: };
       lstats {pre_hog_thr=0.2: hog_thr=0.3: dead_thr=0.01: };
      };
     };
     lay_inhib {on=1: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     unit_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     lay_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     avg_act {targ_init=0.15: fixed=0: use_ext_act=0: use_first=1: tau=100: adjust=1: dt=0.01: };
     inhib_adapt {on=0: tol_pct=0.25: trial_interval=100: tau=200: dt=0.005: };
     inhib_misc {net_thr=0: thr_rel=1: self_fb=0: self_tau=1.4: fb_up_immed=0: self_dt=0.7142857: };
     clamp {hard=1: gain=0.2: avg=0: avg_gain=0.2: };
     decay {trial=1: };
     del_inhib {on=0: prv_trl=0: prv_q=0: };
     margin {pct_marg=0.3: avg_tau=100: adapt_tau=500: tol_pct=0.25: avg_act=0.8: low_thr=0.501: med_thr=0.506: hi_thr=0.508: avg_dt=0.01: adapt_dt=0.002: };
     lay_lrate=1;
     cos_diff {avg_tau=100: lrate_mod=0: lrmod_fm_trc=0: lrmod_z_thr=-1.5: set_net_unlrn=0: avg_dt=0.01: avg_dt_c=0.99: };
     lstats {pre_hog_thr=0.2: hog_thr=0.3: dead_thr=0.01: };
    };
    FullPrjnSpec @[6] {
     name="FullPrjnSpec_0";
     is_used=1;
     used_status=USED;
     desc=;
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=FullPrjnSpec;
      el_def=0;
     };
     self_con=0;
     init_wts=0;
     set_scale=0;
     init_wt_val=1;
     add_rnd_var=0;
     renorm_wts {on=0: mult_norm=1: avg_wt=0.5: };
    };
    OneToOnePrjnSpec @[7] {
     name="OneToOnePrjnSpec_0";
     is_used=1;
     used_status=USED;
     desc=;
     unique{ self_con;     };
     saved{      };
     children {
      name="children";
      el_typ=OneToOnePrjnSpec;
      el_def=0;
     };
     self_con=1;
     init_wts=0;
     set_scale=0;
     init_wt_val=1;
     add_rnd_var=0;
     renorm_wts {on=0: mult_norm=1: avg_wt=0.5: };
     n_conns=-1;
     recv_start=0;
     send_start=0;
     use_gp=0;
    };
    LeabraConSpec @[8] {
     name="LeabraConSpec_0";
     is_used=0;
     used_status=CHILD_USED;
     desc=;
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=1;
       used_status=USED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.002;
       cur_lrate=0.002;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.002;
     cur_lrate=2e-5;
     lrs_mult=0.01;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[9] {
     name="ToActRelHidConSpec";
     is_used=1;
     used_status=USED;
     desc=;
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=0.8: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.002;
     cur_lrate=0.002;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=0;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[10] {
     name="FmActRelHidConSpec_toBeforeState";
     is_used=1;
     used_status=USED;
     desc=;
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1.5: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.002;
     cur_lrate=0.002;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=0;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[11] {
     name="FmActRelHidConSpec_toAfterState";
     is_used=1;
     used_status=USED;
     desc=;
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=2: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.002;
     cur_lrate=0.002;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=0;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[12] {
     name="FmActRelHidConSpec_toActionBetween";
     is_used=1;
     used_status=USED;
     desc=;
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1.2: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.002;
     cur_lrate=0.002;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=0;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[13] {
     name="LeabStrongConSpec";
     is_used=0;
     used_status=UNUSED;
     desc=;
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.002;
       cur_lrate=0.002;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.002;
     cur_lrate=0.002;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[14] {
     name="LeabWeakConSpec";
     is_used=0;
     used_status=UNUSED;
     desc=;
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.002;
       cur_lrate=0.002;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.002;
     cur_lrate=0.002;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[15] {
     name="SelfConSpec";
     is_used=1;
     used_status=PARENT_USED;
     desc=;
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.02;
       cur_lrate=0.02;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.02;
     cur_lrate=0.02;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[16] {
     name="NoVarConSpec_State";
     is_used=1;
     used_status=PARENT_USED;
     desc="rnd.mean = 0.5; wt_scale.abs = 3";
     unique{ wt_limits;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.04;
       cur_lrate=0.02;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=0: set_l_lrn=1: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.04;
     cur_lrate=0.04;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=0: set_l_lrn=1: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[17] {
     name="NoVarConSpec_Action";
     is_used=1;
     used_status=PARENT_USED;
     desc=;
     unique{ wt_limits;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.04;
       cur_lrate=0.02;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=3: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.04;
     cur_lrate=0.04;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[18] {
     name="NoVarConSpec_ActRel";
     is_used=1;
     used_status=PARENT_USED;
     desc=;
     unique{ wt_limits;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.004;
       cur_lrate=0.02;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=2: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.004;
     cur_lrate=0.002;
     lrs_mult=0.5;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[19] {
     name="NoVarMidNoLrnConSpec";
     is_used=1;
     used_status=PARENT_USED;
     desc=;
     unique{ wt_limits;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0;
       cur_lrate=0.02;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0;
     cur_lrate=0;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[20] {
     name="NoVarMidNoLrnConSpec_Word_InOut";
     is_used=1;
     used_status=USED;
     desc=;
     unique{ wt_limits;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
     };
     rnd {name="rnd": type=UNIFORM: mean=0.95: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0;
     cur_lrate=0;
     lrs_mult=0.01;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[21] {
     name="NoVarMidWeakConSpec";
     is_used=0;
     used_status=UNUSED;
     desc=;
     unique{ wt_limits;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.02;
       cur_lrate=0.02;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1: rel=0.2: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.02;
     cur_lrate=0.02;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[22] {
     name="NoVarMidWeaker4FBConSpec";
     is_used=0;
     used_status=UNUSED;
     desc=;
     unique{ wt_limits;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.02;
       cur_lrate=0.02;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1: rel=0.1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.02;
     cur_lrate=0.02;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[23] {
     name="NoVarFmConstantInput";
     is_used=0;
     used_status=UNUSED;
     desc="constant input to increase netin to compensate for no RelationEngine input";
     unique{ wt_limits;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.02;
       cur_lrate=0.02;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=0.5: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.02;
     cur_lrate=0.02;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[24] {
     name="NoVarStrongConSpec";
     is_used=0;
     used_status=UNUSED;
     desc=;
     unique{ wt_limits;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.02;
       cur_lrate=0.02;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.95: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.02;
     cur_lrate=0.02;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[25] {
     name="NoVarStrongNoLrnConSpec";
     is_used=1;
     used_status=PARENT_USED;
     desc=;
     unique{ wt_limits;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0;
       cur_lrate=0.02;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.95: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0;
     cur_lrate=0;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[26] {
     name="NoVarMidNoLrnWeakConSpec";
     is_used=1;
     used_status=PARENT_USED;
     desc=;
     unique{ wt_limits;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0;
       cur_lrate=0.02;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1: rel=0.95: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0;
     cur_lrate=0;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[27] {
     name="NoVarMidNoLrnLessWeakConSpec";
     is_used=0;
     used_status=UNUSED;
     desc=;
     unique{ wt_limits;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0;
       cur_lrate=0.02;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1: rel=0.75: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0;
     cur_lrate=0;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[28] {
     name="NoVarNoLrnConSpec_FB";
     is_used=0;
     used_status=UNUSED;
     desc=;
     unique{ wt_limits;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0;
       cur_lrate=0.02;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.95: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1: rel=0.1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0;
     cur_lrate=0;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[29] {
     name="NoVarWeakConSpec";
     is_used=0;
     used_status=UNUSED;
     desc=;
     unique{ wt_limits;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.02;
       cur_lrate=0.02;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.95: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=0.1: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.02;
     cur_lrate=0.01;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[30] {
     name="NoVarSelfConSpec";
     is_used=1;
     used_status=PARENT_USED;
     desc=;
     unique{ wt_limits;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.02;
       cur_lrate=0.02;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=0.1: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.02;
     cur_lrate=0.02;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
    LeabraConSpec @[31] {
     name="NoVarFmGoalNoLrnConSpec";
     is_used=1;
     used_status=PARENT_USED;
     desc=;
     unique{ wt_limits;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0;
       cur_lrate=0.02;
       lrs_mult=1;
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1.25: soft_bound=1: };
       momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.95: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=0.5: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0;
     cur_lrate=0;
     lrs_mult=1;
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: lrn_thr=0.01: s_mult=1: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1.25: soft_bound=1: };
     momentum {on=0: dwavg_tau=1000: norm_min=0.001: m_tau=20: lrate_comp=0.01: dwavg_dt=0.001: dwavg_dt_c=0.999: m_dt=0.05: m_dt_c=0.95: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
    };
   };
   param_seqs {
    name="param_seqs";
    el_typ=ParamSeq;
    el_def=0;
   };
   monitor {
    name="monitor";
    items {
     name="items";
     el_typ=NetMonItem;
     el_def=0;
     ignore_sig=0;
    };
    network=$.networks[0]$;
    data=.networks[0].mon_data$$;
    rmv_orphan_cols=1;
   };
   mon_data {
    name="mon_data";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   layers {
    name="layers";
    el_typ=LeabraLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    pos2d {x=0: y=0: };
    max_disp_size {x=24: y=18: z=2: };
    max_disp_size2d {x=24: y=20: };
    Layer_Group @.gp[0] {
     name="Actual_InOut";
     el_typ=LeabraLayer;
     el_def=0;
     pos {x=0: y=0: z=0: };
     pos2d {x=0: y=0: };
     max_disp_size {x=12: y=7: z=1: };
     max_disp_size2d {x=12: y=7: };
     LeabraLayer @[0] {
      name="ActualState_Input";
      n_recv_prjns=0;
      n_send_prjns=1;
      un_geom_x=13;
      un_geom_y=1;
      un_geom_n=13;
      gp_geom_x=1;
      gp_geom_y=1;
      gp_geom_n=1;
      flat_geom_x=13;
      flat_geom_y=1;
      flat_geom_n=13;
      gp_spc_x=1;
      gp_spc_y=1;
      flags=NO_ADD_SSE;
      layer_type=INPUT;
      desc=;
      pos_rel {rel=ABS_POS: other=NULL: x_align=LEFT: x_off=0: y_align=FRONT: y_off=0: space=2: };
      pos {x=0: y=0: z=0: };
      pos_abs {x=0: y=0: z=0: };
      pos2d {x=0: y=0: };
      pos2d_abs {x=0: y=0: };
      disp_scale=0.85;
      un_geom {x=13: y=1: n_not_xy=0: n=13: };
      unit_groups=0;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      flat_geom {x=13: y=1: n_not_xy=0: n=13: };
      disp_geom {x=13: y=1: n_not_xy=0: n=13: };
      scaled_disp_geom {x=12: y=1: n_not_xy=0: n=12: };
      projections {
       name="projections";
       el_typ=LeabraPrjn;
       el_def=0;
      };
      send_prjns {
       name="send_prjns";
       el_typ=LeabraPrjn;
       el_def=0;
       Projection_List @. = [0] = LeabraPrjn .networks[0].layers.gp[2][0].projections[4];
       Projection_List @. = [1] = LeabraPrjn .networks[0].layers.gp[3][0].projections[5];
      };
      unit_spec {type=LeabraUnitSpec: spec=.networks[0].specs[0]$$: };
      dist {fm_input=0: fm_output=3: };
      units_lesioned=0;
      gp_unit_names_4d=0;
      brain_area=;
      voxel_fill_pct=1;
      spec {type=LeabraLayerSpec: spec=.networks[0].specs[4].children[0]$$: };
      adapt_gi=1;
      acts_m_avg=0.15;
      acts_p_avg=0.15;
      acts_p_avg_eff=0.15;
     };
     LeabraLayer @[1] {
      name="ActualAction_Output";
      n_recv_prjns=1;
      n_send_prjns=0;
      un_geom_x=12;
      un_geom_y=1;
      un_geom_n=12;
      gp_geom_x=1;
      gp_geom_y=1;
      gp_geom_n=1;
      flat_geom_x=12;
      flat_geom_y=1;
      flat_geom_n=12;
      gp_spc_x=1;
      gp_spc_y=1;
      flags=PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
      layer_type=OUTPUT;
      desc=;
      pos_rel {rel=BEHIND: other=$.networks[0].layers.gp[0][2]$: x_align=RIGHT: x_off=0: y_align=FRONT: y_off=0: space=2: };
      pos {x=1: y=6: z=0: };
      pos_abs {x=1: y=6: z=0: };
      pos2d {x=1: y=6: };
      pos2d_abs {x=1: y=6: };
      disp_scale=0.85;
      un_geom {x=12: y=1: n_not_xy=0: n=12: };
      unit_groups=0;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      flat_geom {x=12: y=1: n_not_xy=0: n=12: };
      disp_geom {x=12: y=1: n_not_xy=0: n=12: };
      scaled_disp_geom {x=11: y=1: n_not_xy=0: n=11: };
      projections {
       name="projections";
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_ActionNodes";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[3][1]$;
	spec {type=OneToOnePrjnSpec: spec=.networks[0].specs[7]$$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=.networks[0].specs[25]$$: };
	dir_fixed=0;
	direction=FM_INPUT;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[1] {
	name="Fm_ActionBetween";
	off=1;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=.networks[0].layers.gp[2][1]$$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[25]$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
      };
      send_prjns {
       name="send_prjns";
       el_typ=LeabraPrjn;
       el_def=0;
      };
      unit_spec {type=LeabraUnitSpec: spec=$.networks[0].specs[0]$: };
      dist {fm_input=3: fm_output=0: };
      units_lesioned=0;
      gp_unit_names_4d=0;
      brain_area=;
      voxel_fill_pct=1;
      spec {type=LeabraLayerSpec: spec=$.networks[0].specs[4].children[0]$: };
      adapt_gi=1;
      acts_m_avg=0.15;
      acts_p_avg=0.15;
      acts_p_avg_eff=0.15;
     };
     LeabraLayer @[2] {
      name="Goal_Input";
      n_recv_prjns=0;
      n_send_prjns=1;
      un_geom_x=13;
      un_geom_y=1;
      un_geom_n=13;
      gp_geom_x=1;
      gp_geom_y=1;
      gp_geom_n=1;
      flat_geom_x=13;
      flat_geom_y=1;
      flat_geom_n=13;
      gp_spc_x=1;
      gp_spc_y=1;
      flags=NO_ADD_SSE;
      layer_type=INPUT;
      desc=;
      pos_rel {rel=BEHIND: other=$.networks[0].layers.gp[0][0]$: x_align=LEFT: x_off=0: y_align=FRONT: y_off=0: space=2: };
      pos {x=0: y=3: z=0: };
      pos_abs {x=0: y=3: z=0: };
      pos2d {x=0: y=3: };
      pos2d_abs {x=0: y=3: };
      disp_scale=0.85;
      un_geom {x=13: y=1: n_not_xy=0: n=13: };
      unit_groups=0;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      flat_geom {x=13: y=1: n_not_xy=0: n=13: };
      disp_geom {x=13: y=1: n_not_xy=0: n=13: };
      scaled_disp_geom {x=12: y=1: n_not_xy=0: n=12: };
      projections {
       name="projections";
       el_typ=LeabraPrjn;
       el_def=0;
      };
      send_prjns {
       name="send_prjns";
       el_typ=LeabraPrjn;
       el_def=0;
       Projection_List @. = [0] = LeabraPrjn .networks[0].layers.gp[2][2].projections[1];
       Projection_List @. = [1] = LeabraPrjn .networks[0].layers.gp[3][0].projections[6];
      };
      unit_spec {type=LeabraUnitSpec: spec=$.networks[0].specs[0]$: };
      dist {fm_input=0: fm_output=3: };
      units_lesioned=0;
      gp_unit_names_4d=0;
      brain_area=;
      voxel_fill_pct=1;
      spec {type=LeabraLayerSpec: spec=$.networks[0].specs[4].children[0]$: };
      adapt_gi=1;
      acts_m_avg=0.15;
      acts_p_avg=0.15;
      acts_p_avg_eff=0.15;
     };
    };
    Layer_Group @.gp[1] {
     name="WordInOut";
     el_typ=LeabraLayer;
     el_def=0;
     pos {x=14: y=0: z=0: };
     pos2d {x=14: y=0: };
     max_disp_size {x=1: y=5: z=1: };
     max_disp_size2d {x=1: y=5: };
     LeabraLayer @[0] {
      name="WordBefore_InOut";
      n_recv_prjns=0;
      n_send_prjns=0;
      un_geom_x=13;
      un_geom_y=1;
      un_geom_n=13;
      gp_geom_x=1;
      gp_geom_y=1;
      gp_geom_n=1;
      flat_geom_x=13;
      flat_geom_y=1;
      flat_geom_n=13;
      gp_spc_x=1;
      gp_spc_y=1;
      flags=LESIONED|ICONIFIED|PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
      layer_type=INPUT;
      desc=;
      pos_rel {rel=RIGHT_OF: other=$.networks[0].layers.gp[0][0]$: x_align=LEFT: x_off=0: y_align=FRONT: y_off=0: space=2: };
      pos {x=0: y=0: z=0: };
      pos_abs {x=14: y=0: z=0: };
      pos2d {x=0: y=0: };
      pos2d_abs {x=14: y=0: };
      disp_scale=0.85;
      un_geom {x=13: y=1: n_not_xy=0: n=13: };
      unit_groups=0;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      flat_geom {x=13: y=1: n_not_xy=0: n=13: };
      disp_geom {x=13: y=1: n_not_xy=0: n=13: };
      scaled_disp_geom {x=12: y=1: n_not_xy=0: n=12: };
      projections {
       name="projections";
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_BeforeState";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=.networks[0].layers.gp[2][0]$$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=.networks[0].specs[20]$$: };
	dir_fixed=0;
	direction=FM_INPUT;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[1] {
	name="Fm_StateNodes";
	off=1;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=.networks[0].layers.gp[3][0]$$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=.networks[0].specs[19]$$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
      };
      send_prjns {
       name="send_prjns";
       el_typ=LeabraPrjn;
       el_def=0;
       Projection_List @. = [0] = LeabraPrjn .networks[0].layers.gp[2][0].projections[0];
       Projection_List @. = [1] = LeabraPrjn .networks[0].layers.gp[3][0].projections[7];
      };
      unit_spec {type=LeabraUnitSpec: spec=$.networks[0].specs[0]$: };
      dist {fm_input=4: fm_output=0: };
      units_lesioned=0;
      gp_unit_names_4d=0;
      brain_area=;
      voxel_fill_pct=1;
      spec {type=LeabraLayerSpec: spec=$.networks[0].specs[4].children[0]$: };
      adapt_gi=1;
      acts_m_avg=0.07394415;
      acts_p_avg=0.07307729;
      acts_p_avg_eff=0.07307729;
     };
     LeabraLayer @[1] {
      name="WordAction_InOut";
      n_recv_prjns=0;
      n_send_prjns=0;
      un_geom_x=12;
      un_geom_y=1;
      un_geom_n=12;
      gp_geom_x=1;
      gp_geom_y=1;
      gp_geom_n=1;
      flat_geom_x=12;
      flat_geom_y=1;
      flat_geom_n=12;
      gp_spc_x=1;
      gp_spc_y=1;
      flags=LESIONED|ICONIFIED|PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
      layer_type=INPUT;
      desc=;
      pos_rel {rel=BEHIND: other=$.networks[0].layers.gp[1][2]$: x_align=LEFT: x_off=0: y_align=FRONT: y_off=0: space=2: };
      pos {x=0: y=4: z=0: };
      pos_abs {x=14: y=4: z=0: };
      pos2d {x=0: y=4: };
      pos2d_abs {x=14: y=4: };
      disp_scale=0.85;
      un_geom {x=12: y=1: n_not_xy=0: n=12: };
      unit_groups=0;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      flat_geom {x=12: y=1: n_not_xy=0: n=12: };
      disp_geom {x=12: y=1: n_not_xy=0: n=12: };
      scaled_disp_geom {x=11: y=1: n_not_xy=0: n=11: };
      projections {
       name="projections";
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_ActionBetween";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[2][1]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[20]$: };
	dir_fixed=0;
	direction=LATERAL;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[1] {
	name="Fm_ActionNodes";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[3][1]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[19]$: };
	dir_fixed=0;
	direction=FM_OUTPUT;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
      };
      send_prjns {
       name="send_prjns";
       el_typ=LeabraPrjn;
       el_def=0;
       Projection_List @. = [0] = LeabraPrjn .networks[0].layers.gp[2][1].projections[0];
       Projection_List @. = [1] = LeabraPrjn .networks[0].layers.gp[3][1].projections[2];
      };
      unit_spec {type=LeabraUnitSpec: spec=$.networks[0].specs[0]$: };
      dist {fm_input=0: fm_output=2: };
      units_lesioned=0;
      gp_unit_names_4d=0;
      brain_area=;
      voxel_fill_pct=1;
      spec {type=LeabraLayerSpec: spec=$.networks[0].specs[4].children[0]$: };
      adapt_gi=1;
      acts_m_avg=0.0798507;
      acts_p_avg=0.07916704;
      acts_p_avg_eff=0.07916704;
     };
     LeabraLayer @[2] {
      name="WordAfter_InOut";
      n_recv_prjns=0;
      n_send_prjns=0;
      un_geom_x=13;
      un_geom_y=1;
      un_geom_n=13;
      gp_geom_x=1;
      gp_geom_y=1;
      gp_geom_n=1;
      flat_geom_x=13;
      flat_geom_y=1;
      flat_geom_n=13;
      gp_spc_x=1;
      gp_spc_y=1;
      flags=LESIONED|ICONIFIED|PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
      layer_type=INPUT;
      desc=;
      pos_rel {rel=BEHIND: other=$.networks[0].layers.gp[1][0]$: x_align=LEFT: x_off=0: y_align=FRONT: y_off=0: space=2: };
      pos {x=0: y=2: z=0: };
      pos_abs {x=14: y=2: z=0: };
      pos2d {x=0: y=2: };
      pos2d_abs {x=14: y=2: };
      disp_scale=0.85;
      un_geom {x=13: y=1: n_not_xy=0: n=13: };
      unit_groups=0;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      flat_geom {x=13: y=1: n_not_xy=0: n=13: };
      disp_geom {x=13: y=1: n_not_xy=0: n=13: };
      scaled_disp_geom {x=12: y=1: n_not_xy=0: n=12: };
      projections {
       name="projections";
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_AfterState";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=.networks[0].layers.gp[2][2]$$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[20]$: };
	dir_fixed=0;
	direction=LATERAL;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[1] {
	name="Fm_StateNodes";
	off=1;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[3][0]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[19]$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
      };
      send_prjns {
       name="send_prjns";
       el_typ=LeabraPrjn;
       el_def=0;
       Projection_List @. = [0] = LeabraPrjn .networks[0].layers.gp[2][2].projections[0];
       Projection_List @. = [1] = LeabraPrjn .networks[0].layers.gp[3][0].projections[8];
      };
      unit_spec {type=LeabraUnitSpec: spec=$.networks[0].specs[0]$: };
      dist {fm_input=0: fm_output=3: };
      units_lesioned=0;
      gp_unit_names_4d=0;
      brain_area=;
      voxel_fill_pct=1;
      spec {type=LeabraLayerSpec: spec=$.networks[0].specs[4].children[0]$: };
      adapt_gi=1;
      acts_m_avg=0.07404311;
      acts_p_avg=0.07307729;
      acts_p_avg_eff=0.07307729;
     };
    };
    Layer_Group @.gp[2] {
     name="RelationEngine";
     el_typ=LeabraLayer;
     el_def=0;
     pos {x=11: y=0: z=1: };
     pos2d {x=11: y=2: };
     max_disp_size {x=13: y=17: z=1: };
     max_disp_size2d {x=13: y=17: };
     LeabraLayer @[0] {
      name="BeforeState";
      n_recv_prjns=1;
      n_send_prjns=2;
      un_geom_x=1;
      un_geom_y=13;
      un_geom_n=13;
      gp_geom_x=1;
      gp_geom_y=1;
      gp_geom_n=1;
      flat_geom_x=1;
      flat_geom_y=13;
      flat_geom_n=13;
      gp_spc_x=1;
      gp_spc_y=1;
      flags=NO_ADD_SSE;
      layer_type=HIDDEN;
      desc=;
      pos_rel {rel=ABOVE: other=$.networks[0].layers.gp[0][0]$: x_align=RIGHT: x_off=0: y_align=FRONT: y_off=0: space=2: };
      pos {x=0: y=0: z=0: };
      pos_abs {x=11: y=0: z=1: };
      pos2d {x=0: y=0: };
      pos2d_abs {x=11: y=2: };
      disp_scale=1;
      un_geom {x=1: y=13: n_not_xy=0: n=13: };
      unit_groups=0;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      flat_geom {x=1: y=13: n_not_xy=0: n=13: };
      disp_geom {x=1: y=13: n_not_xy=0: n=13: };
      scaled_disp_geom {x=1: y=13: n_not_xy=0: n=13: };
      projections {
       name="projections";
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_WordBefore_InOut";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[1][0]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[20]$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[1] {
	name="Fm_ActRelHid";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=.networks[0].layers.gp[2][3]$$;
	spec {type=FullPrjnSpec: spec=.networks[0].specs[6]$$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=.networks[0].specs[10]$$: };
	dir_fixed=0;
	direction=FM_INPUT;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[2] {
	name="Fm_ActionBetween";
	off=1;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[2][1]$;
	spec {type=FullPrjnSpec: spec=$.networks[0].specs[6]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=.networks[0].specs[18]$$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[3] {
	name="Fm_AfterState";
	off=1;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[2][2]$;
	spec {type=FullPrjnSpec: spec=$.networks[0].specs[6]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[18]$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[4] {
	name="Fm_ActualState_Input";
	off=1;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[0][0]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[19]$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[5] {
	name="Fm_StateNodes";
	off=1;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[3][0]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[19]$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
      };
      send_prjns {
       name="send_prjns";
       el_typ=LeabraPrjn;
       el_def=0;
       Projection_List @. = [0] = LeabraPrjn .networks[0].layers.gp[2][3].projections[0];
       Projection_List @. = [1] = LeabraPrjn .networks[0].layers.gp[3][0].projections[3];
       Projection_List @. = [2] = LeabraPrjn .networks[0].layers.gp[1][0].projections[0];
       Projection_List @. = [3] = LeabraPrjn .networks[0].layers.gp[2][1].projections[3];
       Projection_List @. = [4] = LeabraPrjn .networks[0].layers.gp[2][2].projections[3];
      };
      unit_spec {type=LeabraUnitSpec: spec=$.networks[0].specs[0]$: };
      dist {fm_input=4: fm_output=3: };
      units_lesioned=0;
      gp_unit_names_4d=0;
      brain_area=;
      voxel_fill_pct=1;
      spec {type=LeabraLayerSpec: spec=.networks[0].specs[5]$$: };
      adapt_gi=1;
      acts_m_avg=0.15;
      acts_p_avg=0.15;
      acts_p_avg_eff=0.15;
     };
     LeabraLayer @[1] {
      name="ActionBetween";
      n_recv_prjns=1;
      n_send_prjns=2;
      un_geom_x=12;
      un_geom_y=1;
      un_geom_n=12;
      gp_geom_x=1;
      gp_geom_y=1;
      gp_geom_n=1;
      flat_geom_x=12;
      flat_geom_y=1;
      flat_geom_n=12;
      gp_spc_x=1;
      gp_spc_y=1;
      flags=NO_ADD_SSE;
      layer_type=HIDDEN;
      desc=;
      pos_rel {rel=BEHIND: other=$.networks[0].layers.gp[2][3]$: x_align=MIDDLE: x_off=0: y_align=FRONT: y_off=0: space=5: };
      pos {x=0: y=16: z=0: };
      pos_abs {x=11: y=16: z=1: };
      pos2d {x=0: y=16: };
      pos2d_abs {x=11: y=18: };
      disp_scale=1;
      un_geom {x=12: y=1: n_not_xy=0: n=12: };
      unit_groups=0;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      flat_geom {x=12: y=1: n_not_xy=0: n=12: };
      disp_geom {x=12: y=1: n_not_xy=0: n=12: };
      scaled_disp_geom {x=12: y=1: n_not_xy=0: n=12: };
      projections {
       name="projections";
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_WordAction_InOut";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[1][1]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[20]$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[1] {
	name="Fm_ActRelHid";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[2][3]$;
	spec {type=FullPrjnSpec: spec=$.networks[0].specs[6]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=.networks[0].specs[12]$$: };
	dir_fixed=0;
	direction=FM_INPUT;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[2] {
	name="Fm_AfterState";
	off=1;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[2][2]$;
	spec {type=FullPrjnSpec: spec=$.networks[0].specs[6]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[18]$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[3] {
	name="Fm_BeforeState";
	off=1;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[2][0]$;
	spec {type=FullPrjnSpec: spec=$.networks[0].specs[6]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[18]$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[4] {
	name="Fm_ActionNodes";
	off=1;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[3][1]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[19]$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
      };
      send_prjns {
       name="send_prjns";
       el_typ=LeabraPrjn;
       el_def=0;
       Projection_List @. = [0] = LeabraPrjn .networks[0].layers.gp[2][3].projections[1];
       Projection_List @. = [1] = LeabraPrjn .networks[0].layers.gp[1][1].projections[0];
       Projection_List @. = [2] = LeabraPrjn .networks[0].layers.gp[2][0].projections[2];
       Projection_List @. = [3] = LeabraPrjn .networks[0].layers.gp[2][2].projections[4];
       Projection_List @. = [4] = LeabraPrjn .networks[0].layers.gp[3][1].projections[1];
       Projection_List @. = [5] = LeabraPrjn .networks[0].layers.gp[0][1].projections[1];
      };
      unit_spec {type=LeabraUnitSpec: spec=$.networks[0].specs[0]$: };
      dist {fm_input=4: fm_output=2: };
      units_lesioned=0;
      gp_unit_names_4d=0;
      brain_area=;
      voxel_fill_pct=1;
      spec {type=LeabraLayerSpec: spec=$.networks[0].specs[5]$: };
      adapt_gi=1;
      acts_m_avg=0.15;
      acts_p_avg=0.15;
      acts_p_avg_eff=0.15;
     };
     LeabraLayer @[2] {
      name="AfterState";
      n_recv_prjns=2;
      n_send_prjns=2;
      un_geom_x=1;
      un_geom_y=13;
      un_geom_n=13;
      gp_geom_x=1;
      gp_geom_y=1;
      gp_geom_n=1;
      flat_geom_x=1;
      flat_geom_y=13;
      flat_geom_n=13;
      gp_spc_x=1;
      gp_spc_y=1;
      flags=NO_ADD_SSE;
      layer_type=HIDDEN;
      desc=;
      pos_rel {rel=RIGHT_OF: other=$.networks[0].layers.gp[2][3]$: x_align=LEFT: x_off=0: y_align=CENTER: y_off=0: space=2: };
      pos {x=12: y=0: z=0: };
      pos_abs {x=23: y=0: z=1: };
      pos2d {x=12: y=0: };
      pos2d_abs {x=23: y=2: };
      disp_scale=1;
      un_geom {x=1: y=13: n_not_xy=0: n=13: };
      unit_groups=0;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      flat_geom {x=1: y=13: n_not_xy=0: n=13: };
      disp_geom {x=1: y=13: n_not_xy=0: n=13: };
      scaled_disp_geom {x=1: y=13: n_not_xy=0: n=13: };
      projections {
       name="projections";
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_WordAfter_InOut";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[1][2]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[20]$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[1] {
	name="Fm_Goal_Input";
	off=1;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[0][2]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=.networks[0].specs[31]$$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[2] {
	name="Fm_ActRelHid";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[2][3]$;
	spec {type=FullPrjnSpec: spec=$.networks[0].specs[6]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=.networks[0].specs[11]$$: };
	dir_fixed=0;
	direction=LATERAL;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[3] {
	name="Fm_BeforeState";
	off=1;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[2][0]$;
	spec {type=FullPrjnSpec: spec=$.networks[0].specs[6]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[18]$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[4] {
	name="Fm_ActionBetween";
	off=1;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[2][1]$;
	spec {type=FullPrjnSpec: spec=$.networks[0].specs[6]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[18]$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[5] {
	name="Fm_StateNodes";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[3][0]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[19]$: };
	dir_fixed=0;
	direction=FM_INPUT;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
      };
      send_prjns {
       name="send_prjns";
       el_typ=LeabraPrjn;
       el_def=0;
       Projection_List @. = [0] = LeabraPrjn .networks[0].layers.gp[2][3].projections[2];
       Projection_List @. = [1] = LeabraPrjn .networks[0].layers.gp[3][0].projections[4];
       Projection_List @. = [2] = LeabraPrjn .networks[0].layers.gp[1][2].projections[0];
       Projection_List @. = [3] = LeabraPrjn .networks[0].layers.gp[2][0].projections[3];
       Projection_List @. = [4] = LeabraPrjn .networks[0].layers.gp[2][1].projections[2];
      };
      unit_spec {type=LeabraUnitSpec: spec=$.networks[0].specs[0]$: };
      dist {fm_input=2: fm_output=3: };
      units_lesioned=0;
      gp_unit_names_4d=0;
      brain_area=;
      voxel_fill_pct=1;
      spec {type=LeabraLayerSpec: spec=$.networks[0].specs[5]$: };
      adapt_gi=1;
      acts_m_avg=0.15;
      acts_p_avg=0.15;
      acts_p_avg_eff=0.15;
     };
     LeabraLayer @[3] {
      name="ActRelHid";
      n_recv_prjns=3;
      n_send_prjns=3;
      un_geom_x=7;
      un_geom_y=10;
      un_geom_n=70;
      gp_geom_x=1;
      gp_geom_y=1;
      gp_geom_n=1;
      flat_geom_x=7;
      flat_geom_y=10;
      flat_geom_n=70;
      gp_spc_x=1;
      gp_spc_y=1;
      flags=NO_ADD_SSE;
      layer_type=HIDDEN;
      desc="action-relation hidden layer";
      pos_rel {rel=RIGHT_OF: other=$.networks[0].layers.gp[2][0]$: x_align=LEFT: x_off=0: y_align=CENTER: y_off=0: space=2: };
      pos {x=3: y=1: z=0: };
      pos_abs {x=14: y=1: z=1: };
      pos2d {x=3: y=1: };
      pos2d_abs {x=14: y=3: };
      disp_scale=1;
      un_geom {x=7: y=10: n_not_xy=0: n=70: };
      unit_groups=0;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      flat_geom {x=7: y=10: n_not_xy=0: n=70: };
      disp_geom {x=7: y=10: n_not_xy=0: n=70: };
      scaled_disp_geom {x=7: y=10: n_not_xy=0: n=70: };
      projections {
       name="projections";
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_BeforeState";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[2][0]$;
	spec {type=FullPrjnSpec: spec=$.networks[0].specs[6]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=.networks[0].specs[9]$$: };
	dir_fixed=0;
	direction=LATERAL;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[1] {
	name="Fm_ActionBetween";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[2][1]$;
	spec {type=FullPrjnSpec: spec=$.networks[0].specs[6]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[9]$: };
	dir_fixed=0;
	direction=FM_OUTPUT;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[2] {
	name="Fm_AfterState";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[2][2]$;
	spec {type=FullPrjnSpec: spec=$.networks[0].specs[6]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[9]$: };
	dir_fixed=0;
	direction=FM_INPUT;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[3] {
	name="Fm_ActRelHid";
	off=1;
	disp=1;
	notes=;
	from_type=SELF;
	from=$.networks[0].layers.gp[2][3]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=.networks[0].specs[15]$$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
      };
      send_prjns {
       name="send_prjns";
       el_typ=LeabraPrjn;
       el_def=0;
       Projection_List @. = [0] = LeabraPrjn .networks[0].layers.gp[2][0].projections[1];
       Projection_List @. = [1] = LeabraPrjn .networks[0].layers.gp[2][1].projections[1];
       Projection_List @. = [2] = LeabraPrjn .networks[0].layers.gp[2][2].projections[2];
       Projection_List @. = [3] = LeabraPrjn .networks[0].layers.gp[2][3].projections[3];
      };
      unit_spec {type=LeabraUnitSpec: spec=$.networks[0].specs[0]$: };
      dist {fm_input=3: fm_output=3: };
      units_lesioned=0;
      gp_unit_names_4d=0;
      brain_area=;
      voxel_fill_pct=1;
      spec {type=LeabraLayerSpec: spec=.networks[0].specs[4]$$: };
      adapt_gi=1;
      acts_m_avg=0.15;
      acts_p_avg=0.15;
      acts_p_avg_eff=0.15;
     };
    };
    Layer_Group @.gp[3] {
     name="SemAssoc";
     el_typ=LeabraLayer;
     el_def=0;
     pos {x=0: y=0: z=1: };
     pos2d {x=0: y=2: };
     max_disp_size {x=5: y=18: z=1: };
     max_disp_size2d {x=5: y=18: };
     LeabraLayer @[0] {
      name="StateNodes";
      n_recv_prjns=5;
      n_send_prjns=3;
      un_geom_x=1;
      un_geom_y=1;
      un_geom_n=1;
      gp_geom_x=3;
      gp_geom_y=5;
      gp_geom_n=15;
      flat_geom_x=3;
      flat_geom_y=5;
      flat_geom_n=15;
      gp_spc_x=1;
      gp_spc_y=1;
      flags=NO_ADD_SSE;
      layer_type=HIDDEN;
      desc=;
      pos_rel {rel=ABOVE: other=$.networks[0].layers.gp[0][0]$: x_align=LEFT: x_off=0: y_align=FRONT: y_off=0: space=2: };
      pos {x=0: y=0: z=0: };
      pos_abs {x=0: y=0: z=1: };
      pos2d {x=0: y=0: };
      pos2d_abs {x=0: y=2: };
      disp_scale=1;
      un_geom {x=1: y=1: n_not_xy=0: n=1: };
      unit_groups=1;
      gp_geom {x=3: y=5: n_not_xy=0: n=15: };
      gp_spc {x=1: y=1: };
      flat_geom {x=3: y=5: n_not_xy=0: n=15: };
      disp_geom {x=5: y=9: n_not_xy=0: n=60: };
      scaled_disp_geom {x=5: y=9: n_not_xy=0: n=45: };
      projections {
       name="projections";
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_ActionNodes";
	off=1;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[3][1]$;
	spec {type=FullPrjnSpec: spec=$.networks[0].specs[6]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=.networks[0].specs[16]$$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[1] {
	name="Fm_StateNodes";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[3][0]$;
	spec {type=FullPrjnSpec: spec=$.networks[0].specs[6]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[16]$: };
	dir_fixed=0;
	direction=LATERAL;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[2] {
	name="Fm_StateNodes_6";
	off=1;
	disp=1;
	notes=;
	from_type=SELF;
	from=$.networks[0].layers.gp[3][0]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=.networks[0].specs[30]$$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[3] {
	name="Fm_BeforeState";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[2][0]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[19]$: };
	dir_fixed=0;
	direction=LATERAL;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[4] {
	name="Fm_AfterState";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[2][2]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[19]$: };
	dir_fixed=0;
	direction=LATERAL;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[5] {
	name="Fm_ActualState_Input";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[0][0]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=.networks[0].specs[26]$$: };
	dir_fixed=0;
	direction=FM_INPUT;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[6] {
	name="Fm_Goal_Input";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[0][2]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[26]$: };
	dir_fixed=0;
	direction=FM_INPUT;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[7] {
	name="Fm_WordBefore_InOut";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[1][0]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[19]$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[8] {
	name="Fm_WordAfter_InOut";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[1][2]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[19]$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
      };
      send_prjns {
       name="send_prjns";
       el_typ=LeabraPrjn;
       el_def=0;
       Projection_List @. = [0] = LeabraPrjn .networks[0].layers.gp[3][0].projections[1];
       Projection_List @. = [1] = LeabraPrjn .networks[0].layers.gp[3][1].projections[0];
       Projection_List @. = [2] = LeabraPrjn .networks[0].layers.gp[2][0].projections[5];
       Projection_List @. = [3] = LeabraPrjn .networks[0].layers.gp[2][2].projections[5];
       Projection_List @. = [4] = LeabraPrjn .networks[0].layers.gp[3][0].projections[2];
       Projection_List @. = [5] = LeabraPrjn .networks[0].layers.gp[1][0].projections[1];
       Projection_List @. = [6] = LeabraPrjn .networks[0].layers.gp[1][2].projections[1];
      };
      unit_spec {type=LeabraUnitSpec: spec=$.networks[0].specs[0]$: };
      dist {fm_input=1: fm_output=2: };
      units_lesioned=0;
      gp_unit_names_4d=0;
      brain_area=;
      voxel_fill_pct=1;
      spec {type=LeabraLayerSpec: spec=.networks[0].specs[2]$$: };
      adapt_gi=1;
      acts_m_avg=0.15;
      acts_p_avg=0.15;
      acts_p_avg_eff=0.15;
     };
     LeabraLayer @[1] {
      name="ActionNodes";
      n_recv_prjns=2;
      n_send_prjns=1;
      un_geom_x=1;
      un_geom_y=1;
      un_geom_n=1;
      gp_geom_x=3;
      gp_geom_y=4;
      gp_geom_n=12;
      flat_geom_x=3;
      flat_geom_y=4;
      flat_geom_n=12;
      gp_spc_x=1;
      gp_spc_y=1;
      flags=NO_ADD_SSE;
      layer_type=HIDDEN;
      desc=;
      pos_rel {rel=BEHIND: other=$.networks[0].layers.gp[3][0]$: x_align=LEFT: x_off=0: y_align=FRONT: y_off=0: space=2: };
      pos {x=0: y=11: z=0: };
      pos_abs {x=0: y=11: z=1: };
      pos2d {x=0: y=11: };
      pos2d_abs {x=0: y=13: };
      disp_scale=1;
      un_geom {x=1: y=1: n_not_xy=0: n=1: };
      unit_groups=1;
      gp_geom {x=3: y=4: n_not_xy=0: n=12: };
      gp_spc {x=1: y=1: };
      flat_geom {x=3: y=4: n_not_xy=0: n=12: };
      disp_geom {x=5: y=7: n_not_xy=0: n=48: };
      scaled_disp_geom {x=5: y=7: n_not_xy=0: n=35: };
      projections {
       name="projections";
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_StateNodes";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[3][0]$;
	spec {type=FullPrjnSpec: spec=$.networks[0].specs[6]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=.networks[0].specs[17]$$: };
	dir_fixed=0;
	direction=FM_INPUT;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[1] {
	name="Fm_ActionBetween";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[2][1]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[19]$: };
	dir_fixed=0;
	direction=LATERAL;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
       LeabraPrjn @[2] {
	name="Fm_WordAction_InOut";
	off=0;
	disp=1;
	notes=;
	from_type=CUSTOM;
	from=$.networks[0].layers.gp[1][1]$;
	spec {type=OneToOnePrjnSpec: spec=$.networks[0].specs[7]$: };
	con_type=LeabraCon;
	con_spec {type=LeabraConSpec: spec=$.networks[0].specs[19]$: };
	dir_fixed=0;
	direction=DIR_UNKNOWN;
	prjn_clr {r=1: g=0.9: b=0.5: a=1: };
       };
      };
      send_prjns {
       name="send_prjns";
       el_typ=LeabraPrjn;
       el_def=0;
       Projection_List @. = [0] = LeabraPrjn .networks[0].layers.gp[3][0].projections[0];
       Projection_List @. = [1] = LeabraPrjn .networks[0].layers.gp[0][1].projections[0];
       Projection_List @. = [2] = LeabraPrjn .networks[0].layers.gp[2][1].projections[4];
       Projection_List @. = [3] = LeabraPrjn .networks[0].layers.gp[1][1].projections[1];
      };
      unit_spec {type=LeabraUnitSpec: spec=$.networks[0].specs[0]$: };
      dist {fm_input=2: fm_output=1: };
      units_lesioned=0;
      gp_unit_names_4d=0;
      brain_area=;
      voxel_fill_pct=1;
      spec {type=LeabraLayerSpec: spec=.networks[0].specs[3]$$: };
      adapt_gi=1;
      acts_m_avg=0.15;
      acts_p_avg=0.15;
      acts_p_avg_eff=0.15;
     };
    };
    Layer_Group @.gp[4] {
     name="TempLesion";
     el_typ=LeabraLayer;
     el_def=0;
     pos {x=0: y=0: z=0: };
     pos2d {x=0: y=0: };
     max_disp_size {x=1: y=1: z=1: };
     max_disp_size2d {x=1: y=1: };
    };
   };
   weights {
    name="weights";
    el_typ=Weights;
    el_def=0;
   };
   auto_build=AUTO_BUILD;
   auto_load_wts=NO_AUTO_LOAD;
   auto_load_file=;
   brain_atlas_name=;
   cuda {sync_units=0: sync_cons=0: min_threads=32: max_threads=1024: cons_per_thread=2: timers_on=0: n_threads=32: };
   wt_save_fmt=TEXT;
   max_disp_size {x=24: y=18: z=2: };
   max_disp_size2d {x=24: y=20: };
   times {quarter=25: deep_cyc=5: time_inc=0.001: wt_bal_int=10: minus=75: plus=25: total_cycles=100: thal_gate_cycle=-2: };
   lstats {trg_max_act_crit=0.5: off_errs=1: on_errs=1: agg_unlearnable=0: wt_bal=0: };
   net_misc {spike=0: deep=0: bias_learn=0: trial_decay=0: diff_scale_p=0: diff_scale_q1=0: wt_bal=0: lay_gp_inhib=0: inhib_cons=0: };
   deep {on=0: ctxt=0: raw_net=0: mod_net=0: raw_qtr=0: };
   rel_netin {on=1: trl_skip=10: epc_skip=10: };
  };
 };
};
